"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDropdown = exports.useTextArea = exports.useInputUnsignedBalance = exports.useInputUnsignedInt = exports.useInputPrivateKey = exports.useInputAddress = exports.useInputString = exports.useInputBase = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const cryptography_1 = require("@mysten/sui/cryptography");
const react_1 = require("react");
const suitcase_core_1 = require("@polymedia/suitcase-core");
/**
 * A base hook for creating `<input>` fields.
 */
const useInputBase = (props) => {
    const html = props.html ?? {};
    const [str, setStr] = (0, react_1.useState)(`${html.value ?? ""}`);
    const [val, setVal] = (0, react_1.useState)();
    const [err, setErr] = (0, react_1.useState)(null);
    const handleInputEvent = (e) => {
        // prevent input of invalid characters
        const newStr = e.target.value;
        if (html.pattern && !new RegExp(html.pattern).test(newStr)) {
            return;
        }
        setStr(newStr);
        validateAndUpdateValue(newStr);
        if (html.onChange) {
            html.onChange(e);
        }
    };
    const validateAndUpdateValue = (newStr) => {
        const trimStr = newStr.trim();
        if (html.required && trimStr === "") {
            setErr(props.msgRequired ?? "Input is required");
            setVal(undefined);
        }
        else {
            try {
                const validation = props.validate(trimStr);
                setErr(validation.err);
                setVal(validation.val);
            }
            catch (err) {
                const errMsg = err instanceof Error ? err.message : "Validation failed";
                setErr(errMsg);
                setVal(undefined);
            }
        }
    };
    const clear = () => {
        setStr("");
        setVal(undefined);
        setErr(null);
    };
    (0, react_1.useEffect)(() => {
        validateAndUpdateValue(str);
    }, props.deps);
    // Notify parent of value changes
    (0, react_1.useEffect)(() => {
        if (props.onChangeVal) {
            props.onChangeVal(val);
        }
    }, [val, props.onChangeVal]);
    const input = ((0, jsx_runtime_1.jsxs)("div", { className: "poly-input", children: [props.label &&
                (0, jsx_runtime_1.jsx)("div", { className: "input-label", children: props.label }), (0, jsx_runtime_1.jsx)("input", { className: `input ${err !== null ? "error" : ""}`, ...html, onChange: handleInputEvent, value: str, spellCheck: false, autoCorrect: "off", autoCapitalize: "off", autoComplete: "off" }), err &&
                (0, jsx_runtime_1.jsx)("div", { className: "input-error", children: err })] }));
    return { str, val, err, input, clear };
};
exports.useInputBase = useInputBase;
/**
 * An input field for strings.
 */
const useInputString = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "text";
    html.pattern = undefined;
    const textEncoder = new TextEncoder();
    const validate = (input) => {
        if (props.minLength && input.length > 0 && input.length < props.minLength) {
            return { err: props.msgTooShort ?? "Too short", val: undefined };
        }
        if (props.maxLength && input.length > 0 && input.length > props.maxLength) {
            return { err: props.msgTooLong ?? "Too long", val: undefined };
        }
        if (props.minBytes && input.length > 0 && textEncoder.encode(input).length < props.minBytes) {
            return { err: props.msgTooShort ?? "Too short", val: undefined };
        }
        if (props.maxBytes && input.length > 0 && textEncoder.encode(input).length > props.maxBytes) {
            return { err: props.msgTooLong ?? "Too long", val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? input);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? input };
    };
    return (0, exports.useInputBase)({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
exports.useInputString = useInputString;
/**
 * An input field for Sui addresses (or object IDs).
 */
const useInputAddress = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "text";
    html.pattern = `^${suitcase_core_1.REGEX_ADDRESS_NORMALIZED}$`;
    const validate = (input) => {
        const addr = (0, suitcase_core_1.validateAndNormalizeAddress)(input);
        if (!addr) {
            return { err: "Invalid Sui address", val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? addr);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? addr };
    };
    return (0, exports.useInputBase)({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
exports.useInputAddress = useInputAddress;
/**
 * An input field for Sui private keys that produces a Sui Keypair.
 */
const useInputPrivateKey = (props) => {
    const html = props.html ?? {};
    html.type = "password";
    html.inputMode = "text";
    html.pattern = `^(${cryptography_1.SUI_PRIVATE_KEY_PREFIX}.+)?$`;
    const lastValidate = (0, react_1.useRef)(undefined);
    const validate = (input) => {
        if (input === "") {
            return { err: null, val: undefined };
        }
        // Avoid creating a new object which will trigger a rerender
        if (lastValidate.current?.input === input) {
            return lastValidate.current.result;
        }
        let result;
        try {
            const pair = (0, suitcase_core_1.pairFromSecretKey)(input);
            const inputRes = props.validateInput?.(input);
            if (inputRes?.err) {
                return inputRes;
            }
            const valueRes = props.validateValue?.(inputRes?.val ?? pair);
            if (valueRes?.err) {
                return valueRes;
            }
            result = { err: null, val: valueRes?.val ?? inputRes?.val ?? pair };
        }
        catch (_err) {
            result = { err: "Invalid private key", val: undefined };
        }
        lastValidate.current = { input, result };
        return result;
    };
    return (0, exports.useInputBase)({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
exports.useInputPrivateKey = useInputPrivateKey;
/**
 * An input field for positive integers.
 */
const useInputUnsignedInt = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "numeric";
    html.pattern = "^[0-9]*$";
    const validate = (input) => {
        if (input === "") {
            return { err: null, val: undefined };
        }
        const numValue = Number(input);
        if (isNaN(numValue) || numValue < 0) {
            return { err: "Invalid number", val: undefined };
        }
        if (props.min !== undefined && numValue < props.min) {
            return { err: props.msgTooSmall ?? `Minimum value is ${props.min}`, val: undefined };
        }
        if (props.max !== undefined && numValue > props.max) {
            return { err: props.msgTooLarge ?? `Maximum value is ${props.max}`, val: undefined };
        }
        if (numValue > Number.MAX_SAFE_INTEGER) {
            return { err: "Number is too large", val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? numValue);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? numValue };
    };
    return (0, exports.useInputBase)({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
exports.useInputUnsignedInt = useInputUnsignedInt;
/**
 * Input field for positive Coin balances. Handles decimals (e.g. `"1 SUI"` â†’ `1_000_000_000`).
 */
const useInputUnsignedBalance = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "decimal";
    html.pattern = `^[0-9]*\\.?[0-9]{0,${props.decimals}}$`;
    const max = props.max ?? suitcase_core_1.MAX_U64;
    const validate = (input) => {
        if (input === "" || input === ".") {
            return { err: null, val: undefined };
        }
        const bigInput = (0, suitcase_core_1.stringToBalance)(input, props.decimals);
        if (props.min !== undefined && bigInput < props.min) {
            return { err: props.msgTooSmall ?? `Minimum value is ${(0, suitcase_core_1.formatBalance)(props.min, props.decimals)}`, val: undefined };
        }
        if (max !== undefined && bigInput > max) {
            return { err: props.msgTooLarge ?? `Maximum value is ${(0, suitcase_core_1.formatBalance)(max, props.decimals)}`, val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? bigInput);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? bigInput };
    };
    return (0, exports.useInputBase)({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
exports.useInputUnsignedBalance = useInputUnsignedBalance;
/**
 * A <textarea> field with custom validation.
 */
const useTextArea = (props) => {
    const html = props.html ?? {};
    const [str, setStr] = (0, react_1.useState)(`${html.value ?? ""}`);
    const [val, setVal] = (0, react_1.useState)();
    const [err, setErr] = (0, react_1.useState)(null);
    // Handle user input
    const onChangeTextArea = (e) => {
        const newStr = e.target.value;
        setStr(newStr);
        onChangeStr(newStr);
        if (html.onChange) {
            html.onChange(e);
        }
    };
    // Validate and update state
    const onChangeStr = (newStr) => {
        const trimStr = newStr.trim();
        if (html.required && trimStr === "") {
            setErr(props.msgRequired ?? "Input is required");
            setVal(undefined);
        }
        else {
            try {
                const validation = props.validateInput(trimStr);
                setErr(validation.err);
                setVal(validation.val);
            }
            catch (err) {
                const errMsg = err instanceof Error ? err.message : "Validation failed";
                setErr(errMsg);
                setVal(undefined);
            }
        }
    };
    const clear = () => {
        setStr("");
        setVal(undefined);
        setErr(null);
    };
    (0, react_1.useEffect)(() => {
        onChangeStr(str);
    }, props.deps);
    // Notify parent of value changes
    (0, react_1.useEffect)(() => {
        if (props.onChangeVal) {
            props.onChangeVal(val);
        }
    }, [val, props.onChangeVal]);
    const input = ((0, jsx_runtime_1.jsxs)("div", { className: "poly-input", children: [props.label &&
                (0, jsx_runtime_1.jsx)("div", { className: "input-label", children: props.label }), (0, jsx_runtime_1.jsx)("textarea", { className: `input ${err !== null ? "error" : ""}`, ...html, onChange: onChangeTextArea, value: str, spellCheck: false, autoCorrect: "off", autoCapitalize: "off", autoComplete: "off" }), err &&
                (0, jsx_runtime_1.jsx)("div", { className: "input-error", children: err })] }));
    return { str, val, err, input, clear };
};
exports.useTextArea = useTextArea;
/**
 * A <select> dropdown.
 */
const useDropdown = (props) => {
    const html = props.html ?? {};
    const [val, setVal] = (0, react_1.useState)(html.value);
    const [err, setErr] = (0, react_1.useState)(null);
    const validate = (newVal) => {
        if (html.required && !newVal) {
            setErr(props.msgRequired ?? "Selection required");
        }
        else {
            setErr(null);
        }
    };
    const onChange = (e) => {
        const newVal = e.target.value === "" ? undefined : e.target.value;
        setVal(newVal);
        validate(newVal);
        if (props.onChangeVal) {
            props.onChangeVal(newVal);
        }
    };
    (0, react_1.useEffect)(() => {
        validate(val);
    }, [props]);
    const input = ((0, jsx_runtime_1.jsxs)("div", { className: "poly-input", children: [props.label &&
                (0, jsx_runtime_1.jsx)("div", { className: "input-label", children: props.label }), (0, jsx_runtime_1.jsxs)("select", { className: `input ${err !== null ? "error" : ""}`, ...html, onChange: onChange, value: val ?? "", children: [(0, jsx_runtime_1.jsx)("option", { value: "", children: "Select..." }), props.options.map(option => ((0, jsx_runtime_1.jsx)("option", { value: option.value, children: option.label }, String(option.value))))] }), err &&
                (0, jsx_runtime_1.jsx)("div", { className: "input-error", children: err })] }));
    return {
        val,
        err,
        input,
        clear: () => {
            setVal(undefined);
            validate(undefined);
        }
    };
};
exports.useDropdown = useDropdown;
//# sourceMappingURL=inputs.js.map