"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BtnPrevNext = exports.BtnLinkInternal = exports.BtnLinkExternal = exports.BtnSubmit = exports.Btn = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_router_dom_1 = require("react-router-dom");
const links_1 = require("./links");
/**
 * A button component.
 */
const Btn = ({ onClick, children, disabled = undefined, className = undefined, }) => {
    const [working, setIsWorking] = (0, react_1.useState)(false);
    disabled = disabled || working;
    const handleClick = async () => {
        try {
            setIsWorking(true);
            await onClick();
        }
        finally {
            setIsWorking(false);
        }
    };
    return ((0, jsx_runtime_1.jsx)("button", { onClick: handleClick, className: `btn ${working ? "working" : ""} ${className ?? ""}`, disabled: disabled, children: children }));
};
exports.Btn = Btn;
const BtnSubmit = (props) => {
    return ((0, jsx_runtime_1.jsx)("div", { className: "btn-submit", children: (0, jsx_runtime_1.jsx)(exports.Btn, { ...props }) }));
};
exports.BtnSubmit = BtnSubmit;
const BtnLinkExternal = (props) => {
    let className = "btn";
    if (props.className) {
        className += ` ${props.className}`;
    }
    if (props.disabled) {
        className += " disabled";
    }
    return ((0, jsx_runtime_1.jsx)("div", { className: "btn-submit", children: (0, jsx_runtime_1.jsx)(links_1.LinkExternal, { ...props, className: className }) }));
};
exports.BtnLinkExternal = BtnLinkExternal;
exports.BtnLinkInternal = (0, react_1.forwardRef)((props, ref) => {
    let className = "btn";
    if (props.className) {
        className += ` ${props.className}`;
    }
    if (props.disabled) {
        className += " disabled";
    }
    return ((0, jsx_runtime_1.jsx)("div", { className: "btn-submit", children: (0, jsx_runtime_1.jsx)(react_router_dom_1.Link, { ...props, className: className, ref: ref }) }));
});
/**
 * A button component to navigate through paginated data (see `useFetchAndPaginate()`).
 */
const BtnPrevNext = ({ data, onPageChange, scrollToRefOnPageChange, }) => {
    if (!data.hasMultiplePages) {
        return null;
    }
    const handlePageChange = () => {
        if (scrollToRefOnPageChange?.current) {
            const navBarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--nav-bar-height"));
            const extraOffset = 9;
            const totalOffset = navBarHeight + extraOffset;
            const yOffset = scrollToRefOnPageChange.current.getBoundingClientRect().top + window.scrollY - totalOffset;
            window.scrollTo({ top: yOffset });
        }
        onPageChange?.();
    };
    const handlePrevClick = () => {
        data.goToPreviousPage();
        handlePageChange();
        return Promise.resolve();
    };
    const handleNextClick = async () => {
        await data.goToNextPage();
        handlePageChange();
        return Promise.resolve();
    };
    return ((0, jsx_runtime_1.jsxs)("div", { className: "btn-prev-next", children: [(0, jsx_runtime_1.jsx)(exports.Btn, { disabled: data.isLoading || data.isFirstPage, onClick: handlePrevClick, children: "PREV" }), (0, jsx_runtime_1.jsx)(exports.Btn, { disabled: data.isLoading || (data.isLastPage && !data.hasNextPage), onClick: handleNextClick, children: "NEXT" })] }));
};
exports.BtnPrevNext = BtnPrevNext;
//# sourceMappingURL=buttons.js.map