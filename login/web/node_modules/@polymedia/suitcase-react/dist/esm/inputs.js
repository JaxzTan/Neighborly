import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { SUI_PRIVATE_KEY_PREFIX } from "@mysten/sui/cryptography";
import { useEffect, useRef, useState } from "react";
import { formatBalance, MAX_U64, pairFromSecretKey, REGEX_ADDRESS_NORMALIZED, stringToBalance, validateAndNormalizeAddress } from "@polymedia/suitcase-core";
/**
 * A base hook for creating `<input>` fields.
 */
export const useInputBase = (props) => {
    const html = props.html ?? {};
    const [str, setStr] = useState(`${html.value ?? ""}`);
    const [val, setVal] = useState();
    const [err, setErr] = useState(null);
    const handleInputEvent = (e) => {
        // prevent input of invalid characters
        const newStr = e.target.value;
        if (html.pattern && !new RegExp(html.pattern).test(newStr)) {
            return;
        }
        setStr(newStr);
        validateAndUpdateValue(newStr);
        if (html.onChange) {
            html.onChange(e);
        }
    };
    const validateAndUpdateValue = (newStr) => {
        const trimStr = newStr.trim();
        if (html.required && trimStr === "") {
            setErr(props.msgRequired ?? "Input is required");
            setVal(undefined);
        }
        else {
            try {
                const validation = props.validate(trimStr);
                setErr(validation.err);
                setVal(validation.val);
            }
            catch (err) {
                const errMsg = err instanceof Error ? err.message : "Validation failed";
                setErr(errMsg);
                setVal(undefined);
            }
        }
    };
    const clear = () => {
        setStr("");
        setVal(undefined);
        setErr(null);
    };
    useEffect(() => {
        validateAndUpdateValue(str);
    }, props.deps);
    // Notify parent of value changes
    useEffect(() => {
        if (props.onChangeVal) {
            props.onChangeVal(val);
        }
    }, [val, props.onChangeVal]);
    const input = (_jsxs("div", { className: "poly-input", children: [props.label &&
                _jsx("div", { className: "input-label", children: props.label }), _jsx("input", { className: `input ${err !== null ? "error" : ""}`, ...html, onChange: handleInputEvent, value: str, spellCheck: false, autoCorrect: "off", autoCapitalize: "off", autoComplete: "off" }), err &&
                _jsx("div", { className: "input-error", children: err })] }));
    return { str, val, err, input, clear };
};
/**
 * An input field for strings.
 */
export const useInputString = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "text";
    html.pattern = undefined;
    const textEncoder = new TextEncoder();
    const validate = (input) => {
        if (props.minLength && input.length > 0 && input.length < props.minLength) {
            return { err: props.msgTooShort ?? "Too short", val: undefined };
        }
        if (props.maxLength && input.length > 0 && input.length > props.maxLength) {
            return { err: props.msgTooLong ?? "Too long", val: undefined };
        }
        if (props.minBytes && input.length > 0 && textEncoder.encode(input).length < props.minBytes) {
            return { err: props.msgTooShort ?? "Too short", val: undefined };
        }
        if (props.maxBytes && input.length > 0 && textEncoder.encode(input).length > props.maxBytes) {
            return { err: props.msgTooLong ?? "Too long", val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? input);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? input };
    };
    return useInputBase({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
/**
 * An input field for Sui addresses (or object IDs).
 */
export const useInputAddress = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "text";
    html.pattern = `^${REGEX_ADDRESS_NORMALIZED}$`;
    const validate = (input) => {
        const addr = validateAndNormalizeAddress(input);
        if (!addr) {
            return { err: "Invalid Sui address", val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? addr);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? addr };
    };
    return useInputBase({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
/**
 * An input field for Sui private keys that produces a Sui Keypair.
 */
export const useInputPrivateKey = (props) => {
    const html = props.html ?? {};
    html.type = "password";
    html.inputMode = "text";
    html.pattern = `^(${SUI_PRIVATE_KEY_PREFIX}.+)?$`;
    const lastValidate = useRef(undefined);
    const validate = (input) => {
        if (input === "") {
            return { err: null, val: undefined };
        }
        // Avoid creating a new object which will trigger a rerender
        if (lastValidate.current?.input === input) {
            return lastValidate.current.result;
        }
        let result;
        try {
            const pair = pairFromSecretKey(input);
            const inputRes = props.validateInput?.(input);
            if (inputRes?.err) {
                return inputRes;
            }
            const valueRes = props.validateValue?.(inputRes?.val ?? pair);
            if (valueRes?.err) {
                return valueRes;
            }
            result = { err: null, val: valueRes?.val ?? inputRes?.val ?? pair };
        }
        catch (_err) {
            result = { err: "Invalid private key", val: undefined };
        }
        lastValidate.current = { input, result };
        return result;
    };
    return useInputBase({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
/**
 * An input field for positive integers.
 */
export const useInputUnsignedInt = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "numeric";
    html.pattern = "^[0-9]*$";
    const validate = (input) => {
        if (input === "") {
            return { err: null, val: undefined };
        }
        const numValue = Number(input);
        if (isNaN(numValue) || numValue < 0) {
            return { err: "Invalid number", val: undefined };
        }
        if (props.min !== undefined && numValue < props.min) {
            return { err: props.msgTooSmall ?? `Minimum value is ${props.min}`, val: undefined };
        }
        if (props.max !== undefined && numValue > props.max) {
            return { err: props.msgTooLarge ?? `Maximum value is ${props.max}`, val: undefined };
        }
        if (numValue > Number.MAX_SAFE_INTEGER) {
            return { err: "Number is too large", val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? numValue);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? numValue };
    };
    return useInputBase({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
/**
 * Input field for positive Coin balances. Handles decimals (e.g. `"1 SUI"` â†’ `1_000_000_000`).
 */
export const useInputUnsignedBalance = (props) => {
    const html = props.html ?? {};
    html.type = "text";
    html.inputMode = "decimal";
    html.pattern = `^[0-9]*\\.?[0-9]{0,${props.decimals}}$`;
    const max = props.max ?? MAX_U64;
    const validate = (input) => {
        if (input === "" || input === ".") {
            return { err: null, val: undefined };
        }
        const bigInput = stringToBalance(input, props.decimals);
        if (props.min !== undefined && bigInput < props.min) {
            return { err: props.msgTooSmall ?? `Minimum value is ${formatBalance(props.min, props.decimals)}`, val: undefined };
        }
        if (max !== undefined && bigInput > max) {
            return { err: props.msgTooLarge ?? `Maximum value is ${formatBalance(max, props.decimals)}`, val: undefined };
        }
        const inputRes = props.validateInput?.(input);
        if (inputRes?.err) {
            return inputRes;
        }
        const valueRes = props.validateValue?.(inputRes?.val ?? bigInput);
        if (valueRes?.err) {
            return valueRes;
        }
        return { err: null, val: valueRes?.val ?? inputRes?.val ?? bigInput };
    };
    return useInputBase({
        html,
        validate,
        ...props,
        deps: [props],
    });
};
/**
 * A <textarea> field with custom validation.
 */
export const useTextArea = (props) => {
    const html = props.html ?? {};
    const [str, setStr] = useState(`${html.value ?? ""}`);
    const [val, setVal] = useState();
    const [err, setErr] = useState(null);
    // Handle user input
    const onChangeTextArea = (e) => {
        const newStr = e.target.value;
        setStr(newStr);
        onChangeStr(newStr);
        if (html.onChange) {
            html.onChange(e);
        }
    };
    // Validate and update state
    const onChangeStr = (newStr) => {
        const trimStr = newStr.trim();
        if (html.required && trimStr === "") {
            setErr(props.msgRequired ?? "Input is required");
            setVal(undefined);
        }
        else {
            try {
                const validation = props.validateInput(trimStr);
                setErr(validation.err);
                setVal(validation.val);
            }
            catch (err) {
                const errMsg = err instanceof Error ? err.message : "Validation failed";
                setErr(errMsg);
                setVal(undefined);
            }
        }
    };
    const clear = () => {
        setStr("");
        setVal(undefined);
        setErr(null);
    };
    useEffect(() => {
        onChangeStr(str);
    }, props.deps);
    // Notify parent of value changes
    useEffect(() => {
        if (props.onChangeVal) {
            props.onChangeVal(val);
        }
    }, [val, props.onChangeVal]);
    const input = (_jsxs("div", { className: "poly-input", children: [props.label &&
                _jsx("div", { className: "input-label", children: props.label }), _jsx("textarea", { className: `input ${err !== null ? "error" : ""}`, ...html, onChange: onChangeTextArea, value: str, spellCheck: false, autoCorrect: "off", autoCapitalize: "off", autoComplete: "off" }), err &&
                _jsx("div", { className: "input-error", children: err })] }));
    return { str, val, err, input, clear };
};
/**
 * A <select> dropdown.
 */
export const useDropdown = (props) => {
    const html = props.html ?? {};
    const [val, setVal] = useState(html.value);
    const [err, setErr] = useState(null);
    const validate = (newVal) => {
        if (html.required && !newVal) {
            setErr(props.msgRequired ?? "Selection required");
        }
        else {
            setErr(null);
        }
    };
    const onChange = (e) => {
        const newVal = e.target.value === "" ? undefined : e.target.value;
        setVal(newVal);
        validate(newVal);
        if (props.onChangeVal) {
            props.onChangeVal(newVal);
        }
    };
    useEffect(() => {
        validate(val);
    }, [props]);
    const input = (_jsxs("div", { className: "poly-input", children: [props.label &&
                _jsx("div", { className: "input-label", children: props.label }), _jsxs("select", { className: `input ${err !== null ? "error" : ""}`, ...html, onChange: onChange, value: val ?? "", children: [_jsx("option", { value: "", children: "Select..." }), props.options.map(option => (_jsx("option", { value: option.value, children: option.label }, String(option.value))))] }), err &&
                _jsx("div", { className: "input-error", children: err })] }));
    return {
        val,
        err,
        input,
        clear: () => {
            setVal(undefined);
            validate(undefined);
        }
    };
};
//# sourceMappingURL=inputs.js.map