"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinMetaFetcher = void 0;
const utils_1 = require("@mysten/sui/utils");
/**
 * Fetch coin metadata from the RPC and cache it.
 */
class CoinMetaFetcher {
    client;
    cache = new Map();
    constructor({ client, preloadUrl = "https://coinmeta.polymedia.app/api/data.json", preloadData, }) {
        this.client = client;
        if (preloadData) {
            preloadData.forEach(coinMeta => {
                this.cache.set(coinMeta.type, coinMeta);
            });
        }
        if (preloadUrl) {
            (async () => {
                try {
                    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument */
                    const resp = await fetch(preloadUrl);
                    const data = await resp.json();
                    if (!Array.isArray(data)) {
                        throw new Error("Invalid preload data");
                    }
                    for (const m of data) {
                        if (typeof m !== "object" || m === null) {
                            throw new Error("Invalid preload data");
                        }
                        if (typeof m.type !== "string" ||
                            typeof m.symbol !== "string" ||
                            typeof m.decimals !== "number" ||
                            typeof m.name !== "string" ||
                            typeof m.description !== "string" ||
                            (m.id !== undefined && typeof m.id !== "string" && m.id !== null) ||
                            (m.iconUrl !== undefined && typeof m.iconUrl !== "string" && m.iconUrl !== null)) {
                            continue;
                        }
                        this.cache.set(m.type, m);
                    }
                    /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument */
                }
                catch (err) {
                    console.warn(`Failed to preload coin metadata from "${preloadUrl}":`, err);
                }
            })();
        }
    }
    async getCoinMeta(coinType) {
        const normalizedType = (0, utils_1.normalizeStructTag)(coinType);
        const cachedMeta = this.cache.get(normalizedType);
        if (cachedMeta !== undefined) {
            return cachedMeta;
        }
        const rawMeta = await this.client.getCoinMetadata({ coinType: normalizedType });
        const coinMeta = !rawMeta ? null : {
            id: rawMeta.id ?? null,
            type: normalizedType,
            symbol: rawMeta.symbol,
            decimals: rawMeta.decimals,
            name: rawMeta.name,
            description: rawMeta.description,
            iconUrl: rawMeta.iconUrl ?? null,
        };
        this.cache.set(normalizedType, coinMeta);
        return coinMeta;
    }
    async getCoinMetas(coinTypes) {
        const uniqueTypes = Array.from(new Set(coinTypes.map(coinType => (0, utils_1.normalizeStructTag)(coinType))));
        const results = await Promise.allSettled(uniqueTypes.map(coinType => this.getCoinMeta(coinType)));
        const metas = new Map();
        results.forEach((result, index) => {
            metas.set(uniqueTypes[index], result.status === "fulfilled" ? result.value : null);
        });
        return metas;
    }
}
exports.CoinMetaFetcher = CoinMetaFetcher;
//# sourceMappingURL=coins.js.map