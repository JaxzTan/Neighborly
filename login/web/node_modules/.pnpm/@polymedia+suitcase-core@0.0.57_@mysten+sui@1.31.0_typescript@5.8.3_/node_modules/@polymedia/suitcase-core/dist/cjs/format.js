"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shortenDigest = exports.urlToDomain = exports.formatDuration = exports.formatDate = exports.formatBps = exports.TimeUnit = void 0;
exports.formatTimeDiff = formatTimeDiff;
/** Time units in milliseconds. */
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["ONE_SECOND"] = 1000] = "ONE_SECOND";
    TimeUnit[TimeUnit["ONE_MINUTE"] = 60000] = "ONE_MINUTE";
    TimeUnit[TimeUnit["ONE_HOUR"] = 3600000] = "ONE_HOUR";
    TimeUnit[TimeUnit["ONE_DAY"] = 86400000] = "ONE_DAY";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * Return a human-readable string from a number of basis points.
 * E.g. "100 bps" -> "1%".
 */
const formatBps = (bps) => {
    return `${bps / 100}%`;
};
exports.formatBps = formatBps;
/**
 * Return a human-readable date string from a timestamp in milliseconds.
 */
const formatDate = (ms) => {
    return new Date(ms).toLocaleString();
};
exports.formatDate = formatDate;
/**
 * Return a human-readable string from a number of milliseconds.
 * E.g. "1 day", "2 hours", "3 minutes", "4 seconds".
 */
const formatDuration = (ms) => {
    const formatUnit = (value, unit) => `${value} ${unit}${value !== 1 ? "s" : ""}`;
    if (ms >= Number(TimeUnit.ONE_DAY)) {
        return formatUnit(Math.floor(ms / TimeUnit.ONE_DAY), "day");
    }
    if (ms >= Number(TimeUnit.ONE_HOUR)) {
        return formatUnit(Math.floor(ms / TimeUnit.ONE_HOUR), "hour");
    }
    if (ms >= Number(TimeUnit.ONE_MINUTE)) {
        return formatUnit(Math.floor(ms / TimeUnit.ONE_MINUTE), "minute");
    }
    return formatUnit(Math.floor(ms / TimeUnit.ONE_SECOND), "second");
};
exports.formatDuration = formatDuration;
/**
 * Return a human-readable string with the time difference between two timestamps.
 * E.g. "30s"/"30 sec", "1h"/"1 hour", "2d"/"2 days".
 */
function formatTimeDiff({ timestamp, now = Date.now(), format = "short", minTimeUnit = TimeUnit.ONE_SECOND, }) {
    if (!timestamp)
        return "";
    let diff = Math.abs(now - timestamp);
    if (diff < Number(minTimeUnit)) {
        return getEndLabel(minTimeUnit, format);
    }
    let timeUnit;
    if (diff >= Number(TimeUnit.ONE_DAY)) {
        timeUnit = [
            [TIME_LABEL.day[format], TimeUnit.ONE_DAY],
            [TIME_LABEL.hour[format], TimeUnit.ONE_HOUR],
        ];
    }
    else if (diff >= Number(TimeUnit.ONE_HOUR)) {
        timeUnit = [
            [TIME_LABEL.hour[format], TimeUnit.ONE_HOUR],
            [TIME_LABEL.min[format], TimeUnit.ONE_MINUTE],
        ];
    }
    else {
        timeUnit = [
            [TIME_LABEL.min[format], TimeUnit.ONE_MINUTE],
            [TIME_LABEL.sec[format], TimeUnit.ONE_SECOND],
        ];
    }
    const convertAmount = (amount, label) => {
        const spacing = format === "short" ? "" : " ";
        if (amount > 1)
            return `${amount}${spacing}${label}${format === "long" ? "s" : ""}`;
        if (amount === 1)
            return `${amount}${spacing}${label}`;
        return "";
    };
    const resultArr = timeUnit.map(([label, denom]) => {
        const whole = Math.floor(diff / denom);
        diff = diff - whole * denom;
        return convertAmount(whole, label);
    });
    const result = resultArr.join(" ").trim();
    return result || getEndLabel(minTimeUnit, format);
}
const TIME_LABEL = {
    year: { long: "year", short: "y" },
    month: { long: "month", short: "m" },
    day: { long: "day", short: "d" },
    hour: { long: "hour", short: "h" },
    min: { long: "min", short: "m" },
    sec: { long: "sec", short: "s" },
};
function getEndLabel(minTimeUnit, format) {
    let minLabel = "";
    switch (minTimeUnit) {
        case TimeUnit.ONE_DAY:
            minLabel = TIME_LABEL.day[format];
            break;
        case TimeUnit.ONE_HOUR:
            minLabel = TIME_LABEL.hour[format];
            break;
        case TimeUnit.ONE_MINUTE:
            minLabel = TIME_LABEL.min[format];
            break;
        default:
            minLabel = TIME_LABEL.sec[format];
    }
    if (format === "short") {
        return `< 1${minLabel}`;
    }
    else {
        return `< 1 ${minLabel}`;
    }
}
/**
 * Return the domain from a URL.
 * E.g. `"https://polymedia.app"` -> `"polymedia.app"`.
 */
const urlToDomain = (url) => {
    const match = /^https?:\/\/([^/]+)/.exec(url);
    return match ? match[1] : "";
};
exports.urlToDomain = urlToDomain;
/**
 * Return a shortened version of a transaction digest.
 * E.g. "yjxT3tJvRdkg5p5NFN64hGUGSntWoB8MtA34ErFYMgW" -> "yjxT…YMgW".
 */
const shortenDigest = (digest, start = 4, end = 4, separator = "…") => {
    return digest.slice(0, start) + separator + digest.slice(-end);
};
exports.shortenDigest = shortenDigest;
//# sourceMappingURL=format.js.map