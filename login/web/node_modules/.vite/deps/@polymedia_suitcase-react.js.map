{
  "version": 3,
  "sources": ["../../cookie/src/index.ts", "../../set-cookie-parser/lib/set-cookie.js", "../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../use-sync-external-store/shim/with-selector.js", "../../cssesc/cssesc.js", "../../picocolors/picocolors.browser.js", "../../deepmerge/dist/cjs.js", "../../@polymedia/suitcase-react/src/buttons.tsx", "../../react-router/dist/development/chunk-C37GKA54.mjs", "../../react-router/dist/development/chunk-KIUJAIYX.mjs", "../../react-router/dist/development/dom-export.mjs", "../../@polymedia/suitcase-react/src/links.tsx", "../../@polymedia/suitcase-react/src/cards.tsx", "../../@radix-ui/react-dialog/src/dialog.tsx", "../../@radix-ui/primitive/src/primitive.tsx", "../../@radix-ui/react-compose-refs/src/compose-refs.tsx", "../../@radix-ui/react-context/src/create-context.tsx", "../../@radix-ui/react-id/src/id.tsx", "../../@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx", "../../@radix-ui/react-use-controllable-state/src/use-controllable-state.tsx", "../../@radix-ui/react-use-controllable-state/src/use-controllable-state-reducer.tsx", "../../@radix-ui/react-use-effect-event/src/use-effect-event.tsx", "../../@radix-ui/react-dismissable-layer/src/dismissable-layer.tsx", "../../@radix-ui/react-primitive/src/primitive.tsx", "../../@radix-ui/react-slot/src/slot.tsx", "../../@radix-ui/react-use-callback-ref/src/use-callback-ref.tsx", "../../@radix-ui/react-use-escape-keydown/src/use-escape-keydown.tsx", "../../@radix-ui/react-focus-scope/src/focus-scope.tsx", "../../@radix-ui/react-portal/src/portal.tsx", "../../@radix-ui/react-presence/src/presence.tsx", "../../@radix-ui/react-presence/src/use-state-machine.tsx", "../../@radix-ui/react-focus-guards/src/focus-guards.tsx", "../../tslib/tslib.es6.mjs", "../../react-remove-scroll/dist/es2015/Combination.js", "../../react-remove-scroll/dist/es2015/UI.js", "../../react-remove-scroll-bar/dist/es2015/constants.js", "../../use-callback-ref/dist/es2015/assignRef.js", "../../use-callback-ref/dist/es2015/useRef.js", "../../use-callback-ref/dist/es2015/useMergeRef.js", "../../use-sidecar/dist/es2015/hoc.js", "../../use-sidecar/dist/es2015/hook.js", "../../use-sidecar/dist/es2015/medium.js", "../../use-sidecar/dist/es2015/renderProp.js", "../../use-sidecar/dist/es2015/exports.js", "../../react-remove-scroll/dist/es2015/medium.js", "../../react-remove-scroll/dist/es2015/SideEffect.js", "../../react-remove-scroll-bar/dist/es2015/component.js", "../../react-style-singleton/dist/es2015/hook.js", "../../get-nonce/dist/es2015/index.js", "../../react-style-singleton/dist/es2015/singleton.js", "../../react-style-singleton/dist/es2015/component.js", "../../react-remove-scroll-bar/dist/es2015/utils.js", "../../react-remove-scroll/dist/es2015/aggresiveCapture.js", "../../react-remove-scroll/dist/es2015/handleScroll.js", "../../react-remove-scroll/dist/es2015/sidecar.js", "../../aria-hidden/dist/es2015/index.js", "../../clsx/dist/clsx.mjs", "vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9", "../../@mysten/dapp-kit/src/components/styling/StyleMarker.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/ConnectModal.tsx", "../../@mysten/dapp-kit/src/constants/walletDefaults.ts", "../../@mysten/dapp-kit/src/utils/stateStorage.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useConnectWallet.ts", "../../@mysten/dapp-kit/src/constants/walletMutationKeys.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useWalletStore.ts", "../../@mysten/dapp-kit/src/contexts/walletContext.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useWallets.ts", "../../@mysten/dapp-kit/src/utils/walletUtils.ts", "../../@mysten/dapp-kit/src/components/icons/BackIcon.tsx", "../../@mysten/dapp-kit/src/components/icons/CloseIcon.tsx", "../../@mysten/dapp-kit/src/components/styling/StyleMarker.tsx", "../../@mysten/dapp-kit/src/constants/styleDataAttribute.ts", "../../@mysten/dapp-kit/src/components/ui/Heading.tsx", "../../@mysten/dapp-kit/src/components/ui/Heading.css.ts", "../../@mysten/dapp-kit/src/components/ui/IconButton.tsx", "../../@mysten/dapp-kit/src/components/ui/IconButton.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/ConnectModal.css.ts", "../../@mysten/dapp-kit/src/components/ui/Button.tsx", "../../@mysten/dapp-kit/src/components/ui/Button.css.ts", "../../@mysten/dapp-kit/src/components/ui/Text.tsx", "../../@mysten/dapp-kit/src/components/ui/Text.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/views/ConnectionStatus.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/views/ConnectionStatus.tsx", "../../@mysten/dapp-kit/src/components/connect-modal/InfoSection.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/InfoSection.tsx", "../../@mysten/dapp-kit/src/components/connect-modal/views/GettingStarted.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/views/GettingStarted.tsx", "../../@mysten/dapp-kit/src/components/connect-modal/views/WhatIsAWallet.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/views/WhatIsAWallet.tsx", "../../@mysten/dapp-kit/src/components/icons/SuiIcon.tsx", "../../@mysten/dapp-kit/src/components/connect-modal/wallet-list/WalletList.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/wallet-list/WalletListItem.tsx", "../../@mysten/dapp-kit/src/components/connect-modal/wallet-list/WalletListItem.css.ts", "../../@mysten/dapp-kit/src/components/connect-modal/wallet-list/WalletList.tsx", "../../@mysten/dapp-kit/src/hooks/wallet/useCurrentAccount.ts", "../../@mysten/dapp-kit/src/components/AccountDropdownMenu.tsx", "../../@mysten/dapp-kit/src/hooks/useSuiClientQuery.ts", "../../@mysten/dapp-kit/src/hooks/useSuiClient.ts", "../../@mysten/dapp-kit/src/components/SuiClientProvider.tsx", "../../@mysten/dapp-kit/src/hooks/useResolveSuiNSNames.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useAccounts.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useDisconnectWallet.ts", "../../@mysten/dapp-kit/src/errors/walletErrors.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useCurrentWallet.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useSwitchAccount.ts", "../../@mysten/dapp-kit/src/components/AccountDropdownMenu.css.ts", "../../@mysten/dapp-kit/src/components/icons/CheckIcon.tsx", "../../@mysten/dapp-kit/src/components/icons/ChevronIcon.tsx", "../../@mysten/dapp-kit/src/components/ConnectButton.tsx", "../../@mysten/dapp-kit/src/components/WalletProvider.tsx", "../../@mysten/dapp-kit/src/hooks/wallet/useAutoConnectWallet.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useSlushWallet.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useUnsafeBurnerWallet.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useWalletPropertiesChanged.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useWalletsChanged.ts", "../../@mysten/dapp-kit/src/themes/lightTheme.ts", "../../@mysten/dapp-kit/src/walletStore.ts", "../../@mysten/dapp-kit/src/components/styling/InjectedThemeStyles.tsx", "../../@mysten/dapp-kit/src/themes/themeContract.ts", "../../@mysten/dapp-kit/src/hooks/networkConfig.ts", "../../@mysten/dapp-kit/src/hooks/useSuiClientInfiniteQuery.ts", "../../@mysten/dapp-kit/src/hooks/useSuiClientMutation.ts", "../../@mysten/dapp-kit/src/hooks/useSuiClientQueries.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useSignAndExecuteTransaction.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useReportTransactionEffects.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useSignPersonalMessage.ts", "../../@mysten/dapp-kit/src/hooks/wallet/useSignTransaction.ts", "../../@mysten/slush-wallet/node_modules/@mysten/bcs/src/uleb.ts", "../../@mysten/slush-wallet/node_modules/@mysten/bcs/src/reader.ts", "../../@mysten/slush-wallet/node_modules/@mysten/bcs/src/utils.ts", "../../@mysten/slush-wallet/node_modules/@mysten/bcs/src/writer.ts", "../../@mysten/slush-wallet/node_modules/@mysten/bcs/src/bcs-type.ts", "../../@mysten/slush-wallet/node_modules/@mysten/bcs/src/bcs.ts", "../../@mysten/slush-wallet/node_modules/@mysten/sui/src/utils/sui-types.ts", "../../@mysten/slush-wallet/node_modules/@mysten/sui/src/utils/constants.ts", "../../@mysten/slush-wallet/node_modules/@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/slush-wallet/node_modules/@mysten/sui/src/bcs/bcs.ts", "../../@mysten/slush-wallet/node_modules/@mysten/sui/src/bcs/effects.ts", "../../@mysten/slush-wallet/node_modules/@mysten/sui/src/bcs/index.ts", "../../@wallet-standard/errors/src/codes.ts", "../../@wallet-standard/errors/src/messages.ts", "../../@wallet-standard/errors/src/message-formatter.ts", "../../@wallet-standard/wallet/src/util.ts", "../../@mysten/wallet-standard/node_modules/@mysten/bcs/src/uleb.ts", "../../@mysten/wallet-standard/node_modules/@mysten/bcs/src/reader.ts", "../../@mysten/wallet-standard/node_modules/@mysten/bcs/src/utils.ts", "../../@mysten/wallet-standard/node_modules/@mysten/bcs/src/writer.ts", "../../@mysten/wallet-standard/node_modules/@mysten/bcs/src/bcs-type.ts", "../../@mysten/wallet-standard/node_modules/@mysten/bcs/src/bcs.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/utils/suins.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/utils/move-registry.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/utils/sui-types.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/bcs/bcs.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/bcs/effects.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/bcs/pure.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/bcs/index.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/utils/constants.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/serializer.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/Inputs.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/data/internal.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/Commands.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/data/v1.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/data/v2.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/experimental/transports/json-rpc-resolver.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/resolve.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/object.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/pure.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/hash.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/TransactionData.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/utils.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/experimental/cache.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/version.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/experimental/mvr.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/plugins/NamedPackagesPlugin.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/Transaction.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/ObjectCache.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/executor/caching.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/executor/queue.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/executor/serial.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/executor/parallel.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/intents/CoinWithBalance.ts", "../../@mysten/wallet-standard/node_modules/@mysten/sui/src/transactions/Arguments.ts", "../../@mysten/wallet-standard/src/chains.ts", "../../@mysten/window-wallet-core/src/web-wallet-channel/requests.ts", "../../jose/dist/webapi/util/base64url.js", "../../jose/dist/webapi/lib/buffer_utils.js", "../../jose/dist/webapi/lib/base64.js", "../../jose/dist/webapi/util/errors.js", "../../jose/dist/webapi/lib/is_object.js", "../../jose/dist/webapi/lib/private_symbols.js", "../../jose/dist/webapi/lib/secs.js", "../../jose/dist/webapi/jwks/remote.js", "../../jose/dist/webapi/util/decode_jwt.js", "../../@mysten/window-wallet-core/src/jwt-session/index.ts", "../../@mysten/window-wallet-core/src/web-wallet-channel/wallet-post-message-channel.ts", "../../@mysten/window-wallet-core/src/web-wallet-channel/responses.ts", "../../@mysten/window-wallet-core/src/web-wallet-channel/utils.ts", "../../@mysten/window-wallet-core/src/web-wallet-channel/dapp-post-message-channel.ts", "../../@mysten/slush-wallet/src/wallet/index.ts", "../../@tanstack/query-core/src/subscribable.ts", "../../@tanstack/query-core/src/utils.ts", "../../@tanstack/query-core/src/focusManager.ts", "../../@tanstack/query-core/src/onlineManager.ts", "../../@tanstack/query-core/src/notifyManager.ts", "../../@tanstack/query-core/src/types.ts", "../../@tanstack/react-query/src/useQueries.ts", "../../@tanstack/react-query/src/QueryClientProvider.tsx", "../../@tanstack/react-query/src/IsRestoringProvider.ts", "../../@tanstack/react-query/src/QueryErrorResetBoundary.tsx", "../../@tanstack/react-query/src/errorBoundaryUtils.ts", "../../@tanstack/react-query/src/useBaseQuery.ts", "../../@tanstack/react-query/src/HydrationBoundary.tsx", "../../@tanstack/react-query/src/useIsFetching.ts", "../../@tanstack/react-query/src/useMutationState.ts", "../../@tanstack/react-query/src/useMutation.ts", "../../zustand/esm/index.mjs", "../../@vanilla-extract/recipes/dist/createRuntimeFn-62c9670f.esm.js", "../../@mysten/dapp-kit/node_modules/@mysten/bcs/src/uleb.ts", "../../@mysten/dapp-kit/node_modules/@mysten/bcs/src/reader.ts", "../../@mysten/dapp-kit/node_modules/@mysten/bcs/src/utils.ts", "../../@mysten/dapp-kit/node_modules/@mysten/bcs/src/writer.ts", "../../@mysten/dapp-kit/node_modules/@mysten/bcs/src/bcs-type.ts", "../../@mysten/dapp-kit/node_modules/@mysten/bcs/src/bcs.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/utils/suins.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/utils/move-registry.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/utils/sui-types.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/utils/constants.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/bcs/type-tag-serializer.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/bcs/bcs.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/bcs/effects.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/bcs/pure.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/bcs/index.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/utils/dynamic-fields.ts", "../../@radix-ui/react-dropdown-menu/src/dropdown-menu.tsx", "../../@radix-ui/react-menu/src/menu.tsx", "../../@radix-ui/react-collection/src/collection-legacy.tsx", "../../@radix-ui/react-collection/src/collection.tsx", "../../@radix-ui/react-collection/src/ordered-dictionary.ts", "../../@radix-ui/react-direction/src/direction.tsx", "../../@radix-ui/react-popper/src/popper.tsx", "../../@floating-ui/utils/dist/floating-ui.utils.mjs", "../../@floating-ui/core/dist/floating-ui.core.mjs", "../../@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../../@floating-ui/dom/dist/floating-ui.dom.mjs", "../../@floating-ui/react-dom/dist/floating-ui.react-dom.mjs", "../../@radix-ui/react-arrow/src/arrow.tsx", "../../@radix-ui/react-use-size/src/use-size.tsx", "../../@radix-ui/react-roving-focus/src/roving-focus-group.tsx", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/version.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/client/errors.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/client/rpc-websocket-client.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/client/http-transport.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/client/network.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/cache.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/client.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/data/internal.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/Commands.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/data/v1.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/data/v2.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/Inputs.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/serializer.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/transports/json-rpc-resolver.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/resolve.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/object.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/pure.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/hash.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/TransactionData.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/utils.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/mvr.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/plugins/NamedPackagesPlugin.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/Transaction.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/core.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/errors.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/transports/utils.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/transports/jsonRPC.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/client/client.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/cryptography/intent.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/cryptography/signature-scheme.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/cryptography/publickey.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/keypairs/passkey/publickey.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/graphql/generated/queries.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/experimental/transports/graphql.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/graphql/client.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/zklogin/jwt-decode.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/zklogin/poseidon.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/zklogin/utils.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/zklogin/bcs.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/zklogin/publickey.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/keypairs/ed25519/ed25519-hd-key.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/keypairs/ed25519/publickey.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/ObjectCache.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/executor/caching.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/executor/queue.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/executor/serial.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/executor/parallel.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/intents/CoinWithBalance.ts", "../../@mysten/dapp-kit/node_modules/@mysten/sui/src/transactions/Arguments.ts", "../../@vanilla-extract/private/dist/vanilla-extract-private.esm.js", "../../@vanilla-extract/css/injectStyles/dist/vanilla-extract-css-injectStyles.browser.esm.js", "../../@vanilla-extract/css/dist/transformCss-830a230d.browser.esm.js", "../../modern-ahocorasick/dist/index.js", "../../@vanilla-extract/css/adapter/dist/vanilla-extract-css-adapter.browser.esm.js", "../../@vanilla-extract/css/dist/taggedTemplateLiteral-8e47dbd7.browser.esm.js", "../../css-what/lib/es/types.js", "../../css-what/lib/es/parse.js", "../../css-what/lib/es/stringify.js", "../../dedent/dist/dedent.mjs", "../../media-query-parser/node_modules/tslib/tslib.es6.js", "../../media-query-parser/compiled/parse/lexicalAnalysis.js", "../../media-query-parser/compiled/parse/simplifyAST.js", "../../media-query-parser/compiled/parse/syntacticAnalysis.js", "../../lru-cache/src/index.ts", "../../@vanilla-extract/css/dist/vanilla-extract-css.browser.esm.js", "../../@polymedia/suitcase-react/src/connect.tsx", "../../@polymedia/suitcase-react/src/selectors.tsx", "../../@polymedia/suitcase-react/src/explorers.tsx", "../../@polymedia/suitcase-react/src/glitch.tsx", "../../@polymedia/suitcase-react/src/hero.tsx", "../../@polymedia/suitcase-react/src/hooks.ts", "../../@polymedia/suitcase-react/src/icons.tsx", "../../@polymedia/suitcase-react/src/inputs.tsx", "../../@polymedia/suitcase-react/src/loader.tsx", "../../@polymedia/suitcase-react/src/misc.ts", "../../@polymedia/suitcase-react/src/modals.tsx", "../../@polymedia/suitcase-react/src/networks.tsx", "../../@polymedia/suitcase-react/src/rpcs.tsx", "../../@polymedia/suitcase-react/src/index.ts"],
  "sourcesContent": ["/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp =\n  /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n\nconst __toString = Object.prototype.toString;\n\nconst NullObject = /* @__PURE__ */ (() => {\n  const C = function () {};\n  C.prototype = Object.create(null);\n  return C;\n})() as unknown as { new (): any };\n\n/**\n * Parse options.\n */\nexport interface ParseOptions {\n  /**\n   * Specifies a function that will be used to decode a [cookie-value](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1).\n   * Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode\n   * a previously-encoded cookie value into a JavaScript string.\n   *\n   * The default function is the global `decodeURIComponent`, wrapped in a `try..catch`. If an error\n   * is thrown it will return the cookie's original value. If you provide your own encode/decode\n   * scheme you must ensure errors are appropriately handled.\n   *\n   * @default decode\n   */\n  decode?: (str: string) => string | undefined;\n}\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function parse(\n  str: string,\n  options?: ParseOptions,\n): Record<string, string | undefined> {\n  const obj: Record<string, string | undefined> = new NullObject();\n  const len = str.length;\n  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n  if (len < 2) return obj;\n\n  const dec = options?.decode || decode;\n  let index = 0;\n\n  do {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) break; // No more cookie pairs.\n\n    const colonIdx = str.indexOf(\";\", index);\n    const endIdx = colonIdx === -1 ? len : colonIdx;\n\n    if (eqIdx > endIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n\n    const keyStartIdx = startIndex(str, index, eqIdx);\n    const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n    const key = str.slice(keyStartIdx, keyEndIdx);\n\n    // only assign once\n    if (obj[key] === undefined) {\n      let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n      let valEndIdx = endIndex(str, endIdx, valStartIdx);\n\n      const value = dec(str.slice(valStartIdx, valEndIdx));\n      obj[key] = value;\n    }\n\n    index = endIdx + 1;\n  } while (index < len);\n\n  return obj;\n}\n\nfunction startIndex(str: string, index: number, max: number) {\n  do {\n    const code = str.charCodeAt(index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\n  } while (++index < max);\n  return max;\n}\n\nfunction endIndex(str: string, index: number, min: number) {\n  while (index > min) {\n    const code = str.charCodeAt(--index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\n  }\n  return min;\n}\n\n/**\n * Serialize options.\n */\nexport interface SerializeOptions {\n  /**\n   * Specifies a function that will be used to encode a [cookie-value](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1).\n   * Since value of a cookie has a limited character set (and must be a simple string), this function can be used to encode\n   * a value into a string suited for a cookie's value, and should mirror `decode` when parsing.\n   *\n   * @default encodeURIComponent\n   */\n  encode?: (str: string) => string;\n  /**\n   * Specifies the `number` (in seconds) to be the value for the [`Max-Age` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.2).\n   *\n   * The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3) states that if both `expires` and\n   * `maxAge` are set, then `maxAge` takes precedence, but it is possible not all clients by obey this,\n   * so if both are set, they should point to the same date and time.\n   */\n  maxAge?: number;\n  /**\n   * Specifies the `Date` object to be the value for the [`Expires` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.1).\n   * When no expiration is set clients consider this a \"non-persistent cookie\" and delete it the current session is over.\n   *\n   * The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3) states that if both `expires` and\n   * `maxAge` are set, then `maxAge` takes precedence, but it is possible not all clients by obey this,\n   * so if both are set, they should point to the same date and time.\n   */\n  expires?: Date;\n  /**\n   * Specifies the value for the [`Domain` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.3).\n   * When no domain is set clients consider the cookie to apply to the current domain only.\n   */\n  domain?: string;\n  /**\n   * Specifies the value for the [`Path` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.4).\n   * When no path is set, the path is considered the [\"default path\"](https://tools.ietf.org/html/rfc6265#section-5.1.4).\n   */\n  path?: string;\n  /**\n   * Enables the [`HttpOnly` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.6).\n   * When enabled, clients will not allow client-side JavaScript to see the cookie in `document.cookie`.\n   */\n  httpOnly?: boolean;\n  /**\n   * Enables the [`Secure` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.5).\n   * When enabled, clients will only send the cookie back if the browser has a HTTPS connection.\n   */\n  secure?: boolean;\n  /**\n   * Enables the [`Partitioned` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-cutler-httpbis-partitioned-cookies/).\n   * When enabled, clients will only send the cookie back when the current domain _and_ top-level domain matches.\n   *\n   * This is an attribute that has not yet been fully standardized, and may change in the future.\n   * This also means clients may ignore this attribute until they understand it. More information\n   * about can be found in [the proposal](https://github.com/privacycg/CHIPS).\n   */\n  partitioned?: boolean;\n  /**\n   * Specifies the value for the [`Priority` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).\n   *\n   * - `'low'` will set the `Priority` attribute to `Low`.\n   * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n   * - `'high'` will set the `Priority` attribute to `High`.\n   *\n   * More information about priority levels can be found in [the specification](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).\n   */\n  priority?: \"low\" | \"medium\" | \"high\";\n  /**\n   * Specifies the value for the [`SameSite` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).\n   *\n   * - `true` will set the `SameSite` attribute to `Strict` for strict same site enforcement.\n   * - `'lax'` will set the `SameSite` attribute to `Lax` for lax same site enforcement.\n   * - `'none'` will set the `SameSite` attribute to `None` for an explicit cross-site cookie.\n   * - `'strict'` will set the `SameSite` attribute to `Strict` for strict same site enforcement.\n   *\n   * More information about enforcement levels can be found in [the specification](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).\n   */\n  sameSite?: boolean | \"lax\" | \"strict\" | \"none\";\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n */\nexport function serialize(\n  name: string,\n  val: string,\n  options?: SerializeOptions,\n): string {\n  const enc = options?.encode || encodeURIComponent;\n\n  if (!cookieNameRegExp.test(name)) {\n    throw new TypeError(`argument name is invalid: ${name}`);\n  }\n\n  const value = enc(val);\n\n  if (!cookieValueRegExp.test(value)) {\n    throw new TypeError(`argument val is invalid: ${val}`);\n  }\n\n  let str = name + \"=\" + value;\n  if (!options) return str;\n\n  if (options.maxAge !== undefined) {\n    if (!Number.isInteger(options.maxAge)) {\n      throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n    }\n\n    str += \"; Max-Age=\" + options.maxAge;\n  }\n\n  if (options.domain) {\n    if (!domainValueRegExp.test(options.domain)) {\n      throw new TypeError(`option domain is invalid: ${options.domain}`);\n    }\n\n    str += \"; Domain=\" + options.domain;\n  }\n\n  if (options.path) {\n    if (!pathValueRegExp.test(options.path)) {\n      throw new TypeError(`option path is invalid: ${options.path}`);\n    }\n\n    str += \"; Path=\" + options.path;\n  }\n\n  if (options.expires) {\n    if (\n      !isDate(options.expires) ||\n      !Number.isFinite(options.expires.valueOf())\n    ) {\n      throw new TypeError(`option expires is invalid: ${options.expires}`);\n    }\n\n    str += \"; Expires=\" + options.expires.toUTCString();\n  }\n\n  if (options.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n\n  if (options.secure) {\n    str += \"; Secure\";\n  }\n\n  if (options.partitioned) {\n    str += \"; Partitioned\";\n  }\n\n  if (options.priority) {\n    const priority =\n      typeof options.priority === \"string\"\n        ? options.priority.toLowerCase()\n        : undefined;\n    switch (priority) {\n      case \"low\":\n        str += \"; Priority=Low\";\n        break;\n      case \"medium\":\n        str += \"; Priority=Medium\";\n        break;\n      case \"high\":\n        str += \"; Priority=High\";\n        break;\n      default:\n        throw new TypeError(`option priority is invalid: ${options.priority}`);\n    }\n  }\n\n  if (options.sameSite) {\n    const sameSite =\n      typeof options.sameSite === \"string\"\n        ? options.sameSite.toLowerCase()\n        : options.sameSite;\n    switch (sameSite) {\n      case true:\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str: string): string {\n  if (str.indexOf(\"%\") === -1) return str;\n\n  try {\n    return decodeURIComponent(str);\n  } catch (e) {\n    return str;\n  }\n}\n\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val: any): val is Date {\n  return __toString.call(val) === \"[object Date]\";\n}\n", "\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else if (key === \"partitioned\") {\n      cookie.partitioned = true;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n", "/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n", "/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If its not a printable ASCII character\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// Its a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// Its an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since theyre redundant. Note that this is only possible if the escape\n\t// sequence isnt preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// Its not safe to remove the space, so dont.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n", "var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n", "'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", null, "/**\n * react-router v7.7.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n\n// lib/router/history.ts\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n  return Action2;\n})(Action || {});\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options = {}) {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries;\n  entries = initialEntries.map(\n    (entry, index2) => createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index2 === 0 ? \"default\" : void 0\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = \"POP\" /* Pop */;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state = null, key) {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n  function createHref2(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref: createHref2,\n    createURL(to) {\n      return new URL(createHref2(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = \"PUSH\" /* Push */;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = \"REPLACE\" /* Replace */;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = \"POP\" /* Pop */;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\nfunction createBrowserHistory(options = {}) {\n  function createBrowserLocation(window2, globalHistory) {\n    let { pathname, search, hash } = window2.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createBrowserHref(window2, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\nfunction createHashHistory(options = {}) {\n  function createHashLocation(window2, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window2.location.hash.substring(1));\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createHashHref(window2, to) {\n    let base = window2.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window2.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substring(2, 10);\n}\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\nfunction createLocation(current, to, state = null, key) {\n  let location = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...typeof to === \"string\" ? parsePath(to) : to,\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  };\n  return location;\n}\nfunction createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\"\n}) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substring(hashIndex);\n      path = path.substring(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substring(searchIndex);\n      path = path.substring(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {\n  let { window: window2 = document.defaultView, v5Compat = false } = options;\n  let globalHistory = window2.history;\n  let action = \"POP\" /* Pop */;\n  let listener = null;\n  let index = getIndex();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n  function handlePop() {\n    action = \"POP\" /* Pop */;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n  function push(to, state) {\n    action = \"PUSH\" /* Push */;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      window2.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n  function replace2(to, state) {\n    action = \"REPLACE\" /* Replace */;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n  function createURL(to) {\n    return createBrowserURLImpl(to);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window2, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window2.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window2.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref2(window2, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace: replace2,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\nfunction createBrowserURLImpl(to, isAbsolute = false) {\n  let base = \"http://localhost\";\n  if (typeof window !== \"undefined\") {\n    base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n  }\n  invariant(base, \"No window.location.(origin|href) available to create URL\");\n  let href = typeof to === \"string\" ? to : createPath(to);\n  href = href.replace(/ $/, \"%20\");\n  if (!isAbsolute && href.startsWith(\"//\")) {\n    href = base + href;\n  }\n  return new URL(href, base);\n}\n\n// lib/router/utils.ts\nfunction unstable_createContext(defaultValue) {\n  return { defaultValue };\n}\nvar _map;\nvar unstable_RouterContextProvider = class {\n  constructor(init) {\n    __privateAdd(this, _map, /* @__PURE__ */ new Map());\n    if (init) {\n      for (let [context, value] of init) {\n        this.set(context, value);\n      }\n    }\n  }\n  get(context) {\n    if (__privateGet(this, _map).has(context)) {\n      return __privateGet(this, _map).get(context);\n    }\n    if (context.defaultValue !== void 0) {\n      return context.defaultValue;\n    }\n    throw new Error(\"No value found for context\");\n  }\n  set(context, value) {\n    __privateGet(this, _map).set(context, value);\n  }\n};\n_map = new WeakMap();\nvar unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\"\n]);\nfunction isUnsupportedLazyRouteObjectKey(key) {\n  return unsupportedLazyRouteObjectKeys.has(\n    key\n  );\n}\nvar unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"unstable_middleware\",\n  \"children\"\n]);\nfunction isUnsupportedLazyRouteFunctionKey(key) {\n  return unsupportedLazyRouteFunctionKeys.has(\n    key\n  );\n}\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}, allowInPlaceMutations = false) {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, String(index)];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      allowInPlaceMutations || !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route id's must be globally unique within Data Router usages`\n    );\n    if (isIndexRoute(route)) {\n      let indexRoute = {\n        ...route,\n        ...mapRouteProperties2(route),\n        id\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = {\n        ...route,\n        ...mapRouteProperties2(route),\n        id,\n        children: void 0\n      };\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties2,\n          treePath,\n          manifest,\n          allowInPlaceMutations\n        );\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\nfunction matchRoutes(routes, locationArg, basename = \"/\") {\n  return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch(\n      branches[i],\n      decoded,\n      allowPartial\n    );\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = \"\") {\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path \"${parentPath}\" is not valid. An absolute child route path must start with the combined path of all its parent routes.`\n      );\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove all child routes from route path \"${path}\".`\n      );\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  let isOptional = first.endsWith(\"?\");\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  result.push(\n    ...restExploded.map(\n      (subpath) => subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  return result.map(\n    (exploded) => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\nfunction rankRouteBranches(branches) {\n  branches.sort(\n    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(\n      a.routesMeta.map((meta) => meta.childrenIndex),\n      b.routesMeta.map((meta) => meta.childrenIndex)\n    )\n  );\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s) => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter((s) => !isSplat(s)).reduce(\n    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue),\n    initialScore\n  );\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? (\n    // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1]\n  ) : (\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0\n  );\n}\nfunction matchRouteBranch(branch, pathname, allowPartial = false) {\n  let { routesMeta } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n    let route = meta.route;\n    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n      match = matchPath(\n        {\n          path: meta.relativePath,\n          caseSensitive: meta.caseSensitive,\n          end: false\n        },\n        remainingPathname\n      );\n    }\n    if (!match) {\n      return null;\n    }\n    Object.assign(matchedParams, match.params);\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\nfunction generatePath(originalPath, params = {}) {\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify2 = (p) => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      return stringify2(params[star]);\n    }\n    const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n      return stringify2(param);\n    }\n    return segment.replace(/\\?$/g, \"\");\n  }).filter((segment) => !!segment);\n  return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n  let [matcher, compiledParams] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce(\n    (memo2, { paramName, isOptional }, index) => {\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n      }\n      const value = captureGroups[index];\n      if (isOptional && !value) {\n        memo2[paramName] = void 0;\n      } else {\n        memo2[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n      }\n      return memo2;\n    },\n    {}\n  );\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive = false, end = true) {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(\n    /\\/:([\\w-]+)(\\?)?/g,\n    (_, paramName, isOptional) => {\n      params.push({ paramName, isOptional: isOptional != null });\n      return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    }\n  );\n  if (path.endsWith(\"*\")) {\n    params.push({ paramName: \"*\" });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n  } else if (end) {\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n  }\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n  return [matcher, params];\n}\nfunction decodePath(value) {\n  try {\n    return value.split(\"/\").map((v) => decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`\n    );\n    return value;\n  }\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\nfunction prependBasename({\n  basename,\n  pathname\n}) {\n  return pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n}\nfunction resolvePath(to, fromPathname = \"/\") {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return `Cannot include a '${char}' character in a manually specified \\`to.${field}\\` field [${JSON.stringify(\n    path\n  )}].  Please separate it out to the \\`to.${dest}\\` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.`;\n}\nfunction getPathContributingMatches(matches) {\n  return matches.filter(\n    (match, index) => index === 0 || match.route.path && match.route.path.length > 0\n  );\n}\nfunction getResolveToMatches(matches) {\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches.map(\n    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase\n  );\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\nvar joinPaths = (paths) => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname) => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search) => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash) => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar DataWithResponseInit = class {\n  constructor(data2, init) {\n    this.type = \"DataWithResponseInit\";\n    this.data = data2;\n    this.init = init || null;\n  }\n};\nfunction data(data2, init) {\n  return new DataWithResponseInit(\n    data2,\n    typeof init === \"number\" ? { status: init } : init\n  );\n}\nvar redirect = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, { ...responseInit, headers });\n};\nvar redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\nvar replace = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Replace\", \"true\");\n  return response;\n};\nvar ErrorResponseImpl = class {\n  constructor(status, statusText, data2, internal = false) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data2 instanceof Error) {\n      this.data = data2.toString();\n      this.error = data2;\n    } else {\n      this.data = data2;\n    }\n  }\n};\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\n// lib/router/router.ts\nvar validMutationMethodsArr = [\n  \"POST\",\n  \"PUT\",\n  \"PATCH\",\n  \"DELETE\"\n];\nvar validMutationMethods = new Set(\n  validMutationMethodsArr\n);\nvar validRequestMethodsArr = [\n  \"GET\",\n  ...validMutationMethodsArr\n];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_FETCHER = {\n  state: \"idle\",\n  data: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: void 0,\n  reset: void 0,\n  location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);\nvar defaultMapRouteProperties = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nvar ResetLoaderDataSymbol = Symbol(\"ResetLoaderData\");\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : void 0;\n  const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n  let hydrationRouteProperties2 = init.hydrationRouteProperties || [];\n  let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties2,\n    void 0,\n    manifest\n  );\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;\n  let future = {\n    unstable_middleware: false,\n    ...init.future\n  };\n  let unlistenHistory = null;\n  let subscribers = /* @__PURE__ */ new Set();\n  let savedScrollPositions2 = null;\n  let getScrollRestorationKey2 = null;\n  let getScrollPosition = null;\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialMatchesIsFOW = false;\n  let initialErrors = null;\n  let initialized;\n  if (initialMatches == null && !init.patchRoutesOnNavigation) {\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialized = true;\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  } else {\n    if (initialMatches && !init.hydrationData) {\n      let fogOfWar = checkFogOfWar(\n        initialMatches,\n        dataRoutes,\n        init.history.location.pathname\n      );\n      if (fogOfWar.active) {\n        initialMatches = null;\n      }\n    }\n    if (!initialMatches) {\n      initialized = false;\n      initialMatches = [];\n      let fogOfWar = checkFogOfWar(\n        null,\n        dataRoutes,\n        init.history.location.pathname\n      );\n      if (fogOfWar.active && fogOfWar.matches) {\n        initialMatchesIsFOW = true;\n        initialMatches = fogOfWar.matches;\n      }\n    } else if (initialMatches.some((m) => m.route.lazy)) {\n      initialized = false;\n    } else if (!initialMatches.some((m) => m.route.loader)) {\n      initialized = true;\n    } else {\n      let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n      let errors = init.hydrationData ? init.hydrationData.errors : null;\n      if (errors) {\n        let idx = initialMatches.findIndex(\n          (m) => errors[m.route.id] !== void 0\n        );\n        initialized = initialMatches.slice(0, idx + 1).every(\n          (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)\n        );\n      } else {\n        initialized = initialMatches.every(\n          (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)\n        );\n      }\n    }\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: /* @__PURE__ */ new Map(),\n    blockers: /* @__PURE__ */ new Map()\n  };\n  let pendingAction = \"POP\" /* Pop */;\n  let pendingPreventScrollReset = false;\n  let pendingNavigationController;\n  let pendingViewTransitionEnabled = false;\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\n  let removePageHideEventListener = null;\n  let isUninterruptedRevalidation = false;\n  let isRevalidationRequired = false;\n  let cancelledFetcherLoads = /* @__PURE__ */ new Set();\n  let fetchControllers = /* @__PURE__ */ new Map();\n  let incrementingLoadId = 0;\n  let pendingNavigationLoadId = -1;\n  let fetchReloadIds = /* @__PURE__ */ new Map();\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\n  let activeFetchers = /* @__PURE__ */ new Map();\n  let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();\n  let blockerFunctions = /* @__PURE__ */ new Map();\n  let unblockBlockerHistoryUpdate = void 0;\n  let pendingRevalidationDfd = null;\n  function initialize() {\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        if (unblockBlockerHistoryUpdate) {\n          unblockBlockerHistoryUpdate();\n          unblockBlockerHistoryUpdate = void 0;\n          return;\n        }\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\"\n        );\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction\n        });\n        if (blockerKey && delta != null) {\n          let nextHistoryUpdatePromise = new Promise((resolve) => {\n            unblockBlockerHistoryUpdate = resolve;\n          });\n          init.history.go(delta * -1);\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey, {\n                state: \"proceeding\",\n                proceed: void 0,\n                reset: void 0,\n                location\n              });\n              nextHistoryUpdatePromise.then(() => init.history.go(delta));\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey, IDLE_BLOCKER);\n              updateState({ blockers });\n            }\n          });\n          return;\n        }\n        return startNavigation(historyAction, location);\n      }\n    );\n    if (isBrowser2) {\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    if (!state.initialized) {\n      startNavigation(\"POP\" /* Pop */, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  function updateState(newState, opts = {}) {\n    if (newState.matches) {\n      newState.matches = newState.matches.map((m) => {\n        let route = manifest[m.route.id];\n        let matchRoute = m.route;\n        if (matchRoute.element !== route.element || matchRoute.errorElement !== route.errorElement || matchRoute.hydrateFallbackElement !== route.hydrateFallbackElement) {\n          return {\n            ...m,\n            route\n          };\n        }\n        return m;\n      });\n    }\n    state = {\n      ...state,\n      ...newState\n    };\n    let unmountedFetchers = [];\n    let mountedFetchers = [];\n    state.fetchers.forEach((fetcher, key) => {\n      if (fetcher.state === \"idle\") {\n        if (fetchersQueuedForDeletion.has(key)) {\n          unmountedFetchers.push(key);\n        } else {\n          mountedFetchers.push(key);\n        }\n      }\n    });\n    fetchersQueuedForDeletion.forEach((key) => {\n      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {\n        unmountedFetchers.push(key);\n      }\n    });\n    [...subscribers].forEach(\n      (subscriber) => subscriber(state, {\n        deletedFetchers: unmountedFetchers,\n        viewTransitionOpts: opts.viewTransitionOpts,\n        flushSync: opts.flushSync === true\n      })\n    );\n    unmountedFetchers.forEach((key) => deleteFetcher(key));\n    mountedFetchers.forEach((key) => state.fetchers.delete(key));\n  }\n  function completeNavigation(location, newState, { flushSync } = {}) {\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && location.state?._isRedirect !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      actionData = state.actionData;\n    } else {\n      actionData = null;\n    }\n    let loaderData = newState.loaderData ? mergeLoaderData(\n      state.loaderData,\n      newState.loaderData,\n      newState.matches || [],\n      newState.errors\n    ) : state.loaderData;\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    let restoreScrollPosition = isUninterruptedRevalidation ? false : getSavedScrollPosition(location, newState.matches || state.matches);\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = void 0;\n    }\n    if (isUninterruptedRevalidation) {\n    } else if (pendingAction === \"POP\" /* Pop */) {\n    } else if (pendingAction === \"PUSH\" /* Push */) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === \"REPLACE\" /* Replace */) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    if (pendingAction === \"POP\" /* Pop */) {\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(\n      {\n        ...newState,\n        // matches, errors, fetchers go through as-is\n        actionData,\n        loaderData,\n        historyAction: pendingAction,\n        location,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        revalidation: \"idle\",\n        restoreScrollPosition,\n        preventScrollReset,\n        blockers\n      },\n      {\n        viewTransitionOpts,\n        flushSync: flushSync === true\n      }\n    );\n    pendingAction = \"POP\" /* Pop */;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    pendingRevalidationDfd?.resolve();\n    pendingRevalidationDfd = null;\n  }\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      to,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      false,\n      normalizedPath,\n      opts\n    );\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation)\n    };\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n    let historyAction = \"PUSH\" /* Push */;\n    if (userReplace === true) {\n      historyAction = \"REPLACE\" /* Replace */;\n    } else if (userReplace === false) {\n    } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      historyAction = \"REPLACE\" /* Replace */;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n    let flushSync = (opts && opts.flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: void 0,\n            reset: void 0,\n            location: nextLocation\n          });\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({ blockers });\n        }\n      });\n      return;\n    }\n    await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.viewTransition,\n      flushSync\n    });\n  }\n  function revalidate() {\n    if (!pendingRevalidationDfd) {\n      pendingRevalidationDfd = createDeferred();\n    }\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n    let promise = pendingRevalidationDfd.promise;\n    if (state.navigation.state === \"submitting\") {\n      return promise;\n    }\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return promise;\n    }\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      {\n        overrideNavigation: state.navigation,\n        // Proxy through any rending view transition\n        enableViewTransition: pendingViewTransitionEnabled === true\n      }\n    );\n    return promise;\n  }\n  async function startNavigation(historyAction, location, opts) {\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (\n      // `matchRoutes()` has already been called if we're in here via `router.initialize()`\n      state.matches\n    ) : matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, { matches }, { flushSync });\n      return;\n    }\n    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      let { error, notFoundMatches, route } = handleNavigational404(\n        location.pathname\n      );\n      completeNavigation(\n        location,\n        {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        },\n        { flushSync }\n      );\n      return;\n    }\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let scopedContext = new unstable_RouterContextProvider(\n      init.unstable_getContext ? await init.unstable_getContext() : void 0\n    );\n    let pendingActionResult;\n    if (opts && opts.pendingError) {\n      pendingActionResult = [\n        findNearestBoundary(matches).route.id,\n        { type: \"error\" /* error */, error: opts.pendingError }\n      ];\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      let actionResult = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        scopedContext,\n        fogOfWar.active,\n        opts && opts.initialHydration === true,\n        { replace: opts.replace, flushSync }\n      );\n      if (actionResult.shortCircuited) {\n        return;\n      }\n      if (actionResult.pendingActionResult) {\n        let [routeId, result] = actionResult.pendingActionResult;\n        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n          pendingNavigationController = null;\n          completeNavigation(location, {\n            matches: actionResult.matches,\n            loaderData: {},\n            errors: {\n              [routeId]: result.error\n            }\n          });\n          return;\n        }\n      }\n      matches = actionResult.matches || matches;\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      fogOfWar.active = false;\n      request = createClientSideRequest(\n        init.history,\n        request.url,\n        request.signal\n      );\n    }\n    let {\n      shortCircuited,\n      matches: updatedMatches,\n      loaderData,\n      errors\n    } = await handleLoaders(\n      request,\n      location,\n      matches,\n      scopedContext,\n      fogOfWar.active,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      opts && opts.initialHydration === true,\n      flushSync,\n      pendingActionResult\n    );\n    if (shortCircuited) {\n      return;\n    }\n    pendingNavigationController = null;\n    completeNavigation(location, {\n      matches: updatedMatches || matches,\n      ...getActionDataForCommit(pendingActionResult),\n      loaderData,\n      errors\n    });\n  }\n  async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {\n    interruptActiveLoads();\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation }, { flushSync: opts.flushSync === true });\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        matches,\n        location.pathname,\n        request.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return { shortCircuited: true };\n      } else if (discoverResult.type === \"error\") {\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          pendingActionResult: [\n            boundaryId,\n            {\n              type: \"error\" /* error */,\n              error: discoverResult.error\n            }\n          ]\n        };\n      } else if (!discoverResult.matches) {\n        let { notFoundMatches, error, route } = handleNavigational404(\n          location.pathname\n        );\n        return {\n          matches: notFoundMatches,\n          pendingActionResult: [\n            route.id,\n            {\n              type: \"error\" /* error */,\n              error\n            }\n          ]\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: \"error\" /* error */,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      let dsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        request,\n        matches,\n        actionMatch,\n        initialHydration ? [] : hydrationRouteProperties2,\n        scopedContext\n      );\n      let results = await callDataStrategy(\n        request,\n        dsMatches,\n        scopedContext,\n        null\n      );\n      result = results[actionMatch.route.id];\n      if (!result) {\n        for (let match of matches) {\n          if (results[match.route.id]) {\n            result = results[match.route.id];\n            break;\n          }\n        }\n      }\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace2;\n      if (opts && opts.replace != null) {\n        replace2 = opts.replace;\n      } else {\n        let location2 = normalizeRedirectLocation(\n          result.response.headers.get(\"Location\"),\n          new URL(request.url),\n          basename\n        );\n        replace2 = location2 === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, true, {\n        submission,\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      if ((opts && opts.replace) !== true) {\n        pendingAction = \"PUSH\" /* Push */;\n      }\n      return {\n        matches,\n        pendingActionResult: [\n          boundaryMatch.route.id,\n          result,\n          actionMatch.route.id\n        ]\n      };\n    }\n    return {\n      matches,\n      pendingActionResult: [actionMatch.route.id, result]\n    };\n  }\n  async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;\n    if (isFogOfWar) {\n      if (shouldUpdateNavigationState) {\n        let actionData = getUpdatedActionData(pendingActionResult);\n        updateState(\n          {\n            navigation: loadingNavigation,\n            ...actionData !== void 0 ? { actionData } : {}\n          },\n          {\n            flushSync\n          }\n        );\n      }\n      let discoverResult = await discoverRoutes(\n        matches,\n        location.pathname,\n        request.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return { shortCircuited: true };\n      } else if (discoverResult.type === \"error\") {\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          loaderData: {},\n          errors: {\n            [boundaryId]: discoverResult.error\n          }\n        };\n      } else if (!discoverResult.matches) {\n        let { error, notFoundMatches, route } = handleNavigational404(\n          location.pathname\n        );\n        return {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let { dsMatches, revalidatingFetchers } = getMatchesToLoad(\n      request,\n      scopedContext,\n      mapRouteProperties2,\n      manifest,\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      initialHydration ? [] : hydrationRouteProperties2,\n      initialHydration === true,\n      isRevalidationRequired,\n      cancelledFetcherLoads,\n      fetchersQueuedForDeletion,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      init.patchRoutesOnNavigation != null,\n      pendingActionResult\n    );\n    pendingNavigationLoadId = ++incrementingLoadId;\n    if (!init.dataStrategy && !dsMatches.some((m) => m.shouldLoad) && revalidatingFetchers.length === 0) {\n      let updatedFetchers2 = markFetchRedirectsDone();\n      completeNavigation(\n        location,\n        {\n          matches,\n          loaderData: {},\n          // Commit pending error if we're short circuiting\n          errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,\n          ...getActionDataForCommit(pendingActionResult),\n          ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}\n        },\n        { flushSync }\n      );\n      return { shortCircuited: true };\n    }\n    if (shouldUpdateNavigationState) {\n      let updates = {};\n      if (!isFogOfWar) {\n        updates.navigation = loadingNavigation;\n        let actionData = getUpdatedActionData(pendingActionResult);\n        if (actionData !== void 0) {\n          updates.actionData = actionData;\n        }\n      }\n      if (revalidatingFetchers.length > 0) {\n        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n      }\n      updateState(updates, { flushSync });\n    }\n    revalidatingFetchers.forEach((rf) => {\n      abortFetcher(rf.key);\n      if (rf.controller) {\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(\n      dsMatches,\n      revalidatingFetchers,\n      request,\n      scopedContext\n    );\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n    let redirect2 = findRedirect(loaderResults);\n    if (redirect2) {\n      await startRedirectNavigation(request, redirect2.result, true, {\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    redirect2 = findRedirect(fetcherResults);\n    if (redirect2) {\n      fetchRedirectIds.add(redirect2.key);\n      await startRedirectNavigation(request, redirect2.result, true, {\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      loaderResults,\n      pendingActionResult,\n      revalidatingFetchers,\n      fetcherResults\n    );\n    if (initialHydration && state.errors) {\n      errors = { ...state.errors, ...errors };\n    }\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return {\n      matches,\n      loaderData,\n      errors,\n      ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}\n    };\n  }\n  function getUpdatedActionData(pendingActionResult) {\n    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n      return {\n        [pendingActionResult[0]]: pendingActionResult[1].data\n      };\n    } else if (state.actionData) {\n      if (Object.keys(state.actionData).length === 0) {\n        return null;\n      } else {\n        return state.actionData;\n      }\n    }\n  }\n  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n    revalidatingFetchers.forEach((rf) => {\n      let fetcher = state.fetchers.get(rf.key);\n      let revalidatingFetcher = getLoadingFetcher(\n        void 0,\n        fetcher ? fetcher.data : void 0\n      );\n      state.fetchers.set(rf.key, revalidatingFetcher);\n    });\n    return new Map(state.fetchers);\n  }\n  async function fetch2(key, routeId, href, opts) {\n    abortFetcher(key);\n    let flushSync = (opts && opts.flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      href,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath }),\n        { flushSync }\n      );\n      return;\n    }\n    let { path, submission, error } = normalizeNavigateOptions(\n      true,\n      normalizedPath,\n      opts\n    );\n    if (error) {\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n    let scopedContext = new unstable_RouterContextProvider(\n      init.unstable_getContext ? await init.unstable_getContext() : void 0\n    );\n    let preventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      await handleFetcherAction(\n        key,\n        routeId,\n        path,\n        matches,\n        scopedContext,\n        fogOfWar.active,\n        flushSync,\n        preventScrollReset,\n        submission\n      );\n      return;\n    }\n    fetchLoadMatches.set(key, { routeId, path });\n    await handleFetcherLoader(\n      key,\n      routeId,\n      path,\n      matches,\n      scopedContext,\n      fogOfWar.active,\n      flushSync,\n      preventScrollReset,\n      submission\n    );\n  }\n  async function handleFetcherAction(key, routeId, path, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        requestMatches,\n        new URL(fetchRequest.url).pathname,\n        fetchRequest.signal,\n        key\n      );\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, { flushSync });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(\n          key,\n          routeId,\n          getInternalRouterError(404, { pathname: path }),\n          { flushSync }\n        );\n        return;\n      } else {\n        requestMatches = discoverResult.matches;\n      }\n    }\n    let match = getTargetMatch(requestMatches, path);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId\n      });\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let fetchMatches = getTargetedDataStrategyMatches(\n      mapRouteProperties2,\n      manifest,\n      fetchRequest,\n      requestMatches,\n      match,\n      hydrationRouteProperties2,\n      scopedContext\n    );\n    let actionResults = await callDataStrategy(\n      fetchRequest,\n      fetchMatches,\n      scopedContext,\n      key\n    );\n    let actionResult = actionResults[match.route.id];\n    if (fetchRequest.signal.aborted) {\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (fetchersQueuedForDeletion.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      }\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          updateFetcherState(key, getDoneFetcher(void 0));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, false, {\n            fetcherSubmission: submission,\n            preventScrollReset\n          });\n        }\n      }\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let { dsMatches, revalidatingFetchers } = getMatchesToLoad(\n      revalidationRequest,\n      scopedContext,\n      mapRouteProperties2,\n      manifest,\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      hydrationRouteProperties2,\n      false,\n      isRevalidationRequired,\n      cancelledFetcherLoads,\n      fetchersQueuedForDeletion,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      init.patchRoutesOnNavigation != null,\n      [match.route.id, actionResult]\n    );\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\n      let staleKey = rf.key;\n      let existingFetcher2 = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(\n        void 0,\n        existingFetcher2 ? existingFetcher2.data : void 0\n      );\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      abortFetcher(staleKey);\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({ fetchers: new Map(state.fetchers) });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(\n      dsMatches,\n      revalidatingFetchers,\n      revalidationRequest,\n      scopedContext\n    );\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    let redirect2 = findRedirect(loaderResults);\n    if (redirect2) {\n      return startRedirectNavigation(\n        revalidationRequest,\n        redirect2.result,\n        false,\n        { preventScrollReset }\n      );\n    }\n    redirect2 = findRedirect(fetcherResults);\n    if (redirect2) {\n      fetchRedirectIds.add(redirect2.key);\n      return startRedirectNavigation(\n        revalidationRequest,\n        redirect2.result,\n        false,\n        { preventScrollReset }\n      );\n    }\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      loaderResults,\n      void 0,\n      revalidatingFetchers,\n      fetcherResults\n    );\n    abortStaleFetchLoads(loadId);\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  async function handleFetcherLoader(key, routeId, path, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(\n      key,\n      getLoadingFetcher(\n        submission,\n        existingFetcher ? existingFetcher.data : void 0\n      ),\n      { flushSync }\n    );\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        matches,\n        new URL(fetchRequest.url).pathname,\n        fetchRequest.signal,\n        key\n      );\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, { flushSync });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(\n          key,\n          routeId,\n          getInternalRouterError(404, { pathname: path }),\n          { flushSync }\n        );\n        return;\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let match = getTargetMatch(matches, path);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let dsMatches = getTargetedDataStrategyMatches(\n      mapRouteProperties2,\n      manifest,\n      fetchRequest,\n      matches,\n      match,\n      hydrationRouteProperties2,\n      scopedContext\n    );\n    let results = await callDataStrategy(\n      fetchRequest,\n      dsMatches,\n      scopedContext,\n      key\n    );\n    let result = results[match.route.id];\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (fetchersQueuedForDeletion.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result, false, {\n          preventScrollReset\n        });\n        return;\n      }\n    }\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  async function startRedirectNavigation(request, redirect2, isNavigation, {\n    submission,\n    fetcherSubmission,\n    preventScrollReset,\n    replace: replace2\n  } = {}) {\n    if (redirect2.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n    let location = redirect2.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(\n      location,\n      new URL(request.url),\n      basename\n    );\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true\n    });\n    if (isBrowser2) {\n      let isDocumentReload = false;\n      if (redirect2.response.headers.has(\"X-Remix-Reload-Document\")) {\n        isDocumentReload = true;\n      } else if (isAbsoluteUrl(location)) {\n        const url = createBrowserURLImpl(location, true);\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace2) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n    pendingNavigationController = null;\n    let redirectNavigationType = replace2 === true || redirect2.response.headers.has(\"X-Remix-Replace\") ? \"REPLACE\" /* Replace */ : \"PUSH\" /* Push */;\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectNavigationType, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: location\n        },\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n      });\n    } else {\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectNavigationType, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n      });\n    }\n  }\n  async function callDataStrategy(request, matches, scopedContext, fetcherKey) {\n    let results;\n    let dataResults = {};\n    try {\n      results = await callDataStrategyImpl(\n        dataStrategyImpl,\n        request,\n        matches,\n        fetcherKey,\n        scopedContext,\n        false\n      );\n    } catch (e) {\n      matches.filter((m) => m.shouldLoad).forEach((m) => {\n        dataResults[m.route.id] = {\n          type: \"error\" /* error */,\n          error: e\n        };\n      });\n      return dataResults;\n    }\n    if (request.signal.aborted) {\n      return dataResults;\n    }\n    for (let [routeId, result] of Object.entries(results)) {\n      if (isRedirectDataStrategyResult(result)) {\n        let response = result.result;\n        dataResults[routeId] = {\n          type: \"redirect\" /* redirect */,\n          response: normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            routeId,\n            matches,\n            basename\n          )\n        };\n      } else {\n        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\n      }\n    }\n    return dataResults;\n  }\n  async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {\n    let loaderResultsPromise = callDataStrategy(\n      request,\n      matches,\n      scopedContext,\n      null\n    );\n    let fetcherResultsPromise = Promise.all(\n      fetchersToLoad.map(async (f) => {\n        if (f.matches && f.match && f.request && f.controller) {\n          let results = await callDataStrategy(\n            f.request,\n            f.matches,\n            scopedContext,\n            f.key\n          );\n          let result = results[f.match.route.id];\n          return { [f.key]: result };\n        } else {\n          return Promise.resolve({\n            [f.key]: {\n              type: \"error\" /* error */,\n              error: getInternalRouterError(404, {\n                pathname: f.path\n              })\n            }\n          });\n        }\n      })\n    );\n    let loaderResults = await loaderResultsPromise;\n    let fetcherResults = (await fetcherResultsPromise).reduce(\n      (acc, r) => Object.assign(acc, r),\n      {}\n    );\n    return {\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    isRevalidationRequired = true;\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.add(key);\n      }\n      abortFetcher(key);\n    });\n  }\n  function updateFetcherState(key, fetcher, opts = {}) {\n    state.fetchers.set(key, fetcher);\n    updateState(\n      { fetchers: new Map(state.fetchers) },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n  function setFetcherError(key, routeId, error, opts = {}) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState(\n      {\n        errors: {\n          [boundaryMatch.route.id]: error\n        },\n        fetchers: new Map(state.fetchers)\n      },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n  function getFetcher(key) {\n    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n    if (fetchersQueuedForDeletion.has(key)) {\n      fetchersQueuedForDeletion.delete(key);\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    fetchersQueuedForDeletion.delete(key);\n    cancelledFetcherLoads.delete(key);\n    state.fetchers.delete(key);\n  }\n  function queueFetcherForDeletion(key) {\n    let count = (activeFetchers.get(key) || 0) - 1;\n    if (count <= 0) {\n      activeFetchers.delete(key);\n      fetchersQueuedForDeletion.add(key);\n    } else {\n      activeFetchers.set(key, count);\n    }\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    if (controller) {\n      controller.abort();\n      fetchControllers.delete(key);\n    }\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    invariant(\n      blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\",\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction\n  }) {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      return;\n    }\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n  function handleNavigational404(pathname) {\n    let error = getInternalRouterError(404, { pathname });\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let { matches, route } = getShortCircuitMatches(routesToUse);\n    return { notFoundMatches: matches, route, error };\n  }\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions2 = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey2 = getKey || null;\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n    return () => {\n      savedScrollPositions2 = null;\n      getScrollPosition = null;\n      getScrollRestorationKey2 = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey2) {\n      let key = getScrollRestorationKey2(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions2 && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions2[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions2) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions2[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function checkFogOfWar(matches, routesToUse, pathname) {\n    if (init.patchRoutesOnNavigation) {\n      if (!matches) {\n        let fogMatches = matchRoutesImpl(\n          routesToUse,\n          pathname,\n          basename,\n          true\n        );\n        return { active: true, matches: fogMatches || [] };\n      } else {\n        if (Object.keys(matches[0].params).length > 0) {\n          let partialMatches = matchRoutesImpl(\n            routesToUse,\n            pathname,\n            basename,\n            true\n          );\n          return { active: true, matches: partialMatches };\n        }\n      }\n    }\n    return { active: false, matches: null };\n  }\n  async function discoverRoutes(matches, pathname, signal, fetcherKey) {\n    if (!init.patchRoutesOnNavigation) {\n      return { type: \"success\", matches };\n    }\n    let partialMatches = matches;\n    while (true) {\n      let isNonHMR = inFlightDataRoutes == null;\n      let routesToUse = inFlightDataRoutes || dataRoutes;\n      let localManifest = manifest;\n      try {\n        await init.patchRoutesOnNavigation({\n          signal,\n          path: pathname,\n          matches: partialMatches,\n          fetcherKey,\n          patch: (routeId, children) => {\n            if (signal.aborted) return;\n            patchRoutesImpl(\n              routeId,\n              children,\n              routesToUse,\n              localManifest,\n              mapRouteProperties2,\n              false\n            );\n          }\n        });\n      } catch (e) {\n        return { type: \"error\", error: e, partialMatches };\n      } finally {\n        if (isNonHMR && !signal.aborted) {\n          dataRoutes = [...dataRoutes];\n        }\n      }\n      if (signal.aborted) {\n        return { type: \"aborted\" };\n      }\n      let newMatches = matchRoutes(routesToUse, pathname, basename);\n      if (newMatches) {\n        return { type: \"success\", matches: newMatches };\n      }\n      let newPartialMatches = matchRoutesImpl(\n        routesToUse,\n        pathname,\n        basename,\n        true\n      );\n      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(\n        (m, i) => m.route.id === newPartialMatches[i].route.id\n      )) {\n        return { type: \"success\", matches: null };\n      }\n      partialMatches = newPartialMatches;\n    }\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties2,\n      void 0,\n      manifest\n    );\n  }\n  function patchRoutes(routeId, children, unstable_allowElementMutations = false) {\n    let isNonHMR = inFlightDataRoutes == null;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    patchRoutesImpl(\n      routeId,\n      children,\n      routesToUse,\n      manifest,\n      mapRouteProperties2,\n      unstable_allowElementMutations\n    );\n    if (isNonHMR) {\n      dataRoutes = [...dataRoutes];\n      updateState({});\n    }\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch: fetch2,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to) => init.history.createHref(to),\n    encodeLocation: (to) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: queueFetcherForDeletion,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    patchRoutes,\n    _internalFetchControllers: fetchControllers,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n    _internalSetStateDoNotUseOrYouWillBreakYourApp(newState) {\n      updateState(newState);\n    }\n  };\n  return router;\n}\nfunction createStaticHandler(routes, opts) {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties2,\n    void 0,\n    manifest\n  );\n  async function query(request, {\n    requestContext,\n    filterMatchesToLoad,\n    skipLoaderErrorBubbling,\n    skipRevalidation,\n    dataStrategy,\n    unstable_stream: stream,\n    unstable_respond: respond\n  } = {}) {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n    let respondOrStreamStaticContext = (ctx) => {\n      return stream ? stream(\n        requestContext,\n        () => Promise.resolve(ctx)\n      ) : respond ? respond(ctx) : ctx;\n    };\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n      let staticContext = {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n      return respondOrStreamStaticContext(staticContext);\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n      let staticContext = {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n      return respondOrStreamStaticContext(staticContext);\n    }\n    if (stream || respond && matches.some(\n      (m) => m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware\n    )) {\n      invariant(\n        requestContext instanceof unstable_RouterContextProvider,\n        \"When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\"\n      );\n      try {\n        await loadLazyMiddlewareForMatches(\n          matches,\n          manifest,\n          mapRouteProperties2\n        );\n        let renderedStaticContext;\n        let response = await runMiddlewarePipeline(\n          {\n            request,\n            matches,\n            params: matches[0].params,\n            // If we're calling middleware then it must be enabled so we can cast\n            // this to the proper type knowing it's not an `AppLoadContext`\n            context: requestContext\n          },\n          true,\n          async () => {\n            if (stream) {\n              let res2 = await stream(\n                requestContext,\n                async (revalidationRequest) => {\n                  let result3 = await queryImpl(\n                    revalidationRequest,\n                    location,\n                    matches,\n                    requestContext,\n                    dataStrategy || null,\n                    skipLoaderErrorBubbling === true,\n                    null,\n                    filterMatchesToLoad || null,\n                    skipRevalidation === true\n                  );\n                  return isResponse(result3) ? result3 : { location, basename, ...result3 };\n                }\n              );\n              return res2;\n            }\n            invariant(respond, \"Expected respond to be defined\");\n            let result2 = await queryImpl(\n              request,\n              location,\n              matches,\n              requestContext,\n              dataStrategy || null,\n              skipLoaderErrorBubbling === true,\n              null,\n              filterMatchesToLoad || null,\n              skipRevalidation === true\n            );\n            if (isResponse(result2)) {\n              return result2;\n            }\n            renderedStaticContext = { location, basename, ...result2 };\n            let res = await respond(renderedStaticContext);\n            return res;\n          },\n          async (error, routeId) => {\n            if (isResponse(error)) {\n              return error;\n            }\n            if (renderedStaticContext) {\n              if (routeId in renderedStaticContext.loaderData) {\n                renderedStaticContext.loaderData[routeId] = void 0;\n              }\n              let staticContext = getStaticContextFromError(\n                dataRoutes,\n                renderedStaticContext,\n                error,\n                skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id\n              );\n              return respondOrStreamStaticContext(staticContext);\n            } else {\n              let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(\n                matches,\n                matches.find(\n                  (m) => m.route.id === routeId || m.route.loader\n                )?.route.id || routeId\n              ).route.id;\n              let staticContext = {\n                matches,\n                location,\n                basename,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                  [boundaryRouteId]: error\n                },\n                statusCode: isRouteErrorResponse(error) ? error.status : 500,\n                actionHeaders: {},\n                loaderHeaders: {}\n              };\n              return respondOrStreamStaticContext(staticContext);\n            }\n          }\n        );\n        invariant(isResponse(response), \"Expected a response in query()\");\n        return response;\n      } catch (e) {\n        if (isResponse(e)) {\n          return e;\n        }\n        throw e;\n      }\n    }\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      dataStrategy || null,\n      skipLoaderErrorBubbling === true,\n      null,\n      filterMatchesToLoad || null,\n      skipRevalidation === true\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n    return { location, basename, ...result };\n  }\n  async function queryRoute(request, {\n    routeId,\n    requestContext,\n    dataStrategy,\n    unstable_respond: respond\n  } = {}) {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n    let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n    if (respond && matches.some(\n      (m) => m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware\n    )) {\n      invariant(\n        requestContext instanceof unstable_RouterContextProvider,\n        \"When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\"\n      );\n      await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n      let response = await runMiddlewarePipeline(\n        {\n          request,\n          matches,\n          params: matches[0].params,\n          // If we're calling middleware then it must be enabled so we can cast\n          // this to the proper type knowing it's not an `AppLoadContext`\n          context: requestContext\n        },\n        true,\n        async () => {\n          let result2 = await queryImpl(\n            request,\n            location,\n            matches,\n            requestContext,\n            dataStrategy || null,\n            false,\n            match,\n            null,\n            false\n          );\n          if (isResponse(result2)) {\n            return respond(result2);\n          }\n          let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;\n          if (error2 !== void 0) {\n            throw error2;\n          }\n          let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];\n          return typeof value === \"string\" ? new Response(value) : Response.json(value);\n        },\n        (error2) => {\n          if (isResponse(error2)) {\n            return respond(error2);\n          }\n          return new Response(String(error2), {\n            status: 500,\n            statusText: \"Unexpected Server Error\"\n          });\n        }\n      );\n      return response;\n    }\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      dataStrategy || null,\n      false,\n      match,\n      null,\n      false\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : void 0;\n    if (error !== void 0) {\n      throw error;\n    }\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      return Object.values(result.loaderData)[0];\n    }\n    return void 0;\n  }\n  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n    try {\n      if (isMutationMethod(request.method)) {\n        let result2 = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          dataStrategy,\n          skipLoaderErrorBubbling,\n          routeMatch != null,\n          filterMatchesToLoad,\n          skipRevalidation\n        );\n        return result2;\n      }\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        dataStrategy,\n        skipLoaderErrorBubbling,\n        routeMatch,\n        filterMatchesToLoad\n      );\n      return isResponse(result) ? result : {\n        ...result,\n        actionData: null,\n        actionHeaders: {}\n      };\n    } catch (e) {\n      if (isDataStrategyResult(e) && isResponse(e.result)) {\n        if (e.type === \"error\" /* error */) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: \"error\" /* error */,\n        error\n      };\n    } else {\n      let dsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        request,\n        matches,\n        actionMatch,\n        [],\n        requestContext\n      );\n      let results = await callDataStrategy(\n        request,\n        dsMatches,\n        isRouteRequest,\n        requestContext,\n        dataStrategy\n      );\n      result = results[actionMatch.route.id];\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest);\n      }\n    }\n    if (isRedirectResult(result)) {\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")\n        }\n      });\n    }\n    if (isRouteRequest) {\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n    }\n    if (skipRevalidation) {\n      if (isErrorResult(result)) {\n        let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n        return {\n          statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n          actionData: null,\n          actionHeaders: {\n            ...result.headers ? { [actionMatch.route.id]: result.headers } : {}\n          },\n          matches,\n          loaderData: {},\n          errors: {\n            [boundaryMatch.route.id]: result.error\n          },\n          loaderHeaders: {}\n        };\n      } else {\n        return {\n          actionData: {\n            [actionMatch.route.id]: result.data\n          },\n          actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {},\n          matches,\n          loaderData: {},\n          errors: null,\n          statusCode: result.statusCode || 200,\n          loaderHeaders: {}\n        };\n      }\n    }\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    if (isErrorResult(result)) {\n      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n      let handlerContext2 = await loadRouteData(\n        loaderRequest,\n        matches,\n        requestContext,\n        dataStrategy,\n        skipLoaderErrorBubbling,\n        null,\n        filterMatchesToLoad,\n        [boundaryMatch.route.id, result]\n      );\n      return {\n        ...handlerContext2,\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n        actionData: null,\n        actionHeaders: {\n          ...result.headers ? { [actionMatch.route.id]: result.headers } : {}\n        }\n      };\n    }\n    let handlerContext = await loadRouteData(\n      loaderRequest,\n      matches,\n      requestContext,\n      dataStrategy,\n      skipLoaderErrorBubbling,\n      null,\n      filterMatchesToLoad\n    );\n    return {\n      ...handlerContext,\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      // action status codes take precedence over loader status codes\n      ...result.statusCode ? { statusCode: result.statusCode } : {},\n      actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}\n    };\n  }\n  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {\n    let isRouteRequest = routeMatch != null;\n    if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id\n      });\n    }\n    let dsMatches;\n    if (routeMatch) {\n      dsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        request,\n        matches,\n        routeMatch,\n        [],\n        requestContext\n      );\n    } else {\n      let maxIdx = pendingActionResult && isErrorResult(pendingActionResult[1]) ? (\n        // Up to but not including the boundary\n        matches.findIndex((m) => m.route.id === pendingActionResult[0]) - 1\n      ) : void 0;\n      dsMatches = matches.map((match, index) => {\n        if (maxIdx != null && index > maxIdx) {\n          return getDataStrategyMatch(\n            mapRouteProperties2,\n            manifest,\n            request,\n            match,\n            [],\n            requestContext,\n            false\n          );\n        }\n        return getDataStrategyMatch(\n          mapRouteProperties2,\n          manifest,\n          request,\n          match,\n          [],\n          requestContext,\n          (match.route.loader || match.route.lazy) != null && (!filterMatchesToLoad || filterMatchesToLoad(match))\n        );\n      });\n    }\n    if (!dataStrategy && !dsMatches.some((m) => m.shouldLoad)) {\n      return {\n        matches,\n        loaderData: {},\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null,\n        statusCode: 200,\n        loaderHeaders: {}\n      };\n    }\n    let results = await callDataStrategy(\n      request,\n      dsMatches,\n      isRouteRequest,\n      requestContext,\n      dataStrategy\n    );\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest);\n    }\n    let handlerContext = processRouteLoaderData(\n      matches,\n      results,\n      pendingActionResult,\n      true,\n      skipLoaderErrorBubbling\n    );\n    return {\n      ...handlerContext,\n      matches\n    };\n  }\n  async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {\n    let results = await callDataStrategyImpl(\n      dataStrategy || defaultDataStrategy,\n      request,\n      matches,\n      null,\n      requestContext,\n      true\n    );\n    let dataResults = {};\n    await Promise.all(\n      matches.map(async (match) => {\n        if (!(match.route.id in results)) {\n          return;\n        }\n        let result = results[match.route.id];\n        if (isRedirectDataStrategyResult(result)) {\n          let response = result.result;\n          throw normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            match.route.id,\n            matches,\n            basename\n          );\n        }\n        if (isResponse(result.result) && isRouteRequest) {\n          throw result;\n        }\n        dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n      })\n    );\n    return dataResults;\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\nfunction getStaticContextFromError(routes, handlerContext, error, boundaryId) {\n  let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;\n  return {\n    ...handlerContext,\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [errorBoundaryId]: error\n    }\n  };\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest) {\n  if (request.signal.reason !== void 0) {\n    throw request.signal.reason;\n  }\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(\n    `${method}() call aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`\n  );\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  let path = resolveTo(\n    to ? to : \".\",\n    getResolveToMatches(contextualMatches),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n    let nakedIndex = hasNakedIndexQuery(path.search);\n    if (activeRouteMatch.route.index && !nakedIndex) {\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } else if (!activeRouteMatch.route.index && nakedIndex) {\n      let params = new URLSearchParams(path.search);\n      let indexValues = params.getAll(\"index\");\n      params.delete(\"index\");\n      indexValues.filter((v) => v).forEach((v) => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? `?${qs}` : \"\";\n    }\n  }\n  if (basename !== \"/\") {\n    path.pathname = prependBasename({ basename, pathname: path.pathname });\n  }\n  return createPath(path);\n}\nfunction normalizeNavigateOptions(isFetcher, path, opts) {\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" })\n  });\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = rawFormMethod.toUpperCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== void 0) {\n    if (opts.formEncType === \"text/plain\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n        Array.from(opts.body.entries()).reduce(\n          (acc, [name, value]) => `${acc}${name}=${value}\n`,\n          \"\"\n        )\n      ) : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: void 0,\n          json: void 0,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: void 0,\n            json,\n            text: void 0\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: void 0,\n    text: void 0\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n  let parsedPath = parsePath(path);\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n  return { path: createPath(parsedPath), submission };\n}\nfunction getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, hasPatchRoutesOnNavigation, pendingActionResult) {\n  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  let maxIdx;\n  if (initialHydration && state.errors) {\n    let boundaryId = Object.keys(state.errors)[0];\n    maxIdx = matches.findIndex((m) => m.route.id === boundaryId);\n  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n    let boundaryId = pendingActionResult[0];\n    maxIdx = matches.findIndex((m) => m.route.id === boundaryId) - 1;\n  }\n  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;\n  let shouldSkipRevalidation = actionStatus && actionStatus >= 400;\n  let baseShouldRevalidateArgs = {\n    currentUrl,\n    currentParams: state.matches[0]?.params || {},\n    nextUrl,\n    nextParams: matches[0].params,\n    ...submission,\n    actionResult,\n    actionStatus\n  };\n  let dsMatches = matches.map((match, index) => {\n    let { route } = match;\n    let forceShouldLoad = null;\n    if (maxIdx != null && index > maxIdx) {\n      forceShouldLoad = false;\n    } else if (route.lazy) {\n      forceShouldLoad = true;\n    } else if (route.loader == null) {\n      forceShouldLoad = false;\n    } else if (initialHydration) {\n      forceShouldLoad = shouldLoadRouteOnHydration(\n        route,\n        state.loaderData,\n        state.errors\n      );\n    } else if (isNewLoader(state.loaderData, state.matches[index], match)) {\n      forceShouldLoad = true;\n    }\n    if (forceShouldLoad !== null) {\n      return getDataStrategyMatch(\n        mapRouteProperties2,\n        manifest,\n        request,\n        match,\n        lazyRoutePropertiesToSkip,\n        scopedContext,\n        forceShouldLoad\n      );\n    }\n    let defaultShouldRevalidate = shouldSkipRevalidation ? false : (\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match)\n    );\n    let shouldRevalidateArgs = {\n      ...baseShouldRevalidateArgs,\n      defaultShouldRevalidate\n    };\n    let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);\n    return getDataStrategyMatch(\n      mapRouteProperties2,\n      manifest,\n      request,\n      match,\n      lazyRoutePropertiesToSkip,\n      scopedContext,\n      shouldLoad,\n      shouldRevalidateArgs\n    );\n  });\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {\n      return;\n    }\n    let fetcher = state.fetchers.get(key);\n    let isMidInitialLoad = fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0;\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    if (!fetcherMatches) {\n      if (hasPatchRoutesOnNavigation && isMidInitialLoad) {\n        return;\n      }\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        request: null,\n        controller: null\n      });\n      return;\n    }\n    if (fetchRedirectIds.has(key)) {\n      return;\n    }\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let fetchController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      history,\n      f.path,\n      fetchController.signal\n    );\n    let fetcherDsMatches = null;\n    if (cancelledFetcherLoads.has(key)) {\n      cancelledFetcherLoads.delete(key);\n      fetcherDsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        fetchRequest,\n        fetcherMatches,\n        fetcherMatch,\n        lazyRoutePropertiesToSkip,\n        scopedContext\n      );\n    } else if (isMidInitialLoad) {\n      if (isRevalidationRequired) {\n        fetcherDsMatches = getTargetedDataStrategyMatches(\n          mapRouteProperties2,\n          manifest,\n          fetchRequest,\n          fetcherMatches,\n          fetcherMatch,\n          lazyRoutePropertiesToSkip,\n          scopedContext\n        );\n      }\n    } else {\n      let shouldRevalidateArgs = {\n        ...baseShouldRevalidateArgs,\n        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n      };\n      if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {\n        fetcherDsMatches = getTargetedDataStrategyMatches(\n          mapRouteProperties2,\n          manifest,\n          fetchRequest,\n          fetcherMatches,\n          fetcherMatch,\n          lazyRoutePropertiesToSkip,\n          scopedContext,\n          shouldRevalidateArgs\n        );\n      }\n    }\n    if (fetcherDsMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherDsMatches,\n        match: fetcherMatch,\n        request: fetchRequest,\n        controller: fetchController\n      });\n    }\n  });\n  return { dsMatches, revalidatingFetchers };\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n  if (route.lazy) {\n    return true;\n  }\n  if (!route.loader) {\n    return false;\n  }\n  let hasData = loaderData != null && route.id in loaderData;\n  let hasError = errors != null && errors[route.id] !== void 0;\n  if (!hasData && hasError) {\n    return false;\n  }\n  if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n    return true;\n  }\n  return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew = (\n    // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id\n  );\n  let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2, allowElementMutations) {\n  let childrenToPatch;\n  if (routeId) {\n    let route = manifest[routeId];\n    invariant(\n      route,\n      `No route found to patch children into: routeId = ${routeId}`\n    );\n    if (!route.children) {\n      route.children = [];\n    }\n    childrenToPatch = route.children;\n  } else {\n    childrenToPatch = routesToUse;\n  }\n  let uniqueChildren = [];\n  let existingChildren = [];\n  children.forEach((newRoute) => {\n    let existingRoute = childrenToPatch.find(\n      (existingRoute2) => isSameRoute(newRoute, existingRoute2)\n    );\n    if (existingRoute) {\n      existingChildren.push({ existingRoute, newRoute });\n    } else {\n      uniqueChildren.push(newRoute);\n    }\n  });\n  if (uniqueChildren.length > 0) {\n    let newRoutes = convertRoutesToDataRoutes(\n      uniqueChildren,\n      mapRouteProperties2,\n      [routeId || \"_\", \"patch\", String(childrenToPatch?.length || \"0\")],\n      manifest\n    );\n    childrenToPatch.push(...newRoutes);\n  }\n  if (allowElementMutations && existingChildren.length > 0) {\n    for (let i = 0; i < existingChildren.length; i++) {\n      let { existingRoute, newRoute } = existingChildren[i];\n      let existingRouteTyped = existingRoute;\n      let [newRouteTyped] = convertRoutesToDataRoutes(\n        [newRoute],\n        mapRouteProperties2,\n        [],\n        // Doesn't matter for mutated routes since they already have an id\n        {},\n        // Don't touch the manifest here since we're updating in place\n        true\n      );\n      Object.assign(existingRouteTyped, {\n        element: newRouteTyped.element ? newRouteTyped.element : existingRouteTyped.element,\n        errorElement: newRouteTyped.errorElement ? newRouteTyped.errorElement : existingRouteTyped.errorElement,\n        hydrateFallbackElement: newRouteTyped.hydrateFallbackElement ? newRouteTyped.hydrateFallbackElement : existingRouteTyped.hydrateFallbackElement\n      });\n    }\n  }\n}\nfunction isSameRoute(newRoute, existingRoute) {\n  if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n    return true;\n  }\n  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n    return false;\n  }\n  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n    return true;\n  }\n  return newRoute.children.every(\n    (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))\n  );\n}\nvar lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();\nvar loadLazyRouteProperty = ({\n  key,\n  route,\n  manifest,\n  mapRouteProperties: mapRouteProperties2\n}) => {\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== \"object\") {\n    return;\n  }\n  let lazyFn = routeToUpdate.lazy[key];\n  if (!lazyFn) {\n    return;\n  }\n  let cache = lazyRoutePropertyCache.get(routeToUpdate);\n  if (!cache) {\n    cache = {};\n    lazyRoutePropertyCache.set(routeToUpdate, cache);\n  }\n  let cachedPromise = cache[key];\n  if (cachedPromise) {\n    return cachedPromise;\n  }\n  let propertyPromise = (async () => {\n    let isUnsupported = isUnsupportedLazyRouteObjectKey(key);\n    let staticRouteValue = routeToUpdate[key];\n    let isStaticallyDefined = staticRouteValue !== void 0 && key !== \"hasErrorBoundary\";\n    if (isUnsupported) {\n      warning(\n        !isUnsupported,\n        \"Route property \" + key + \" is not a supported lazy route property. This property will be ignored.\"\n      );\n      cache[key] = Promise.resolve();\n    } else if (isStaticallyDefined) {\n      warning(\n        false,\n        `Route \"${routeToUpdate.id}\" has a static property \"${key}\" defined. The lazy property will be ignored.`\n      );\n    } else {\n      let value = await lazyFn();\n      if (value != null) {\n        Object.assign(routeToUpdate, { [key]: value });\n        Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));\n      }\n    }\n    if (typeof routeToUpdate.lazy === \"object\") {\n      routeToUpdate.lazy[key] = void 0;\n      if (Object.values(routeToUpdate.lazy).every((value) => value === void 0)) {\n        routeToUpdate.lazy = void 0;\n      }\n    }\n  })();\n  cache[key] = propertyPromise;\n  return propertyPromise;\n};\nvar lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();\nfunction loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  if (!route.lazy) {\n    return {\n      lazyRoutePromise: void 0,\n      lazyHandlerPromise: void 0\n    };\n  }\n  if (typeof route.lazy === \"function\") {\n    let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);\n    if (cachedPromise) {\n      return {\n        lazyRoutePromise: cachedPromise,\n        lazyHandlerPromise: cachedPromise\n      };\n    }\n    let lazyRoutePromise2 = (async () => {\n      invariant(\n        typeof route.lazy === \"function\",\n        \"No lazy route function found\"\n      );\n      let lazyRoute = await route.lazy();\n      let routeUpdates = {};\n      for (let lazyRouteProperty in lazyRoute) {\n        let lazyValue = lazyRoute[lazyRouteProperty];\n        if (lazyValue === void 0) {\n          continue;\n        }\n        let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        if (isUnsupported) {\n          warning(\n            !isUnsupported,\n            \"Route property \" + lazyRouteProperty + \" is not a supported property to be returned from a lazy route function. This property will be ignored.\"\n          );\n        } else if (isStaticallyDefined) {\n          warning(\n            !isStaticallyDefined,\n            `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" defined but its lazy function is also returning a value for this property. The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n          );\n        } else {\n          routeUpdates[lazyRouteProperty] = lazyValue;\n        }\n      }\n      Object.assign(routeToUpdate, routeUpdates);\n      Object.assign(routeToUpdate, {\n        // To keep things framework agnostic, we use the provided `mapRouteProperties`\n        // function to set the framework-aware properties (`element`/`hasErrorBoundary`)\n        // since the logic will differ between frameworks.\n        ...mapRouteProperties2(routeToUpdate),\n        lazy: void 0\n      });\n    })();\n    lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);\n    lazyRoutePromise2.catch(() => {\n    });\n    return {\n      lazyRoutePromise: lazyRoutePromise2,\n      lazyHandlerPromise: lazyRoutePromise2\n    };\n  }\n  let lazyKeys = Object.keys(route.lazy);\n  let lazyPropertyPromises = [];\n  let lazyHandlerPromise = void 0;\n  for (let key of lazyKeys) {\n    if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {\n      continue;\n    }\n    let promise = loadLazyRouteProperty({\n      key,\n      route,\n      manifest,\n      mapRouteProperties: mapRouteProperties2\n    });\n    if (promise) {\n      lazyPropertyPromises.push(promise);\n      if (key === type) {\n        lazyHandlerPromise = promise;\n      }\n    }\n  }\n  let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(() => {\n  }) : void 0;\n  lazyRoutePromise?.catch(() => {\n  });\n  lazyHandlerPromise?.catch(() => {\n  });\n  return {\n    lazyRoutePromise,\n    lazyHandlerPromise\n  };\n}\nfunction isNonNullable(value) {\n  return value !== void 0;\n}\nfunction loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {\n  let promises = matches.map(({ route }) => {\n    if (typeof route.lazy !== \"object\" || !route.lazy.unstable_middleware) {\n      return void 0;\n    }\n    return loadLazyRouteProperty({\n      key: \"unstable_middleware\",\n      route,\n      manifest,\n      mapRouteProperties: mapRouteProperties2\n    });\n  }).filter(isNonNullable);\n  return promises.length > 0 ? Promise.all(promises) : void 0;\n}\nasync function defaultDataStrategy(args) {\n  let matchesToLoad = args.matches.filter((m) => m.shouldLoad);\n  let keyedResults = {};\n  let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));\n  results.forEach((result, i) => {\n    keyedResults[matchesToLoad[i].route.id] = result;\n  });\n  return keyedResults;\n}\nasync function defaultDataStrategyWithMiddleware(args) {\n  if (!args.matches.some((m) => m.route.unstable_middleware)) {\n    return defaultDataStrategy(args);\n  }\n  return runMiddlewarePipeline(\n    args,\n    false,\n    () => defaultDataStrategy(args),\n    (error, routeId) => ({ [routeId]: { type: \"error\", result: error } })\n  );\n}\nasync function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {\n  let { matches, request, params, context } = args;\n  let middlewareState = {\n    handlerResult: void 0\n  };\n  try {\n    let tuples = matches.flatMap(\n      (m) => m.route.unstable_middleware ? m.route.unstable_middleware.map((fn) => [m.route.id, fn]) : []\n    );\n    let result = await callRouteMiddleware(\n      { request, params, context },\n      tuples,\n      propagateResult,\n      middlewareState,\n      handler\n    );\n    return propagateResult ? result : middlewareState.handlerResult;\n  } catch (e) {\n    if (!middlewareState.middlewareError) {\n      throw e;\n    }\n    let result = await errorHandler(\n      middlewareState.middlewareError.error,\n      middlewareState.middlewareError.routeId\n    );\n    if (propagateResult || !middlewareState.handlerResult) {\n      return result;\n    }\n    return Object.assign(middlewareState.handlerResult, result);\n  }\n}\nasync function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {\n  let { request } = args;\n  if (request.signal.aborted) {\n    if (request.signal.reason) {\n      throw request.signal.reason;\n    }\n    throw new Error(\n      `Request aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`\n    );\n  }\n  let tuple = middlewares[idx];\n  if (!tuple) {\n    middlewareState.handlerResult = await handler();\n    return middlewareState.handlerResult;\n  }\n  let [routeId, middleware] = tuple;\n  let nextCalled = false;\n  let nextResult = void 0;\n  let next = async () => {\n    if (nextCalled) {\n      throw new Error(\"You may only call `next()` once per middleware\");\n    }\n    nextCalled = true;\n    let result = await callRouteMiddleware(\n      args,\n      middlewares,\n      propagateResult,\n      middlewareState,\n      handler,\n      idx + 1\n    );\n    if (propagateResult) {\n      nextResult = result;\n      return nextResult;\n    }\n  };\n  try {\n    let result = await middleware(\n      {\n        request: args.request,\n        params: args.params,\n        context: args.context\n      },\n      next\n    );\n    if (nextCalled) {\n      if (result === void 0) {\n        return nextResult;\n      } else {\n        return result;\n      }\n    } else {\n      return next();\n    }\n  } catch (error) {\n    if (!middlewareState.middlewareError) {\n      middlewareState.middlewareError = { routeId, error };\n    } else if (middlewareState.middlewareError.error !== error) {\n      middlewareState.middlewareError = { routeId, error };\n    }\n    throw error;\n  }\n}\nfunction getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {\n  let lazyMiddlewarePromise = loadLazyRouteProperty({\n    key: \"unstable_middleware\",\n    route: match.route,\n    manifest,\n    mapRouteProperties: mapRouteProperties2\n  });\n  let lazyRoutePromises = loadLazyRoute(\n    match.route,\n    isMutationMethod(request.method) ? \"action\" : \"loader\",\n    manifest,\n    mapRouteProperties2,\n    lazyRoutePropertiesToSkip\n  );\n  return {\n    middleware: lazyMiddlewarePromise,\n    route: lazyRoutePromises.lazyRoutePromise,\n    handler: lazyRoutePromises.lazyHandlerPromise\n  };\n}\nfunction getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {\n  let isUsingNewApi = false;\n  let _lazyPromises = getDataStrategyMatchLazyPromises(\n    mapRouteProperties2,\n    manifest,\n    request,\n    match,\n    lazyRoutePropertiesToSkip\n  );\n  return {\n    ...match,\n    _lazyPromises,\n    shouldLoad,\n    unstable_shouldRevalidateArgs,\n    unstable_shouldCallHandler(defaultShouldRevalidate) {\n      isUsingNewApi = true;\n      if (!unstable_shouldRevalidateArgs) {\n        return shouldLoad;\n      }\n      if (typeof defaultShouldRevalidate === \"boolean\") {\n        return shouldRevalidateLoader(match, {\n          ...unstable_shouldRevalidateArgs,\n          defaultShouldRevalidate\n        });\n      }\n      return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);\n    },\n    resolve(handlerOverride) {\n      if (isUsingNewApi || shouldLoad || handlerOverride && !isMutationMethod(request.method) && (match.route.lazy || match.route.loader)) {\n        return callLoaderOrAction({\n          request,\n          match,\n          lazyHandlerPromise: _lazyPromises?.handler,\n          lazyRoutePromise: _lazyPromises?.route,\n          handlerOverride,\n          scopedContext\n        });\n      }\n      return Promise.resolve({ type: \"data\" /* data */, result: void 0 });\n    }\n  };\n}\nfunction getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {\n  return matches.map((match) => {\n    if (match.route.id !== targetMatch.route.id) {\n      return {\n        ...match,\n        shouldLoad: false,\n        unstable_shouldRevalidateArgs: shouldRevalidateArgs,\n        unstable_shouldCallHandler: () => false,\n        _lazyPromises: getDataStrategyMatchLazyPromises(\n          mapRouteProperties2,\n          manifest,\n          request,\n          match,\n          lazyRoutePropertiesToSkip\n        ),\n        resolve: () => Promise.resolve({ type: \"data\", result: void 0 })\n      };\n    }\n    return getDataStrategyMatch(\n      mapRouteProperties2,\n      manifest,\n      request,\n      match,\n      lazyRoutePropertiesToSkip,\n      scopedContext,\n      true,\n      shouldRevalidateArgs\n    );\n  });\n}\nasync function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {\n  if (matches.some((m) => m._lazyPromises?.middleware)) {\n    await Promise.all(matches.map((m) => m._lazyPromises?.middleware));\n  }\n  let dataStrategyArgs = {\n    request,\n    params: matches[0].params,\n    context: scopedContext,\n    matches\n  };\n  let unstable_runClientMiddleware = isStaticHandler ? () => {\n    throw new Error(\n      \"You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`\"\n    );\n  } : (cb) => {\n    let typedDataStrategyArgs = dataStrategyArgs;\n    return runMiddlewarePipeline(\n      typedDataStrategyArgs,\n      false,\n      () => cb({\n        ...typedDataStrategyArgs,\n        fetcherKey,\n        unstable_runClientMiddleware: () => {\n          throw new Error(\n            \"Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler\"\n          );\n        }\n      }),\n      (error, routeId) => ({\n        [routeId]: { type: \"error\", result: error }\n      })\n    );\n  };\n  let results = await dataStrategyImpl({\n    ...dataStrategyArgs,\n    fetcherKey,\n    unstable_runClientMiddleware\n  });\n  try {\n    await Promise.all(\n      matches.flatMap((m) => [\n        m._lazyPromises?.handler,\n        m._lazyPromises?.route\n      ])\n    );\n  } catch (e) {\n  }\n  return results;\n}\nasync function callLoaderOrAction({\n  request,\n  match,\n  lazyHandlerPromise,\n  lazyRoutePromise,\n  handlerOverride,\n  scopedContext\n}) {\n  let result;\n  let onReject;\n  let isAction = isMutationMethod(request.method);\n  let type = isAction ? \"action\" : \"loader\";\n  let runHandler = (handler) => {\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    let actualHandler = (ctx) => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(\n          new Error(\n            `You cannot call the handler for a route which defines a boolean \"${type}\" [routeId: ${match.route.id}]`\n          )\n        );\n      }\n      return handler(\n        {\n          request,\n          params: match.params,\n          context: scopedContext\n        },\n        ...ctx !== void 0 ? [ctx] : []\n      );\n    };\n    let handlerPromise = (async () => {\n      try {\n        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());\n        return { type: \"data\", result: val };\n      } catch (e) {\n        return { type: \"error\", result: e };\n      }\n    })();\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n  try {\n    let handler = isAction ? match.route.action : match.route.loader;\n    if (lazyHandlerPromise || lazyRoutePromise) {\n      if (handler) {\n        let handlerError;\n        let [value] = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          // Ensure all lazy route promises are resolved before continuing\n          lazyHandlerPromise,\n          lazyRoutePromise\n        ]);\n        if (handlerError !== void 0) {\n          throw handlerError;\n        }\n        result = value;\n      } else {\n        await lazyHandlerPromise;\n        let handler2 = isAction ? match.route.action : match.route.loader;\n        if (handler2) {\n          [result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          return { type: \"data\" /* data */, result: void 0 };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n  } catch (e) {\n    return { type: \"error\" /* error */, result: e };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  return result;\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n  let { result, type } = dataStrategyResult;\n  if (isResponse(result)) {\n    let data2;\n    try {\n      let contentType = result.headers.get(\"Content-Type\");\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n        if (result.body == null) {\n          data2 = null;\n        } else {\n          data2 = await result.json();\n        }\n      } else {\n        data2 = await result.text();\n      }\n    } catch (e) {\n      return { type: \"error\" /* error */, error: e };\n    }\n    if (type === \"error\" /* error */) {\n      return {\n        type: \"error\" /* error */,\n        error: new ErrorResponseImpl(result.status, result.statusText, data2),\n        statusCode: result.status,\n        headers: result.headers\n      };\n    }\n    return {\n      type: \"data\" /* data */,\n      data: data2,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (type === \"error\" /* error */) {\n    if (isDataWithResponseInit(result)) {\n      if (result.data instanceof Error) {\n        return {\n          type: \"error\" /* error */,\n          error: result.data,\n          statusCode: result.init?.status,\n          headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n        };\n      }\n      return {\n        type: \"error\" /* error */,\n        error: new ErrorResponseImpl(\n          result.init?.status || 500,\n          void 0,\n          result.data\n        ),\n        statusCode: isRouteErrorResponse(result) ? result.status : void 0,\n        headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n      };\n    }\n    return {\n      type: \"error\" /* error */,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : void 0\n    };\n  }\n  if (isDataWithResponseInit(result)) {\n    return {\n      type: \"data\" /* data */,\n      data: result.data,\n      statusCode: result.init?.status,\n      headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n    };\n  }\n  return { type: \"data\" /* data */, data: result };\n}\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {\n  let location = response.headers.get(\"Location\");\n  invariant(\n    location,\n    \"Redirects returned/thrown from loaders/actions must have a Location header\"\n  );\n  if (!isAbsoluteUrl(location)) {\n    let trimmedMatches = matches.slice(\n      0,\n      matches.findIndex((m) => m.route.id === routeId) + 1\n    );\n    location = normalizeTo(\n      new URL(request.url),\n      trimmedMatches,\n      basename,\n      location\n    );\n    response.headers.set(\"Location\", location);\n  }\n  return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n  if (isAbsoluteUrl(location)) {\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = { signal };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;\n  matches.forEach((match) => {\n    if (!(match.route.id in results)) {\n      return;\n    }\n    let id = match.route.id;\n    let result = results[id];\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      let error = result.error;\n      if (pendingError !== void 0) {\n        error = pendingError;\n        pendingError = void 0;\n      }\n      errors = errors || {};\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n      if (!isStaticHandler) {\n        loaderData[id] = ResetLoaderDataSymbol;\n      }\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      loaderData[id] = result.data;\n      if (result.statusCode && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  if (pendingError !== void 0 && pendingActionResult) {\n    errors = { [pendingActionResult[0]]: pendingError };\n    if (pendingActionResult[2]) {\n      loaderData[pendingActionResult[2]] = void 0;\n    }\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    results,\n    pendingActionResult\n  );\n  revalidatingFetchers.filter((f) => !f.matches || f.matches.some((m) => m.shouldLoad)).forEach((rf) => {\n    let { key, match, controller } = rf;\n    let result = fetcherResults[key];\n    invariant(result, \"Did not find corresponding fetcher result\");\n    if (controller && controller.signal.aborted) {\n      return;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  });\n  return { loaderData, errors };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {\n    merged[k] = v;\n    return merged;\n  }, {});\n  for (let match of matches) {\n    let id = match.route.id;\n    if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1]) ? {\n    // Clear out prior actionData on errors\n    actionData: {}\n  } : {\n    actionData: {\n      [pendingActionResult[0]]: pendingActionResult[1].data\n    }\n  };\n}\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-error-route__`\n  };\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route\n      }\n    ],\n    route\n  };\n}\nfunction getInternalRouterError(status, {\n  pathname,\n  routeId,\n  method,\n  type,\n  message\n} = {}) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = `You made a ${method} request to \"${pathname}\" but did not provide a \\`loader\\` for route \"${routeId}\", so there is no way to handle the request.`;\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = `You made a ${method.toUpperCase()} request to \"${pathname}\" but did not provide an \\`action\\` for route \"${routeId}\", so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\nfunction findRedirect(results) {\n  let entries = Object.entries(results);\n  for (let i = entries.length - 1; i >= 0; i--) {\n    let [key, result] = entries[i];\n    if (isRedirectResult(result)) {\n      return { key, result };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    return true;\n  } else if (b.hash !== \"\") {\n    return true;\n  }\n  return false;\n}\nfunction isDataStrategyResult(result) {\n  return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === \"data\" /* data */ || result.type === \"error\" /* error */);\n}\nfunction isRedirectDataStrategyResult(result) {\n  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isErrorResult(result) {\n  return result.type === \"error\" /* error */;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === \"redirect\" /* redirect */;\n}\nfunction isDataWithResponseInit(value) {\n  return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(result) {\n  return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has(\"Location\");\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toUpperCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toUpperCase());\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    return matches[matches.length - 1];\n  }\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: void 0,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: void 0,\n      text: void 0\n    };\n  } else if (json !== void 0) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json,\n      text: void 0\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data2) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data: data2\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data: data2\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : void 0\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data2) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0,\n    data: data2\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(\n      TRANSITIONS_STORAGE_KEY\n    );\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(\n        TRANSITIONS_STORAGE_KEY,\n        JSON.stringify(json)\n      );\n    } catch (error) {\n      warning(\n        false,\n        `Failed to save applied view transitions in sessionStorage (${error}).`\n      );\n    }\n  }\n}\nfunction createDeferred() {\n  let resolve;\n  let reject;\n  let promise = new Promise((res, rej) => {\n    resolve = async (val) => {\n      res(val);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n    reject = async (error) => {\n      rej(error);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n  });\n  return {\n    promise,\n    //@ts-ignore\n    resolve,\n    //@ts-ignore\n    reject\n  };\n}\n\n// lib/context.ts\nimport * as React from \"react\";\nvar DataRouterContext = React.createContext(null);\nDataRouterContext.displayName = \"DataRouter\";\nvar DataRouterStateContext = React.createContext(null);\nDataRouterStateContext.displayName = \"DataRouterState\";\nvar RSCRouterContext = React.createContext(false);\nfunction useIsRSCRouterContext() {\n  return React.useContext(RSCRouterContext);\n}\nvar ViewTransitionContext = React.createContext({\n  isTransitioning: false\n});\nViewTransitionContext.displayName = \"ViewTransition\";\nvar FetchersContext = React.createContext(\n  /* @__PURE__ */ new Map()\n);\nFetchersContext.displayName = \"Fetchers\";\nvar AwaitContext = React.createContext(null);\nAwaitContext.displayName = \"Await\";\nvar NavigationContext = React.createContext(\n  null\n);\nNavigationContext.displayName = \"Navigation\";\nvar LocationContext = React.createContext(\n  null\n);\nLocationContext.displayName = \"Location\";\nvar RouteContext = React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nRouteContext.displayName = \"Route\";\nvar RouteErrorContext = React.createContext(null);\nRouteErrorContext.displayName = \"RouteError\";\nvar ENABLE_DEV_WARNINGS = true;\n\n// lib/hooks.tsx\nimport * as React2 from \"react\";\nfunction useHref(to, { relative } = {}) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n  let { basename, navigator } = React2.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to, { relative });\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\nfunction useInRouterContext() {\n  return React2.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n  return React2.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n  return React2.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n  let { pathname } = useLocation();\n  return React2.useMemo(\n    () => matchPath(pattern, decodePath(pathname)),\n    [pathname, pattern]\n  );\n}\nvar navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React2.useContext(NavigationContext).static;\n  if (!isStatic) {\n    React2.useLayoutEffect(cb);\n  }\n}\nfunction useNavigate() {\n  let { isDataRoute } = React2.useContext(RouteContext);\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n  let dataRouterContext = React2.useContext(DataRouterContext);\n  let { basename, navigator } = React2.useContext(NavigationContext);\n  let { matches } = React2.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n  let activeRef = React2.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React2.useCallback(\n    (to, options = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        options.relative === \"path\"\n      );\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n      }\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state,\n        options\n      );\n    },\n    [\n      basename,\n      navigator,\n      routePathnamesJson,\n      locationPathname,\n      dataRouterContext\n    ]\n  );\n  return navigate;\n}\nvar OutletContext = React2.createContext(null);\nfunction useOutletContext() {\n  return React2.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n  let outlet = React2.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /* @__PURE__ */ React2.createElement(OutletContext.Provider, { value: context }, outlet);\n  }\n  return outlet;\n}\nfunction useParams() {\n  let { matches } = React2.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, { relative } = {}) {\n  let { matches } = React2.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n  return React2.useMemo(\n    () => resolveTo(\n      to,\n      JSON.parse(routePathnamesJson),\n      locationPathname,\n      relative === \"path\"\n    ),\n    [to, routePathnamesJson, locationPathname, relative]\n  );\n}\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n  let { navigator } = React2.useContext(NavigationContext);\n  let { matches: parentMatches } = React2.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (ENABLE_DEV_WARNINGS) {\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\") || parentPath.endsWith(\"*?\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at \"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    invariant(\n      parentPathnameBase === \"/\" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = pathname;\n  if (parentPathnameBase !== \"/\") {\n    let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n    let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n  }\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n  if (ENABLE_DEV_WARNINGS) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n    warning(\n      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n  let renderedMatches = _renderMatches(\n    matches && matches.map(\n      (match) => Object.assign({}, match, {\n        params: Object.assign({}, parentParams, match.params),\n        pathname: joinPaths([\n          parentPathnameBase,\n          // Re-encode pathnames that were decoded inside matchRoutes\n          navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n        ]),\n        pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n          parentPathnameBase,\n          // Re-encode pathnames that were decoded inside matchRoutes\n          navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n        ])\n      })\n    ),\n    parentMatches,\n    dataRouterState,\n    future\n  );\n  if (locationArg && renderedMatches) {\n    return /* @__PURE__ */ React2.createElement(\n      LocationContext.Provider,\n      {\n        value: {\n          location: {\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\",\n            ...location\n          },\n          navigationType: \"POP\" /* Pop */\n        }\n      },\n      renderedMatches\n    );\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = { padding: \"0.5rem\", backgroundColor: lightgrey };\n  let codeStyles = { padding: \"2px 4px\", backgroundColor: lightgrey };\n  let devInfo = null;\n  if (ENABLE_DEV_WARNINGS) {\n    console.error(\n      \"Error handled by React Router default ErrorBoundary:\",\n      error\n    );\n    devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"p\", null, \"\\u{1F4BF} Hey developer \\u{1F44B}\"), /* @__PURE__ */ React2.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /* @__PURE__ */ React2.createElement(\"code\", { style: codeStyles }, \"ErrorBoundary\"), \" or\", \" \", /* @__PURE__ */ React2.createElement(\"code\", { style: codeStyles }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"h2\", null, \"Unexpected Application Error!\"), /* @__PURE__ */ React2.createElement(\"h3\", { style: { fontStyle: \"italic\" } }, message), stack ? /* @__PURE__ */ React2.createElement(\"pre\", { style: preStyles }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React2.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n    return {\n      error: props.error !== void 0 ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\n      \"React Router caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n  render() {\n    return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React2.createElement(\n      RouteErrorContext.Provider,\n      {\n        value: this.state.error,\n        children: this.props.component\n      }\n    )) : this.props.children;\n  }\n};\nfunction RenderedRoute({ routeContext, match, children }) {\n  let dataRouterContext = React2.useContext(DataRouterContext);\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: routeContext }, children);\n}\nfunction _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {\n  if (matches == null) {\n    if (!dataRouterState) {\n      return null;\n    }\n    if (dataRouterState.errors) {\n      matches = dataRouterState.matches;\n    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n  let errors = dataRouterState?.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(\n      (m) => m.route.id && errors?.[m.route.id] !== void 0\n    );\n    invariant(\n      errorIndex >= 0,\n      `Could not find a matching route for errors on route IDs: ${Object.keys(\n        errors\n      ).join(\",\")}`\n    );\n    renderedMatches = renderedMatches.slice(\n      0,\n      Math.min(renderedMatches.length, errorIndex + 1)\n    );\n  }\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.id) {\n        let { loaderData, errors: errors2 } = dataRouterState;\n        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);\n        if (match.route.lazy || needsToRunLoader) {\n          renderFallback = true;\n          if (fallbackIndex >= 0) {\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n          } else {\n            renderedMatches = [renderedMatches[0]];\n          }\n          break;\n        }\n      }\n    }\n  }\n  return renderedMatches.reduceRight(\n    (outlet, match, index) => {\n      let error;\n      let shouldRenderHydrateFallback = false;\n      let errorElement = null;\n      let hydrateFallbackElement = null;\n      if (dataRouterState) {\n        error = errors && match.route.id ? errors[match.route.id] : void 0;\n        errorElement = match.route.errorElement || defaultErrorElement;\n        if (renderFallback) {\n          if (fallbackIndex < 0 && index === 0) {\n            warningOnce(\n              \"route-fallback\",\n              false,\n              \"No `HydrateFallback` element provided to render during initial hydration\"\n            );\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = null;\n          } else if (fallbackIndex === index) {\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n          }\n        }\n      }\n      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n      let getChildren = () => {\n        let children;\n        if (error) {\n          children = errorElement;\n        } else if (shouldRenderHydrateFallback) {\n          children = hydrateFallbackElement;\n        } else if (match.route.Component) {\n          children = /* @__PURE__ */ React2.createElement(match.route.Component, null);\n        } else if (match.route.element) {\n          children = match.route.element;\n        } else {\n          children = outlet;\n        }\n        return /* @__PURE__ */ React2.createElement(\n          RenderedRoute,\n          {\n            match,\n            routeContext: {\n              outlet,\n              matches: matches2,\n              isDataRoute: dataRouterState != null\n            },\n            children\n          }\n        );\n      };\n      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(\n        RenderErrorBoundary,\n        {\n          location: dataRouterState.location,\n          revalidation: dataRouterState.revalidation,\n          component: errorElement,\n          error,\n          children: getChildren(),\n          routeContext: { outlet: null, matches: matches2, isDataRoute: true }\n        }\n      ) : getChildren();\n    },\n    null\n  );\n}\nfunction getDataRouterConsoleError(hookName) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React2.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React2.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React2.useContext(RouteContext);\n  invariant(route, getDataRouterConsoleError(hookName));\n  return route;\n}\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  invariant(\n    thisRoute.route.id,\n    `${hookName} can only be used on routes that contain a unique \"id\"`\n  );\n  return thisRoute.route.id;\n}\nfunction useRouteId() {\n  return useCurrentRouteId(\"useRouteId\" /* UseRouteId */);\n}\nfunction useNavigation() {\n  let state = useDataRouterState(\"useNavigation\" /* UseNavigation */);\n  return state.navigation;\n}\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(\"useRevalidator\" /* UseRevalidator */);\n  let state = useDataRouterState(\"useRevalidator\" /* UseRevalidator */);\n  let revalidate = React2.useCallback(async () => {\n    await dataRouterContext.router.revalidate();\n  }, [dataRouterContext.router]);\n  return React2.useMemo(\n    () => ({ revalidate, state: state.revalidation }),\n    [revalidate, state.revalidation]\n  );\n}\nfunction useMatches() {\n  let { matches, loaderData } = useDataRouterState(\n    \"useMatches\" /* UseMatches */\n  );\n  return React2.useMemo(\n    () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),\n    [matches, loaderData]\n  );\n}\nfunction useLoaderData() {\n  let state = useDataRouterState(\"useLoaderData\" /* UseLoaderData */);\n  let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */);\n  return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(\"useRouteLoaderData\" /* UseRouteLoaderData */);\n  return state.loaderData[routeId];\n}\nfunction useActionData() {\n  let state = useDataRouterState(\"useActionData\" /* UseActionData */);\n  let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */);\n  return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n  let error = React2.useContext(RouteErrorContext);\n  let state = useDataRouterState(\"useRouteError\" /* UseRouteError */);\n  let routeId = useCurrentRouteId(\"useRouteError\" /* UseRouteError */);\n  if (error !== void 0) {\n    return error;\n  }\n  return state.errors?.[routeId];\n}\nfunction useAsyncValue() {\n  let value = React2.useContext(AwaitContext);\n  return value?._data;\n}\nfunction useAsyncError() {\n  let value = React2.useContext(AwaitContext);\n  return value?._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n  let { router, basename } = useDataRouterContext(\"useBlocker\" /* UseBlocker */);\n  let state = useDataRouterState(\"useBlocker\" /* UseBlocker */);\n  let [blockerKey, setBlockerKey] = React2.useState(\"\");\n  let blockerFunction = React2.useCallback(\n    (arg) => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n      let { currentLocation, nextLocation, historyAction } = arg;\n      return shouldBlock({\n        currentLocation: {\n          ...currentLocation,\n          pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n        },\n        nextLocation: {\n          ...nextLocation,\n          pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n        },\n        historyAction\n      });\n    },\n    [basename, shouldBlock]\n  );\n  React2.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n  React2.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n  let { router } = useDataRouterContext(\"useNavigate\" /* UseNavigateStable */);\n  let id = useCurrentRouteId(\"useNavigate\" /* UseNavigateStable */);\n  let activeRef = React2.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React2.useCallback(\n    async (to, options = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        router.navigate(to);\n      } else {\n        await router.navigate(to, { fromRouteId: id, ...options });\n      }\n    },\n    [router, id]\n  );\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\n// lib/components.tsx\nimport * as React3 from \"react\";\n\n// lib/server-runtime/warnings.ts\nvar alreadyWarned2 = {};\nfunction warnOnce(condition, message) {\n  if (!condition && !alreadyWarned2[message]) {\n    alreadyWarned2[message] = true;\n    console.warn(message);\n  }\n}\n\n// lib/components.tsx\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (ENABLE_DEV_WARNINGS) {\n      if (route.element) {\n        warning(\n          false,\n          \"You should not include both `Component` and `element` on your route - `Component` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      element: React3.createElement(route.Component),\n      Component: void 0\n    });\n  }\n  if (route.HydrateFallback) {\n    if (ENABLE_DEV_WARNINGS) {\n      if (route.hydrateFallbackElement) {\n        warning(\n          false,\n          \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: React3.createElement(route.HydrateFallback),\n      HydrateFallback: void 0\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (ENABLE_DEV_WARNINGS) {\n      if (route.errorElement) {\n        warning(\n          false,\n          \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      errorElement: React3.createElement(route.ErrorBoundary),\n      ErrorBoundary: void 0\n    });\n  }\n  return updates;\n}\nvar hydrationRouteProperties = [\n  \"HydrateFallback\",\n  \"hydrateFallbackElement\"\n];\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    unstable_getContext: opts?.unstable_getContext,\n    future: opts?.future,\n    history: createMemoryHistory({\n      initialEntries: opts?.initialEntries,\n      initialIndex: opts?.initialIndex\n    }),\n    hydrationData: opts?.hydrationData,\n    routes,\n    hydrationRouteProperties,\n    mapRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation\n  }).initialize();\n}\nvar Deferred = class {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = (reason) => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n};\nfunction RouterProvider({\n  router,\n  flushSync: reactDomFlushSyncImpl\n}) {\n  let [state, setStateImpl] = React3.useState(router.state);\n  let [pendingState, setPendingState] = React3.useState();\n  let [vtContext, setVtContext] = React3.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React3.useState();\n  let [transition, setTransition] = React3.useState();\n  let [interruption, setInterruption] = React3.useState();\n  let fetcherData = React3.useRef(/* @__PURE__ */ new Map());\n  let setState = React3.useCallback(\n    (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {\n      newState.fetchers.forEach((fetcher, key) => {\n        if (fetcher.data !== void 0) {\n          fetcherData.current.set(key, fetcher.data);\n        }\n      });\n      deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n      warnOnce(\n        flushSync === false || reactDomFlushSyncImpl != null,\n        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from \"react-router/dom\"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'\n      );\n      let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === \"function\";\n      warnOnce(\n        viewTransitionOpts == null || isViewTransitionAvailable,\n        \"You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.\"\n      );\n      if (!viewTransitionOpts || !isViewTransitionAvailable) {\n        if (reactDomFlushSyncImpl && flushSync) {\n          reactDomFlushSyncImpl(() => setStateImpl(newState));\n        } else {\n          React3.startTransition(() => setStateImpl(newState));\n        }\n        return;\n      }\n      if (reactDomFlushSyncImpl && flushSync) {\n        reactDomFlushSyncImpl(() => {\n          if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n          }\n          setVtContext({\n            isTransitioning: true,\n            flushSync: true,\n            currentLocation: viewTransitionOpts.currentLocation,\n            nextLocation: viewTransitionOpts.nextLocation\n          });\n        });\n        let t = router.window.document.startViewTransition(() => {\n          reactDomFlushSyncImpl(() => setStateImpl(newState));\n        });\n        t.finished.finally(() => {\n          reactDomFlushSyncImpl(() => {\n            setRenderDfd(void 0);\n            setTransition(void 0);\n            setPendingState(void 0);\n            setVtContext({ isTransitioning: false });\n          });\n        });\n        reactDomFlushSyncImpl(() => setTransition(t));\n        return;\n      }\n      if (transition) {\n        renderDfd && renderDfd.resolve();\n        transition.skipTransition();\n        setInterruption({\n          state: newState,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      } else {\n        setPendingState(newState);\n        setVtContext({\n          isTransitioning: true,\n          flushSync: false,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      }\n    },\n    [router.window, reactDomFlushSyncImpl, transition, renderDfd]\n  );\n  React3.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  React3.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  React3.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition2 = router.window.document.startViewTransition(async () => {\n        React3.startTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition2.finished.finally(() => {\n        setRenderDfd(void 0);\n        setTransition(void 0);\n        setPendingState(void 0);\n        setVtContext({ isTransitioning: false });\n      });\n      setTransition(transition2);\n    }\n  }, [pendingState, renderDfd, router.window]);\n  React3.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  React3.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(void 0);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  let navigator = React3.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React3.useMemo(\n    () => ({\n      router,\n      navigator,\n      static: false,\n      basename\n    }),\n    [router, navigator, basename]\n  );\n  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ React3.createElement(\n    Router,\n    {\n      basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator\n    },\n    /* @__PURE__ */ React3.createElement(\n      MemoizedDataRoutes,\n      {\n        routes: router.routes,\n        future: router.future,\n        state\n      }\n    )\n  ))))), null);\n}\nvar MemoizedDataRoutes = React3.memo(DataRoutes);\nfunction DataRoutes({\n  routes,\n  future,\n  state\n}) {\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex\n}) {\n  let historyRef = React3.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React3.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React3.useCallback(\n    (newState) => {\n      React3.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React3.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React3.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction Navigate({\n  to,\n  replace: replace2,\n  state,\n  relative\n}) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n  let { static: isStatic } = React3.useContext(NavigationContext);\n  warning(\n    !isStatic,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`\n  );\n  let { matches } = React3.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let navigate = useNavigate();\n  let path = resolveTo(\n    to,\n    getResolveToMatches(matches),\n    locationPathname,\n    relative === \"path\"\n  );\n  let jsonPath = JSON.stringify(path);\n  React3.useEffect(() => {\n    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });\n  }, [navigate, jsonPath, relative, replace2, state]);\n  return null;\n}\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\nfunction Route(props) {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\nfunction Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = \"POP\" /* Pop */,\n  navigator,\n  static: staticProp = false\n}) {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`\n  );\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React3.useMemo(\n    () => ({\n      basename,\n      navigator,\n      static: staticProp,\n      future: {}\n    }),\n    [basename, navigator, staticProp]\n  );\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React3.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  warning(\n    locationContext != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL \"${pathname}${search}${hash}\" because it does not start with the basename, so the <Router> won't render anything.`\n  );\n  if (locationContext == null) {\n    return null;\n  }\n  return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children, value: locationContext }));\n}\nfunction Routes({\n  children,\n  location\n}) {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await({\n  children,\n  errorElement,\n  resolve\n}) {\n  return /* @__PURE__ */ React3.createElement(AwaitErrorBoundary, { resolve, errorElement }, /* @__PURE__ */ React3.createElement(ResolveAwait, null, children));\n}\nvar AwaitErrorBoundary = class extends React3.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\n      \"<Await> caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n  render() {\n    let { children, errorElement, resolve } = this.props;\n    let promise = null;\n    let status = 0 /* pending */;\n    if (!(resolve instanceof Promise)) {\n      status = 1 /* success */;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_data\", { get: () => resolve });\n    } else if (this.state.error) {\n      status = 2 /* error */;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {\n      });\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_error\", { get: () => renderError });\n    } else if (resolve._tracked) {\n      promise = resolve;\n      status = \"_error\" in promise ? 2 /* error */ : \"_data\" in promise ? 1 /* success */ : 0 /* pending */;\n    } else {\n      status = 0 /* pending */;\n      Object.defineProperty(resolve, \"_tracked\", { get: () => true });\n      promise = resolve.then(\n        (data2) => Object.defineProperty(resolve, \"_data\", { get: () => data2 }),\n        (error) => Object.defineProperty(resolve, \"_error\", { get: () => error })\n      );\n    }\n    if (status === 2 /* error */ && !errorElement) {\n      throw promise._error;\n    }\n    if (status === 2 /* error */) {\n      return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children: errorElement });\n    }\n    if (status === 1 /* success */) {\n      return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children });\n    }\n    throw promise;\n  }\n};\nfunction ResolveAwait({\n  children\n}) {\n  let data2 = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data2) : children;\n  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath = []) {\n  let routes = [];\n  React3.Children.forEach(children, (element, index) => {\n    if (!React3.isValidElement(element)) {\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React3.Fragment) {\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children, treePath)\n      );\n      return;\n    }\n    invariant(\n      element.type === Route,\n      `[${typeof element.type === \"string\" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n    invariant(\n      !element.props.index || !element.props.children,\n      \"An index route cannot have child routes.\"\n    );\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      hydrateFallbackElement: element.props.hydrateFallbackElement,\n      HydrateFallback: element.props.HydrateFallback,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(\n        element.props.children,\n        treePath\n      );\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nvar createRoutesFromElements = createRoutesFromChildren;\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction useRouteComponentProps() {\n  return {\n    params: useParams(),\n    loaderData: useLoaderData(),\n    actionData: useActionData(),\n    matches: useMatches()\n  };\n}\nfunction WithComponentProps({\n  children\n}) {\n  const props = useRouteComponentProps();\n  return React3.cloneElement(children, props);\n}\nfunction withComponentProps(Component4) {\n  return function WithComponentProps2() {\n    const props = useRouteComponentProps();\n    return React3.createElement(Component4, props);\n  };\n}\nfunction useHydrateFallbackProps() {\n  return {\n    params: useParams(),\n    loaderData: useLoaderData(),\n    actionData: useActionData()\n  };\n}\nfunction WithHydrateFallbackProps({\n  children\n}) {\n  const props = useHydrateFallbackProps();\n  return React3.cloneElement(children, props);\n}\nfunction withHydrateFallbackProps(HydrateFallback) {\n  return function WithHydrateFallbackProps2() {\n    const props = useHydrateFallbackProps();\n    return React3.createElement(HydrateFallback, props);\n  };\n}\nfunction useErrorBoundaryProps() {\n  return {\n    params: useParams(),\n    loaderData: useLoaderData(),\n    actionData: useActionData(),\n    error: useRouteError()\n  };\n}\nfunction WithErrorBoundaryProps({\n  children\n}) {\n  const props = useErrorBoundaryProps();\n  return React3.cloneElement(children, props);\n}\nfunction withErrorBoundaryProps(ErrorBoundary) {\n  return function WithErrorBoundaryProps2() {\n    const props = useErrorBoundaryProps();\n    return React3.createElement(ErrorBoundary, props);\n  };\n}\n\n// lib/dom/dom.ts\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && // Ignore everything but left clicks\n  (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event);\n}\nfunction createSearchParams(init = \"\") {\n  return new URLSearchParams(\n    typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {\n      let value = init[key];\n      return memo2.concat(\n        Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n      );\n    }, [])\n  );\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    warning(\n      false,\n      `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` and will default to \"${defaultEncType}\"`\n    );\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\n        `Cannot submit a <button> or <input type=\"submit\"> without a <form>`\n      );\n    }\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(form, target);\n    if (!isFormDataSubmitterSupported()) {\n      let { name, type, value } = target;\n      if (type === \"image\") {\n        let prefix = name ? `${name}.` : \"\";\n        formData.append(`${prefix}x`, \"0\");\n        formData.append(`${prefix}y`, \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\n      `Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`\n    );\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = void 0;\n  }\n  return { action, method: method.toLowerCase(), encType, formData, body };\n}\n\n// lib/dom/ssr/single-fetch.tsx\nimport * as React4 from \"react\";\n\n// vendor/turbo-stream-v2/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred2 = class {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n};\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, { stream: true });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n  });\n}\n\n// vendor/turbo-stream-v2/flatten.ts\nfunction flatten(input) {\n  const { indices } = this;\n  const existing = indices.get(input);\n  if (existing) return [existing];\n  if (input === void 0) return UNDEFINED;\n  if (input === null) return NULL;\n  if (Number.isNaN(input)) return NAN;\n  if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\nfunction stringify(input, index) {\n  const { deferred, plugins, postPlugins } = this;\n  const str = this.stringified;\n  const stack = [[input, index]];\n  while (stack.length > 0) {\n    const [input2, index2] = stack.pop();\n    const partsForObj = (obj) => Object.keys(obj).map((k) => `\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n    let error = null;\n    switch (typeof input2) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        str[index2] = JSON.stringify(input2);\n        break;\n      case \"bigint\":\n        str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n        break;\n      case \"symbol\": {\n        const keyFor = Symbol.keyFor(input2);\n        if (!keyFor) {\n          error = new Error(\n            \"Cannot encode symbol unless created with Symbol.for()\"\n          );\n        } else {\n          str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n        }\n        break;\n      }\n      case \"object\": {\n        if (!input2) {\n          str[index2] = `${NULL}`;\n          break;\n        }\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          let result = isArray ? \"[\" : \"{\";\n          if (isArray) {\n            for (let i = 0; i < input2.length; i++)\n              result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n            str[index2] = `${result}]`;\n          } else if (input2 instanceof Date) {\n            const dateTime = input2.getTime();\n            str[index2] = `[\"${TYPE_DATE}\",${Number.isNaN(dateTime) ? JSON.stringify(\"invalid\") : dateTime}]`;\n          } else if (input2 instanceof URL) {\n            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n          } else if (input2 instanceof RegExp) {\n            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(\n              input2.source\n            )},${JSON.stringify(input2.flags)}]`;\n          } else if (input2 instanceof Set) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_SET}\",${[...input2].map((val) => flatten.call(this, val)).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_SET}\"]`;\n            }\n          } else if (input2 instanceof Map) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_MAP}\",${[...input2].flatMap(([k, v]) => [\n                flatten.call(this, k),\n                flatten.call(this, v)\n              ]).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_MAP}\"]`;\n            }\n          } else if (input2 instanceof Promise) {\n            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n            deferred[index2] = input2;\n          } else if (input2 instanceof Error) {\n            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n            if (input2.name !== \"Error\") {\n              str[index2] += `,${JSON.stringify(input2.name)}`;\n            }\n            str[index2] += \"]\";\n          } else if (Object.getPrototypeOf(input2) === null) {\n            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n          } else if (isPlainObject(input2)) {\n            str[index2] = `{${partsForObj(input2)}}`;\n          } else {\n            error = new Error(\"Cannot encode object with prototype\");\n          }\n        }\n        break;\n      }\n      default: {\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          error = new Error(\"Cannot encode function or unexpected type\");\n        }\n      }\n    }\n    if (error) {\n      let pluginHandled = false;\n      if (postPlugins) {\n        for (const plugin of postPlugins) {\n          const pluginResult = plugin(input2);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index2] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        throw error;\n      }\n    }\n  }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n}\n\n// vendor/turbo-stream-v2/unflatten.ts\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n  const { hydrated, values } = this;\n  if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n  const startIndex = values.length;\n  for (const value of parsed) {\n    values.push(value);\n  }\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n  const { hydrated, values, deferred, plugins } = this;\n  let result;\n  const stack = [\n    [\n      index,\n      (v) => {\n        result = v;\n      }\n    ]\n  ];\n  let postRun = [];\n  while (stack.length > 0) {\n    const [index2, set] = stack.pop();\n    switch (index2) {\n      case UNDEFINED:\n        set(void 0);\n        continue;\n      case NULL:\n        set(null);\n        continue;\n      case NAN:\n        set(NaN);\n        continue;\n      case POSITIVE_INFINITY:\n        set(Infinity);\n        continue;\n      case NEGATIVE_INFINITY:\n        set(-Infinity);\n        continue;\n      case NEGATIVE_ZERO:\n        set(-0);\n        continue;\n    }\n    if (hydrated[index2]) {\n      set(hydrated[index2]);\n      continue;\n    }\n    const value = values[index2];\n    if (!value || typeof value !== \"object\") {\n      hydrated[index2] = value;\n      set(value);\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (typeof value[0] === \"string\") {\n        const [type, b, c] = value;\n        switch (type) {\n          case TYPE_DATE:\n            set(hydrated[index2] = new Date(b));\n            continue;\n          case TYPE_URL:\n            set(hydrated[index2] = new URL(b));\n            continue;\n          case TYPE_BIGINT:\n            set(hydrated[index2] = BigInt(b));\n            continue;\n          case TYPE_REGEXP:\n            set(hydrated[index2] = new RegExp(b, c));\n            continue;\n          case TYPE_SYMBOL:\n            set(hydrated[index2] = Symbol.for(b));\n            continue;\n          case TYPE_SET:\n            const newSet = /* @__PURE__ */ new Set();\n            hydrated[index2] = newSet;\n            for (let i = value.length - 1; i > 0; i--)\n              stack.push([\n                value[i],\n                (v) => {\n                  newSet.add(v);\n                }\n              ]);\n            set(newSet);\n            continue;\n          case TYPE_MAP:\n            const map = /* @__PURE__ */ new Map();\n            hydrated[index2] = map;\n            for (let i = value.length - 2; i > 0; i -= 2) {\n              const r = [];\n              stack.push([\n                value[i + 1],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                value[i],\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                map.set(r[0], r[1]);\n              });\n            }\n            set(map);\n            continue;\n          case TYPE_NULL_OBJECT:\n            const obj = /* @__PURE__ */ Object.create(null);\n            hydrated[index2] = obj;\n            for (const key of Object.keys(b).reverse()) {\n              const r = [];\n              stack.push([\n                b[key],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                Number(key.slice(1)),\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                obj[r[0]] = r[1];\n              });\n            }\n            set(obj);\n            continue;\n          case TYPE_PROMISE:\n            if (hydrated[b]) {\n              set(hydrated[index2] = hydrated[b]);\n            } else {\n              const d = new Deferred2();\n              deferred[b] = d;\n              set(hydrated[index2] = d.promise);\n            }\n            continue;\n          case TYPE_ERROR:\n            const [, message, errorType] = value;\n            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n            hydrated[index2] = error;\n            set(error);\n            continue;\n          case TYPE_PREVIOUS_RESOLVED:\n            set(hydrated[index2] = hydrated[b]);\n            continue;\n          default:\n            if (Array.isArray(plugins)) {\n              const r = [];\n              const vals = value.slice(1);\n              for (let i = 0; i < vals.length; i++) {\n                const v = vals[i];\n                stack.push([\n                  v,\n                  (v2) => {\n                    r[i] = v2;\n                  }\n                ]);\n              }\n              postRun.push(() => {\n                for (const plugin of plugins) {\n                  const result2 = plugin(value[0], ...r);\n                  if (result2) {\n                    set(hydrated[index2] = result2.value);\n                    return;\n                  }\n                }\n                throw new SyntaxError();\n              });\n              continue;\n            }\n            throw new SyntaxError();\n        }\n      } else {\n        const array = [];\n        hydrated[index2] = array;\n        for (let i = 0; i < value.length; i++) {\n          const n = value[i];\n          if (n !== HOLE) {\n            stack.push([\n              n,\n              (v) => {\n                array[i] = v;\n              }\n            ]);\n          }\n        }\n        set(array);\n        continue;\n      }\n    } else {\n      const object = {};\n      hydrated[index2] = object;\n      for (const key of Object.keys(value).reverse()) {\n        const r = [];\n        stack.push([\n          value[key],\n          (v) => {\n            r[1] = v;\n          }\n        ]);\n        stack.push([\n          Number(key.slice(1)),\n          (k) => {\n            r[0] = k;\n          }\n        ]);\n        postRun.push(() => {\n          object[r[0]] = r[1];\n        });\n      }\n      set(object);\n      continue;\n    }\n  }\n  while (postRun.length > 0) {\n    postRun.pop()();\n  }\n  return result;\n}\n\n// vendor/turbo-stream-v2/turbo-stream.ts\nasync function decode(readable, options) {\n  const { plugins } = options ?? {};\n  const done = new Deferred2();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n      done.reject(reason);\n    });\n  }\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n  let line;\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n  while (!read.done) {\n    if (!read.value) continue;\n    const line = read.value;\n    switch (line[0]) {\n      case TYPE_PROMISE: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.resolve(value);\n        break;\n      }\n      case TYPE_ERROR: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.reject(value);\n        break;\n      }\n      default:\n        throw new SyntaxError();\n    }\n    read = await reader.read();\n  }\n}\nfunction encode(input, options) {\n  const { plugins, postPlugins, signal } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */ new Map(),\n    stringified: [],\n    plugins,\n    postPlugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(\n          textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`)\n        );\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n      const seenPromises = /* @__PURE__ */ new WeakSet();\n      if (Object.keys(encoder.deferred).length) {\n        let raceDone;\n        const racePromise = new Promise((resolve, reject) => {\n          raceDone = resolve;\n          if (signal) {\n            const rejectPromise = () => reject(signal.reason || new Error(\"Signal was aborted.\"));\n            if (signal.aborted) {\n              rejectPromise();\n            } else {\n              signal.addEventListener(\"abort\", (event) => {\n                rejectPromise();\n              });\n            }\n          }\n        });\n        while (Object.keys(encoder.deferred).length > 0) {\n          for (const [deferredId, deferred] of Object.entries(\n            encoder.deferred\n          )) {\n            if (seenPromises.has(deferred)) continue;\n            seenPromises.add(\n              // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n              encoder.deferred[Number(deferredId)] = Promise.race([\n                racePromise,\n                deferred\n              ]).then(\n                (resolved) => {\n                  const id2 = flatten.call(encoder, resolved);\n                  if (Array.isArray(id2)) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                      )\n                    );\n                    encoder.index++;\n                    lastSentIndex++;\n                  } else if (id2 < 0) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_PROMISE}${deferredId}:${id2}\n`\n                      )\n                    );\n                  } else {\n                    const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_PROMISE}${deferredId}:[${values}]\n`\n                      )\n                    );\n                    lastSentIndex = encoder.stringified.length - 1;\n                  }\n                },\n                (reason) => {\n                  if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                    reason = new Error(\"An unknown error occurred\");\n                  }\n                  const id2 = flatten.call(encoder, reason);\n                  if (Array.isArray(id2)) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                      )\n                    );\n                    encoder.index++;\n                    lastSentIndex++;\n                  } else if (id2 < 0) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_ERROR}${deferredId}:${id2}\n`\n                      )\n                    );\n                  } else {\n                    const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_ERROR}${deferredId}:[${values}]\n`\n                      )\n                    );\n                    lastSentIndex = encoder.stringified.length - 1;\n                  }\n                }\n              ).finally(() => {\n                delete encoder.deferred[Number(deferredId)];\n              })\n            );\n          }\n          await Promise.race(Object.values(encoder.deferred));\n        }\n        raceDone();\n      }\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n  });\n  return readable;\n}\n\n// lib/dom/ssr/data.ts\nasync function createRequestInit(request) {\n  let init = { signal: request.signal };\n  if (request.method !== \"GET\") {\n    init.method = request.method;\n    let contentType = request.headers.get(\"Content-Type\");\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      init.headers = { \"Content-Type\": contentType };\n      init.body = JSON.stringify(await request.json());\n    } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n      init.headers = { \"Content-Type\": contentType };\n      init.body = await request.text();\n    } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n      init.body = new URLSearchParams(await request.text());\n    } else {\n      init.body = await request.formData();\n    }\n  }\n  return init;\n}\n\n// lib/dom/ssr/markup.ts\nvar ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n  return { __html: html };\n}\n\n// lib/dom/ssr/invariant.ts\nfunction invariant2(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\n// lib/dom/ssr/single-fetch.tsx\nvar SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nvar SingleFetchNoResultError = class extends Error {\n};\nvar SINGLE_FETCH_REDIRECT_STATUS = 202;\nvar NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);\nfunction StreamTransfer({\n  context,\n  identifier,\n  reader,\n  textDecoder,\n  nonce\n}) {\n  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n    return null;\n  }\n  if (!context.renderMeta.streamCache) {\n    context.renderMeta.streamCache = {};\n  }\n  let { streamCache } = context.renderMeta;\n  let promise = streamCache[identifier];\n  if (!promise) {\n    promise = streamCache[identifier] = reader.read().then((result) => {\n      streamCache[identifier].result = {\n        done: result.done,\n        value: textDecoder.decode(result.value, { stream: true })\n      };\n    }).catch((e) => {\n      streamCache[identifier].error = e;\n    });\n  }\n  if (promise.error) {\n    throw promise.error;\n  }\n  if (promise.result === void 0) {\n    throw promise;\n  }\n  let { done, value } = promise.result;\n  let scriptTag = value ? /* @__PURE__ */ React4.createElement(\n    \"script\",\n    {\n      nonce,\n      dangerouslySetInnerHTML: {\n        __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(\n          JSON.stringify(value)\n        )});`\n      }\n    }\n  ) : null;\n  if (done) {\n    return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(\n      \"script\",\n      {\n        nonce,\n        dangerouslySetInnerHTML: {\n          __html: `window.__reactRouterContext.streamController.close();`\n        }\n      }\n    ));\n  } else {\n    return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(React4.Suspense, null, /* @__PURE__ */ React4.createElement(\n      StreamTransfer,\n      {\n        context,\n        identifier: identifier + 1,\n        reader,\n        textDecoder,\n        nonce\n      }\n    )));\n  }\n}\nfunction getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(\n    getRouter,\n    (match) => {\n      let manifestRoute = manifest.routes[match.route.id];\n      invariant2(manifestRoute, \"Route not found in manifest\");\n      let routeModule = routeModules[match.route.id];\n      return {\n        hasLoader: manifestRoute.hasLoader,\n        hasClientLoader: manifestRoute.hasClientLoader,\n        hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)\n      };\n    },\n    fetchAndDecodeViaTurboStream,\n    ssr,\n    basename\n  );\n  return async (args) => args.unstable_runClientMiddleware(dataStrategy);\n}\nfunction getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename, shouldAllowOptOut = () => true) {\n  return async (args) => {\n    let { request, matches, fetcherKey } = args;\n    let router = getRouter();\n    if (request.method !== \"GET\") {\n      return singleFetchActionStrategy(args, fetchAndDecode, basename);\n    }\n    let foundRevalidatingServerLoader = matches.some((m) => {\n      let { hasLoader, hasClientLoader } = getRouteInfo(m);\n      return m.unstable_shouldCallHandler() && hasLoader && !hasClientLoader;\n    });\n    if (!ssr && !foundRevalidatingServerLoader) {\n      return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);\n    }\n    if (fetcherKey) {\n      return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);\n    }\n    return singleFetchLoaderNavigationStrategy(\n      args,\n      router,\n      getRouteInfo,\n      fetchAndDecode,\n      ssr,\n      basename,\n      shouldAllowOptOut\n    );\n  };\n}\nasync function singleFetchActionStrategy(args, fetchAndDecode, basename) {\n  let actionMatch = args.matches.find((m) => m.unstable_shouldCallHandler());\n  invariant2(actionMatch, \"No action match found\");\n  let actionStatus = void 0;\n  let result = await actionMatch.resolve(async (handler) => {\n    let result2 = await handler(async () => {\n      let { data: data2, status } = await fetchAndDecode(args, basename, [\n        actionMatch.route.id\n      ]);\n      actionStatus = status;\n      return unwrapSingleFetchResult(data2, actionMatch.route.id);\n    });\n    return result2;\n  });\n  if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {\n    return { [actionMatch.route.id]: result };\n  }\n  return {\n    [actionMatch.route.id]: {\n      type: result.type,\n      result: data(result.result, actionStatus)\n    }\n  };\n}\nasync function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {\n  let matchesToLoad = args.matches.filter(\n    (m) => m.unstable_shouldCallHandler()\n  );\n  let results = {};\n  await Promise.all(\n    matchesToLoad.map(\n      (m) => m.resolve(async (handler) => {\n        try {\n          let { hasClientLoader } = getRouteInfo(m);\n          let routeId = m.route.id;\n          let result = hasClientLoader ? await handler(async () => {\n            let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);\n            return unwrapSingleFetchResult(data2, routeId);\n          }) : await handler();\n          results[m.route.id] = { type: \"data\", result };\n        } catch (e) {\n          results[m.route.id] = { type: \"error\", result: e };\n        }\n      })\n    )\n  );\n  return results;\n}\nasync function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename, shouldAllowOptOut = () => true) {\n  let routesParams = /* @__PURE__ */ new Set();\n  let foundOptOutRoute = false;\n  let routeDfds = args.matches.map(() => createDeferred2());\n  let singleFetchDfd = createDeferred2();\n  let results = {};\n  let resolvePromise = Promise.all(\n    args.matches.map(\n      async (m, i) => m.resolve(async (handler) => {\n        routeDfds[i].resolve();\n        let routeId = m.route.id;\n        let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);\n        let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus < 400;\n        let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);\n        if (!shouldCall) {\n          foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null && // This is a revalidation,\n          hasLoader && // for a route with a server loader,\n          hasShouldRevalidate === true);\n          return;\n        }\n        if (shouldAllowOptOut(m) && hasClientLoader) {\n          if (hasLoader) {\n            foundOptOutRoute = true;\n          }\n          try {\n            let result = await handler(async () => {\n              let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);\n              return unwrapSingleFetchResult(data2, routeId);\n            });\n            results[routeId] = { type: \"data\", result };\n          } catch (e) {\n            results[routeId] = { type: \"error\", result: e };\n          }\n          return;\n        }\n        if (hasLoader) {\n          routesParams.add(routeId);\n        }\n        try {\n          let result = await handler(async () => {\n            let data2 = await singleFetchDfd.promise;\n            return unwrapSingleFetchResult(data2, routeId);\n          });\n          results[routeId] = { type: \"data\", result };\n        } catch (e) {\n          results[routeId] = { type: \"error\", result: e };\n        }\n      })\n    )\n  );\n  await Promise.all(routeDfds.map((d) => d.promise));\n  let isInitialLoad = !router.state.initialized && router.state.navigation.state === \"idle\";\n  if ((isInitialLoad || routesParams.size === 0) && !window.__reactRouterHdrActive) {\n    singleFetchDfd.resolve({ routes: {} });\n  } else {\n    let targetRoutes = ssr && foundOptOutRoute && routesParams.size > 0 ? [...routesParams.keys()] : void 0;\n    try {\n      let data2 = await fetchAndDecode(args, basename, targetRoutes);\n      singleFetchDfd.resolve(data2.data);\n    } catch (e) {\n      singleFetchDfd.reject(e);\n    }\n  }\n  await resolvePromise;\n  await bubbleMiddlewareErrors(\n    singleFetchDfd.promise,\n    args.matches,\n    routesParams,\n    results\n  );\n  return results;\n}\nasync function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {\n  try {\n    let middlewareError;\n    let fetchedData = await singleFetchPromise;\n    if (\"routes\" in fetchedData) {\n      for (let match of matches) {\n        if (match.route.id in fetchedData.routes) {\n          let routeResult = fetchedData.routes[match.route.id];\n          if (\"error\" in routeResult) {\n            middlewareError = routeResult.error;\n            break;\n          }\n        }\n      }\n    }\n    if (middlewareError !== void 0) {\n      Array.from(routesParams.values()).forEach((routeId) => {\n        if (results[routeId].result instanceof SingleFetchNoResultError) {\n          results[routeId].result = middlewareError;\n        }\n      });\n    }\n  } catch (e) {\n  }\n}\nasync function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {\n  let fetcherMatch = args.matches.find((m) => m.unstable_shouldCallHandler());\n  invariant2(fetcherMatch, \"No fetcher match found\");\n  let routeId = fetcherMatch.route.id;\n  let result = await fetcherMatch.resolve(\n    async (handler) => handler(async () => {\n      let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);\n      return unwrapSingleFetchResult(data2, routeId);\n    })\n  );\n  return { [fetcherMatch.route.id]: result };\n}\nfunction stripIndexParam(url) {\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  return url;\n}\nfunction singleFetchUrl(reqUrl, basename, extension) {\n  let url = typeof reqUrl === \"string\" ? new URL(\n    reqUrl,\n    // This can be called during the SSR flow via PrefetchPageLinksImpl so\n    // don't assume window is available\n    typeof window === \"undefined\" ? \"server://singlefetch/\" : window.location.origin\n  ) : reqUrl;\n  if (url.pathname === \"/\") {\n    url.pathname = `_root.${extension}`;\n  } else if (basename && stripBasename(url.pathname, basename) === \"/\") {\n    url.pathname = `${basename.replace(/\\/$/, \"\")}/_root.${extension}`;\n  } else {\n    url.pathname = `${url.pathname.replace(/\\/$/, \"\")}.${extension}`;\n  }\n  return url;\n}\nasync function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {\n  let { request } = args;\n  let url = singleFetchUrl(request.url, basename, \"data\");\n  if (request.method === \"GET\") {\n    url = stripIndexParam(url);\n    if (targetRoutes) {\n      url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n    }\n  }\n  let res = await fetch(url, await createRequestInit(request));\n  if (res.status === 404 && !res.headers.has(\"X-Remix-Response\")) {\n    throw new ErrorResponseImpl(404, \"Not Found\", true);\n  }\n  if (res.status === 204 && res.headers.has(\"X-Remix-Redirect\")) {\n    return {\n      status: SINGLE_FETCH_REDIRECT_STATUS,\n      data: {\n        redirect: {\n          redirect: res.headers.get(\"X-Remix-Redirect\"),\n          status: Number(res.headers.get(\"X-Remix-Status\") || \"302\"),\n          revalidate: res.headers.get(\"X-Remix-Revalidate\") === \"true\",\n          reload: res.headers.get(\"X-Remix-Reload-Document\") === \"true\",\n          replace: res.headers.get(\"X-Remix-Replace\") === \"true\"\n        }\n      }\n    };\n  }\n  if (NO_BODY_STATUS_CODES.has(res.status)) {\n    let routes = {};\n    if (targetRoutes && request.method !== \"GET\") {\n      routes[targetRoutes[0]] = { data: void 0 };\n    }\n    return {\n      status: res.status,\n      data: { routes }\n    };\n  }\n  invariant2(res.body, \"No response body to decode\");\n  try {\n    let decoded = await decodeViaTurboStream(res.body, window);\n    let data2;\n    if (request.method === \"GET\") {\n      let typed = decoded.value;\n      if (SingleFetchRedirectSymbol in typed) {\n        data2 = { redirect: typed[SingleFetchRedirectSymbol] };\n      } else {\n        data2 = { routes: typed };\n      }\n    } else {\n      let typed = decoded.value;\n      let routeId = targetRoutes?.[0];\n      invariant2(routeId, \"No routeId found for single fetch call decoding\");\n      if (\"redirect\" in typed) {\n        data2 = { redirect: typed };\n      } else {\n        data2 = { routes: { [routeId]: typed } };\n      }\n    }\n    return { status: res.status, data: data2 };\n  } catch (e) {\n    throw new Error(\"Unable to decode turbo-stream response\");\n  }\n}\nfunction decodeViaTurboStream(body, global) {\n  return decode(body, {\n    plugins: [\n      (type, ...rest) => {\n        if (type === \"SanitizedError\") {\n          let [name, message, stack] = rest;\n          let Constructor = Error;\n          if (name && name in global && typeof global[name] === \"function\") {\n            Constructor = global[name];\n          }\n          let error = new Constructor(message);\n          error.stack = stack;\n          return { value: error };\n        }\n        if (type === \"ErrorResponse\") {\n          let [data2, status, statusText] = rest;\n          return {\n            value: new ErrorResponseImpl(status, statusText, data2)\n          };\n        }\n        if (type === \"SingleFetchRedirect\") {\n          return { value: { [SingleFetchRedirectSymbol]: rest[0] } };\n        }\n        if (type === \"SingleFetchClassInstance\") {\n          return { value: rest[0] };\n        }\n        if (type === \"SingleFetchFallback\") {\n          return { value: void 0 };\n        }\n      }\n    ]\n  });\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n  if (\"redirect\" in result) {\n    let {\n      redirect: location,\n      revalidate,\n      reload,\n      replace: replace2,\n      status\n    } = result.redirect;\n    throw redirect(location, {\n      status,\n      headers: {\n        // Three R's of redirecting (lol Veep)\n        ...revalidate ? { \"X-Remix-Revalidate\": \"yes\" } : null,\n        ...reload ? { \"X-Remix-Reload-Document\": \"yes\" } : null,\n        ...replace2 ? { \"X-Remix-Replace\": \"yes\" } : null\n      }\n    });\n  }\n  let routeResult = result.routes[routeId];\n  if (routeResult == null) {\n    throw new SingleFetchNoResultError(\n      `No result found for routeId \"${routeId}\"`\n    );\n  } else if (\"error\" in routeResult) {\n    throw routeResult.error;\n  } else if (\"data\" in routeResult) {\n    return routeResult.data;\n  } else {\n    throw new Error(`Invalid response found for routeId \"${routeId}\"`);\n  }\n}\nfunction createDeferred2() {\n  let resolve;\n  let reject;\n  let promise = new Promise((res, rej) => {\n    resolve = async (val) => {\n      res(val);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n    reject = async (error) => {\n      rej(error);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n  });\n  return {\n    promise,\n    //@ts-ignore\n    resolve,\n    //@ts-ignore\n    reject\n  };\n}\n\n// lib/dom/ssr/errorBoundaries.tsx\nimport * as React9 from \"react\";\n\n// lib/dom/ssr/components.tsx\nimport * as React8 from \"react\";\n\n// lib/dom/ssr/routeModules.ts\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n  try {\n    let routeModule = await import(\n      /* @vite-ignore */\n      /* webpackIgnore: true */\n      route.module\n    );\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    console.error(\n      `Error loading route module \\`${route.module}\\`, reloading page...`\n    );\n    console.error(error);\n    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error\n    import.meta.hot) {\n      throw error;\n    }\n    window.location.reload();\n    return new Promise(() => {\n    });\n  }\n}\n\n// lib/dom/ssr/links.ts\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map((match) => {\n    let module = routeModules[match.route.id];\n    let route = manifest.routes[match.route.id];\n    return [\n      route && route.css ? route.css.map((href) => ({ rel: \"stylesheet\", href })) : [],\n      module?.links?.() || []\n    ];\n  }).flat(2);\n  let preloads = getModuleLinkHrefs(matches, manifest);\n  return dedupeLinkDescriptors(descriptors, preloads);\n}\nfunction getRouteCssDescriptors(route) {\n  if (!route.css) return [];\n  return route.css.map((href) => ({ rel: \"stylesheet\", href }));\n}\nasync function prefetchRouteCss(route) {\n  if (!route.css) return;\n  let descriptors = getRouteCssDescriptors(route);\n  await Promise.all(descriptors.map(prefetchStyleLink));\n}\nasync function prefetchStyleLinks(route, routeModule) {\n  if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n  let descriptors = [];\n  if (route.css) {\n    descriptors.push(...getRouteCssDescriptors(route));\n  }\n  if (routeModule.links) {\n    descriptors.push(...routeModule.links());\n  }\n  if (descriptors.length === 0) return;\n  let styleLinks = [];\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({\n        ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  }\n  await Promise.all(styleLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n  return new Promise((resolve) => {\n    if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(\n      `link[rel=\"stylesheet\"][href=\"${descriptor.href}\"]`\n    )) {\n      return resolve();\n    }\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n    function removeLink() {\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n    document.head.appendChild(link);\n  });\n}\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  if (object == null) {\n    return false;\n  }\n  if (object.href == null) {\n    return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n  }\n  return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n  let links = await Promise.all(\n    matches.map(async (match) => {\n      let route = manifest.routes[match.route.id];\n      if (route) {\n        let mod = await loadRouteModule(route, routeModules);\n        return mod.links ? mod.links() : [];\n      }\n      return [];\n    })\n  );\n  return dedupeLinkDescriptors(\n    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === \"stylesheet\" || link.rel === \"preload\").map(\n      (link) => link.rel === \"stylesheet\" ? { ...link, rel: \"prefetch\", as: \"style\" } : { ...link, rel: \"prefetch\" }\n    )\n  );\n}\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n  let matchPathChanged = (match, index) => {\n    return (\n      // param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      currentMatches[index].route.path?.endsWith(\"*\") && currentMatches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  };\n  if (mode === \"assets\") {\n    return nextMatches.filter(\n      (match, index) => isNew(match, index) || matchPathChanged(match, index)\n    );\n  }\n  if (mode === \"data\") {\n    return nextMatches.filter((match, index) => {\n      let manifestRoute = manifest.routes[match.route.id];\n      if (!manifestRoute || !manifestRoute.hasLoader) {\n        return false;\n      }\n      if (isNew(match, index) || matchPathChanged(match, index)) {\n        return true;\n      }\n      if (match.route.shouldRevalidate) {\n        let routeChoice = match.route.shouldRevalidate({\n          currentUrl: new URL(\n            location.pathname + location.search + location.hash,\n            window.origin\n          ),\n          currentParams: currentMatches[0]?.params || {},\n          nextUrl: new URL(page, window.origin),\n          nextParams: match.params,\n          defaultShouldRevalidate: true\n        });\n        if (typeof routeChoice === \"boolean\") {\n          return routeChoice;\n        }\n      }\n      return true;\n    });\n  }\n  return [];\n}\nfunction getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {\n  return dedupeHrefs(\n    matches.map((match) => {\n      let route = manifest.routes[match.route.id];\n      if (!route) return [];\n      let hrefs = [route.module];\n      if (route.clientActionModule) {\n        hrefs = hrefs.concat(route.clientActionModule);\n      }\n      if (route.clientLoaderModule) {\n        hrefs = hrefs.concat(route.clientLoaderModule);\n      }\n      if (includeHydrateFallback && route.hydrateFallbackModule) {\n        hrefs = hrefs.concat(route.hydrateFallbackModule);\n      }\n      if (route.imports) {\n        hrefs = hrefs.concat(route.imports);\n      }\n      return hrefs;\n    }).flat(1)\n  );\n}\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\nfunction sortKeys(obj) {\n  let sorted = {};\n  let keys = Object.keys(obj).sort();\n  for (let key of keys) {\n    sorted[key] = obj[key];\n  }\n  return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n  let set = /* @__PURE__ */ new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n    let key = JSON.stringify(sortKeys(descriptor));\n    if (!set.has(key)) {\n      set.add(key);\n      deduped.push({ key, link: descriptor });\n    }\n    return deduped;\n  }, []);\n}\nvar _isPreloadSupported;\nfunction isPreloadSupported() {\n  if (_isPreloadSupported !== void 0) {\n    return _isPreloadSupported;\n  }\n  let el = document.createElement(\"link\");\n  _isPreloadSupported = el.relList.supports(\"preload\");\n  el = null;\n  return _isPreloadSupported;\n}\n\n// lib/dom/ssr/fog-of-war.ts\nimport * as React7 from \"react\";\n\n// lib/dom/ssr/routes.tsx\nimport * as React6 from \"react\";\n\n// lib/dom/ssr/fallback.tsx\nimport * as React5 from \"react\";\nfunction RemixRootDefaultHydrateFallback() {\n  return /* @__PURE__ */ React5.createElement(BoundaryShell, { title: \"Loading...\", renderScripts: true }, ENABLE_DEV_WARNINGS ? /* @__PURE__ */ React5.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n              console.log(\n                \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this \" +\n                \"when your app is loading JS modules and/or running \\`clientLoader\\` \" +\n                \"functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback \" +\n                \"for more information.\"\n              );\n            `\n      }\n    }\n  ) : null);\n}\n\n// lib/dom/ssr/routes.tsx\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n  let Component4 = getRouteModuleComponent(routeModule);\n  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : void 0;\n  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? () => /* @__PURE__ */ React6.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;\n  if (route.id === \"root\" && routeModule.Layout) {\n    return {\n      ...Component4 ? {\n        element: /* @__PURE__ */ React6.createElement(routeModule.Layout, null, /* @__PURE__ */ React6.createElement(Component4, null))\n      } : { Component: Component4 },\n      ...ErrorBoundary ? {\n        errorElement: /* @__PURE__ */ React6.createElement(routeModule.Layout, null, /* @__PURE__ */ React6.createElement(ErrorBoundary, null))\n      } : { ErrorBoundary },\n      ...HydrateFallback ? {\n        hydrateFallbackElement: /* @__PURE__ */ React6.createElement(routeModule.Layout, null, /* @__PURE__ */ React6.createElement(HydrateFallback, null))\n      } : { HydrateFallback }\n    };\n  }\n  return { Component: Component4, ErrorBoundary, HydrateFallback };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () => null })) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let routeModule = routeModules[route.id];\n    invariant2(\n      routeModule,\n      \"No `routeModule` available to create server routes\"\n    );\n    let dataRoute = {\n      ...getRouteComponents(route, routeModule, isSpaMode),\n      caseSensitive: route.caseSensitive,\n      id: route.id,\n      index: route.index,\n      path: route.path,\n      handle: routeModule.handle,\n      // For SPA Mode, all routes are lazy except root.  However we tell the\n      // router root is also lazy here too since we don't need a full\n      // implementation - we just need a `lazy` prop to tell the RR rendering\n      // where to stop which is always at the root route in SPA mode\n      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,\n      // For partial hydration rendering, we need to indicate when the route\n      // has a loader/clientLoader, but it won't ever be called during the static\n      // render, so just give it a no-op function so we can render down to the\n      // proper fallback\n      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0\n      // We don't need middleware/action/shouldRevalidate on these routes since\n      // they're for a static render\n    };\n    let children = createServerRoutes(\n      manifest,\n      routeModules,\n      future,\n      isSpaMode,\n      route.id,\n      routesByParentId,\n      spaModeLazyPromise\n    );\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {\n  return createClientRoutes(\n    manifest,\n    routeModulesCache,\n    initialState,\n    ssr,\n    isSpaMode,\n    \"\",\n    groupRoutesByParentId(manifest),\n    needsRevalidation\n  );\n}\nfunction preventInvalidServerHandlerCall(type, route) {\n  if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${route.id}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nfunction noActionDefinedError(type, routeId) {\n  let article = type === \"clientAction\" ? \"a\" : \"an\";\n  let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n  console.error(msg);\n  throw new ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let routeModule = routeModulesCache[route.id];\n    function fetchServerHandler(singleFetch) {\n      invariant2(\n        typeof singleFetch === \"function\",\n        \"No single fetch function available for route handler\"\n      );\n      return singleFetch();\n    }\n    function fetchServerLoader(singleFetch) {\n      if (!route.hasLoader) return Promise.resolve(null);\n      return fetchServerHandler(singleFetch);\n    }\n    function fetchServerAction(singleFetch) {\n      if (!route.hasAction) {\n        throw noActionDefinedError(\"action\", route.id);\n      }\n      return fetchServerHandler(singleFetch);\n    }\n    function prefetchModule(modulePath) {\n      import(\n        /* @vite-ignore */\n        /* webpackIgnore: true */\n        modulePath\n      );\n    }\n    function prefetchRouteModuleChunks(route2) {\n      if (route2.clientActionModule) {\n        prefetchModule(route2.clientActionModule);\n      }\n      if (route2.clientLoaderModule) {\n        prefetchModule(route2.clientLoaderModule);\n      }\n    }\n    async function prefetchStylesAndCallHandler(handler) {\n      let cachedModule = routeModulesCache[route.id];\n      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n      try {\n        return handler();\n      } finally {\n        await linkPrefetchPromise;\n      }\n    }\n    let dataRoute = {\n      id: route.id,\n      index: route.index,\n      path: route.path\n    };\n    if (routeModule) {\n      Object.assign(dataRoute, {\n        ...dataRoute,\n        ...getRouteComponents(route, routeModule, isSpaMode),\n        unstable_middleware: routeModule.unstable_clientMiddleware,\n        handle: routeModule.handle,\n        shouldRevalidate: getShouldRevalidateFunction(\n          dataRoute.path,\n          routeModule,\n          route,\n          ssr,\n          needsRevalidation\n        )\n      });\n      let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;\n      let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;\n      let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;\n      let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;\n      let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);\n      dataRoute.loader = async ({ request, params, context }, singleFetch) => {\n        try {\n          let result = await prefetchStylesAndCallHandler(async () => {\n            invariant2(\n              routeModule,\n              \"No `routeModule` available for critical-route loader\"\n            );\n            if (!routeModule.clientLoader) {\n              return fetchServerLoader(singleFetch);\n            }\n            return routeModule.clientLoader({\n              request,\n              params,\n              context,\n              async serverLoader() {\n                preventInvalidServerHandlerCall(\"loader\", route);\n                if (isHydrationRequest) {\n                  if (hasInitialData) {\n                    return initialData;\n                  }\n                  if (hasInitialError) {\n                    throw initialError;\n                  }\n                }\n                return fetchServerLoader(singleFetch);\n              }\n            });\n          });\n          return result;\n        } finally {\n          isHydrationRequest = false;\n        }\n      };\n      dataRoute.loader.hydrate = shouldHydrateRouteLoader(\n        route.id,\n        routeModule.clientLoader,\n        route.hasLoader,\n        isSpaMode\n      );\n      dataRoute.action = ({ request, params, context }, singleFetch) => {\n        return prefetchStylesAndCallHandler(async () => {\n          invariant2(\n            routeModule,\n            \"No `routeModule` available for critical-route action\"\n          );\n          if (!routeModule.clientAction) {\n            if (isSpaMode) {\n              throw noActionDefinedError(\"clientAction\", route.id);\n            }\n            return fetchServerAction(singleFetch);\n          }\n          return routeModule.clientAction({\n            request,\n            params,\n            context,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route);\n              return fetchServerAction(singleFetch);\n            }\n          });\n        });\n      };\n    } else {\n      if (!route.hasClientLoader) {\n        dataRoute.loader = (_, singleFetch) => prefetchStylesAndCallHandler(() => {\n          return fetchServerLoader(singleFetch);\n        });\n      }\n      if (!route.hasClientAction) {\n        dataRoute.action = (_, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) {\n            throw noActionDefinedError(\"clientAction\", route.id);\n          }\n          return fetchServerAction(singleFetch);\n        });\n      }\n      let lazyRoutePromise;\n      async function getLazyRoute() {\n        if (lazyRoutePromise) {\n          return await lazyRoutePromise;\n        }\n        lazyRoutePromise = (async () => {\n          if (route.clientLoaderModule || route.clientActionModule) {\n            await new Promise((resolve) => setTimeout(resolve, 0));\n          }\n          let routeModulePromise = loadRouteModuleWithBlockingLinks(\n            route,\n            routeModulesCache\n          );\n          prefetchRouteModuleChunks(route);\n          return await routeModulePromise;\n        })();\n        return await lazyRoutePromise;\n      }\n      dataRoute.lazy = {\n        loader: route.hasClientLoader ? async () => {\n          let { clientLoader } = route.clientLoaderModule ? await import(\n            /* @vite-ignore */\n            /* webpackIgnore: true */\n            route.clientLoaderModule\n          ) : await getLazyRoute();\n          invariant2(clientLoader, \"No `clientLoader` export found\");\n          return (args, singleFetch) => clientLoader({\n            ...args,\n            async serverLoader() {\n              preventInvalidServerHandlerCall(\"loader\", route);\n              return fetchServerLoader(singleFetch);\n            }\n          });\n        } : void 0,\n        action: route.hasClientAction ? async () => {\n          let clientActionPromise = route.clientActionModule ? import(\n            /* @vite-ignore */\n            /* webpackIgnore: true */\n            route.clientActionModule\n          ) : getLazyRoute();\n          prefetchRouteModuleChunks(route);\n          let { clientAction } = await clientActionPromise;\n          invariant2(clientAction, \"No `clientAction` export found\");\n          return (args, singleFetch) => clientAction({\n            ...args,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route);\n              return fetchServerAction(singleFetch);\n            }\n          });\n        } : void 0,\n        unstable_middleware: route.hasClientMiddleware ? async () => {\n          let { unstable_clientMiddleware } = route.clientMiddlewareModule ? await import(\n            /* @vite-ignore */\n            /* webpackIgnore: true */\n            route.clientMiddlewareModule\n          ) : await getLazyRoute();\n          invariant2(\n            unstable_clientMiddleware,\n            \"No `unstable_clientMiddleware` export found\"\n          );\n          return unstable_clientMiddleware;\n        } : void 0,\n        shouldRevalidate: async () => {\n          let lazyRoute = await getLazyRoute();\n          return getShouldRevalidateFunction(\n            dataRoute.path,\n            lazyRoute,\n            route,\n            ssr,\n            needsRevalidation\n          );\n        },\n        handle: async () => (await getLazyRoute()).handle,\n        // No need to wrap these in layout since the root route is never\n        // loaded via route.lazy()\n        Component: async () => (await getLazyRoute()).Component,\n        ErrorBoundary: route.hasErrorBoundary ? async () => (await getLazyRoute()).ErrorBoundary : void 0\n      };\n    }\n    let children = createClientRoutes(\n      manifest,\n      routeModulesCache,\n      initialState,\n      ssr,\n      isSpaMode,\n      route.id,\n      routesByParentId,\n      needsRevalidation\n    );\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {\n  if (needsRevalidation) {\n    return wrapShouldRevalidateForHdr(\n      manifestRoute.id,\n      route.shouldRevalidate,\n      needsRevalidation\n    );\n  }\n  if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {\n    let myParams = path ? compilePath(path)[1].map((p) => p.paramName) : [];\n    const didParamsChange = (opts) => myParams.some((p) => opts.currentParams[p] !== opts.nextParams[p]);\n    if (route.shouldRevalidate) {\n      let fn = route.shouldRevalidate;\n      return (opts) => fn({\n        ...opts,\n        defaultShouldRevalidate: didParamsChange(opts)\n      });\n    } else {\n      return (opts) => didParamsChange(opts);\n    }\n  }\n  if (ssr && route.shouldRevalidate) {\n    let fn = route.shouldRevalidate;\n    return (opts) => fn({ ...opts, defaultShouldRevalidate: true });\n  }\n  return route.shouldRevalidate;\n}\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n  let handledRevalidation = false;\n  return (arg) => {\n    if (!handledRevalidation) {\n      handledRevalidation = true;\n      return needsRevalidation.has(routeId);\n    }\n    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n  };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModulePromise = loadRouteModule(route, routeModules);\n  let prefetchRouteCssPromise = prefetchRouteCss(route);\n  let routeModule = await routeModulePromise;\n  await Promise.all([\n    prefetchRouteCssPromise,\n    prefetchStyleLinks(route, routeModule)\n  ]);\n  return {\n    Component: getRouteModuleComponent(routeModule),\n    ErrorBoundary: routeModule.ErrorBoundary,\n    unstable_clientMiddleware: routeModule.unstable_clientMiddleware,\n    clientAction: routeModule.clientAction,\n    clientLoader: routeModule.clientLoader,\n    handle: routeModule.handle,\n    links: routeModule.links,\n    meta: routeModule.meta,\n    shouldRevalidate: routeModule.shouldRevalidate\n  };\n}\nfunction getRouteModuleComponent(routeModule) {\n  if (routeModule.default == null) return void 0;\n  let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n  if (!isEmptyObject) {\n    return routeModule.default;\n  }\n}\nfunction shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {\n  return isSpaMode && routeId !== \"root\" || clientLoader != null && (clientLoader.hydrate === true || hasLoader !== true);\n}\n\n// lib/dom/ssr/fog-of-war.ts\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction isFogOfWarEnabled(routeDiscovery, ssr) {\n  return routeDiscovery.mode === \"lazy\" && ssr === true;\n}\nfunction getPartialManifest({ sri, ...manifest }, router) {\n  let routeIds = new Set(router.state.matches.map((m) => m.route.id));\n  let segments = router.state.location.pathname.split(\"/\").filter(Boolean);\n  let paths = [\"/\"];\n  segments.pop();\n  while (segments.length > 0) {\n    paths.push(`/${segments.join(\"/\")}`);\n    segments.pop();\n  }\n  paths.forEach((path) => {\n    let matches = matchRoutes(router.routes, path, router.basename);\n    if (matches) {\n      matches.forEach((m) => routeIds.add(m.route.id));\n    }\n  });\n  let initialRoutes = [...routeIds].reduce(\n    (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),\n    {}\n  );\n  return {\n    ...manifest,\n    routes: initialRoutes,\n    sri: sri ? true : void 0\n  };\n}\nfunction getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {\n  if (!isFogOfWarEnabled(routeDiscovery, ssr)) {\n    return void 0;\n  }\n  return async ({ path, patch, signal, fetcherKey }) => {\n    if (discoveredPaths.has(path)) {\n      return;\n    }\n    await fetchAndApplyManifestPatches(\n      [path],\n      fetcherKey ? window.location.href : path,\n      manifest,\n      routeModules,\n      ssr,\n      isSpaMode,\n      basename,\n      routeDiscovery.manifestPath,\n      patch,\n      signal\n    );\n  };\n}\nfunction useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {\n  React7.useEffect(() => {\n    if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let lazyPaths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (lazyPaths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          lazyPaths,\n          null,\n          manifest,\n          routeModules,\n          ssr,\n          isSpaMode,\n          router.basename,\n          routeDiscovery.manifestPath,\n          router.patchRoutes\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n    return () => observer.disconnect();\n  }, [ssr, isSpaMode, manifest, routeModules, router, routeDiscovery]);\n}\nfunction getManifestPath(_manifestPath, basename) {\n  let manifestPath = _manifestPath || \"/__manifest\";\n  if (basename == null) {\n    return manifestPath;\n  }\n  return `${basename}${manifestPath}`.replace(/\\/+/g, \"/\");\n}\nvar MANIFEST_VERSION_STORAGE_KEY = \"react-router-manifest-version\";\nasync function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {\n  let url = new URL(\n    getManifestPath(manifestPath, basename),\n    window.location.origin\n  );\n  paths.sort().forEach((path) => url.searchParams.append(\"p\", path));\n  url.searchParams.set(\"version\", manifest.version);\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let serverPatches;\n  try {\n    let res = await fetch(url, { signal });\n    if (!res.ok) {\n      throw new Error(`${res.status} ${res.statusText}`);\n    } else if (res.status === 204 && res.headers.has(\"X-Remix-Reload-Document\")) {\n      if (!errorReloadPath) {\n        console.warn(\n          \"Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.\"\n        );\n        return;\n      }\n      if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {\n        console.error(\n          \"Unable to discover routes due to manifest version mismatch.\"\n        );\n        return;\n      }\n      sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);\n      window.location.href = errorReloadPath;\n      console.warn(\"Detected manifest version mismatch, reloading...\");\n      await new Promise(() => {\n      });\n    } else if (res.status >= 400) {\n      throw new Error(await res.text());\n    }\n    sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);\n    serverPatches = await res.json();\n  } catch (e) {\n    if (signal?.aborted) return;\n    throw e;\n  }\n  let knownRoutes = new Set(Object.keys(manifest.routes));\n  let patches = Object.values(serverPatches).reduce((acc, route) => {\n    if (route && !knownRoutes.has(route.id)) {\n      acc[route.id] = route;\n    }\n    return acc;\n  }, {});\n  Object.assign(manifest.routes, patches);\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  let parentIds = /* @__PURE__ */ new Set();\n  Object.values(patches).forEach((patch) => {\n    if (patch && (!patch.parentId || !patches[patch.parentId])) {\n      parentIds.add(patch.parentId);\n    }\n  });\n  parentIds.forEach(\n    (parentId) => patchRoutes(\n      parentId || null,\n      createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)\n    )\n  );\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\n\n// lib/dom/ssr/components.tsx\nfunction useDataRouterContext2() {\n  let context = React8.useContext(DataRouterContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <DataRouterContext.Provider> element\"\n  );\n  return context;\n}\nfunction useDataRouterStateContext() {\n  let context = React8.useContext(DataRouterStateContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <DataRouterStateContext.Provider> element\"\n  );\n  return context;\n}\nvar FrameworkContext = React8.createContext(void 0);\nFrameworkContext.displayName = \"FrameworkContext\";\nfunction useFrameworkContext() {\n  let context = React8.useContext(FrameworkContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <HydratedRouter> element\"\n  );\n  return context;\n}\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let frameworkContext = React8.useContext(FrameworkContext);\n  let [maybePrefetch, setMaybePrefetch] = React8.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = React8.useState(false);\n  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;\n  let ref = React8.useRef(null);\n  React8.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n    if (prefetch === \"viewport\") {\n      let callback = (entries) => {\n        entries.forEach((entry) => {\n          setShouldPrefetch(entry.isIntersecting);\n        });\n      };\n      let observer = new IntersectionObserver(callback, { threshold: 0.5 });\n      if (ref.current) observer.observe(ref.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [prefetch]);\n  React8.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  let setIntent = () => {\n    setMaybePrefetch(true);\n  };\n  let cancelIntent = () => {\n    setMaybePrefetch(false);\n    setShouldPrefetch(false);\n  };\n  if (!frameworkContext) {\n    return [false, ref, {}];\n  }\n  if (prefetch !== \"intent\") {\n    return [shouldPrefetch, ref, {}];\n  }\n  return [\n    shouldPrefetch,\n    ref,\n    {\n      onFocus: composeEventHandlers(onFocus, setIntent),\n      onBlur: composeEventHandlers(onBlur, cancelIntent),\n      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n      onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n    }\n  ];\n}\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return (event) => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\nfunction getActiveMatches(matches, errors, isSpaMode) {\n  if (isSpaMode && !isHydrated) {\n    return [matches[0]];\n  }\n  if (errors) {\n    let errorIdx = matches.findIndex((m) => errors[m.route.id] !== void 0);\n    return matches.slice(0, errorIdx + 1);\n  }\n  return matches;\n}\nvar CRITICAL_CSS_DATA_ATTRIBUTE = \"data-react-router-critical-css\";\nfunction Links() {\n  let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();\n  let { errors, matches: routerMatches } = useDataRouterStateContext();\n  let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let keyedLinks = React8.useMemo(\n    () => getKeyedLinksForMatches(matches, routeModules, manifest),\n    [matches, routeModules, manifest]\n  );\n  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, typeof criticalCss === \"string\" ? /* @__PURE__ */ React8.createElement(\n    \"style\",\n    {\n      ...{ [CRITICAL_CSS_DATA_ATTRIBUTE]: \"\" },\n      dangerouslySetInnerHTML: { __html: criticalCss }\n    }\n  ) : null, typeof criticalCss === \"object\" ? /* @__PURE__ */ React8.createElement(\n    \"link\",\n    {\n      ...{ [CRITICAL_CSS_DATA_ATTRIBUTE]: \"\" },\n      rel: \"stylesheet\",\n      href: criticalCss.href\n    }\n  ) : null, keyedLinks.map(\n    ({ key, link }) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React8.createElement(PrefetchPageLinks, { key, ...link }) : /* @__PURE__ */ React8.createElement(\"link\", { key, ...link })\n  ));\n}\nfunction PrefetchPageLinks({ page, ...linkProps }) {\n  let { router } = useDataRouterContext2();\n  let matches = React8.useMemo(\n    () => matchRoutes(router.routes, page, router.basename),\n    [router.routes, page, router.basename]\n  );\n  if (!matches) {\n    return null;\n  }\n  return /* @__PURE__ */ React8.createElement(PrefetchPageLinksImpl, { page, matches, ...linkProps });\n}\nfunction useKeyedPrefetchLinks(matches) {\n  let { manifest, routeModules } = useFrameworkContext();\n  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React8.useState([]);\n  React8.useEffect(() => {\n    let interrupted = false;\n    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(\n      (links) => {\n        if (!interrupted) {\n          setKeyedPrefetchLinks(links);\n        }\n      }\n    );\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, manifest, routeModules]);\n  return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let { manifest, routeModules } = useFrameworkContext();\n  let { basename } = useDataRouterContext2();\n  let { loaderData, matches } = useDataRouterStateContext();\n  let newMatchesForData = React8.useMemo(\n    () => getNewMatchesForLinks(\n      page,\n      nextMatches,\n      matches,\n      manifest,\n      location,\n      \"data\"\n    ),\n    [page, nextMatches, matches, manifest, location]\n  );\n  let newMatchesForAssets = React8.useMemo(\n    () => getNewMatchesForLinks(\n      page,\n      nextMatches,\n      matches,\n      manifest,\n      location,\n      \"assets\"\n    ),\n    [page, nextMatches, matches, manifest, location]\n  );\n  let dataHrefs = React8.useMemo(() => {\n    if (page === location.pathname + location.search + location.hash) {\n      return [];\n    }\n    let routesParams = /* @__PURE__ */ new Set();\n    let foundOptOutRoute = false;\n    nextMatches.forEach((m) => {\n      let manifestRoute = manifest.routes[m.route.id];\n      if (!manifestRoute || !manifestRoute.hasLoader) {\n        return;\n      }\n      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {\n        foundOptOutRoute = true;\n      } else if (manifestRoute.hasClientLoader) {\n        foundOptOutRoute = true;\n      } else {\n        routesParams.add(m.route.id);\n      }\n    });\n    if (routesParams.size === 0) {\n      return [];\n    }\n    let url = singleFetchUrl(page, basename, \"data\");\n    if (foundOptOutRoute && routesParams.size > 0) {\n      url.searchParams.set(\n        \"_routes\",\n        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(\",\")\n      );\n    }\n    return [url.pathname + url.search];\n  }, [\n    basename,\n    loaderData,\n    location,\n    manifest,\n    newMatchesForData,\n    nextMatches,\n    page,\n    routeModules\n  ]);\n  let moduleHrefs = React8.useMemo(\n    () => getModuleLinkHrefs(newMatchesForAssets, manifest),\n    [newMatchesForAssets, manifest]\n  );\n  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React8.createElement(\"link\", { key: href, rel: \"prefetch\", as: \"fetch\", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ React8.createElement(\"link\", { key: href, rel: \"modulepreload\", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (\n    // these don't spread `linkProps` because they are full link descriptors\n    // already with their own props\n    /* @__PURE__ */ React8.createElement(\"link\", { key, ...link })\n  )));\n}\nfunction Meta() {\n  let { isSpaMode, routeModules } = useFrameworkContext();\n  let {\n    errors,\n    matches: routerMatches,\n    loaderData\n  } = useDataRouterStateContext();\n  let location = useLocation();\n  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let error = null;\n  if (errors) {\n    error = errors[_matches[_matches.length - 1].route.id];\n  }\n  let meta = [];\n  let leafMeta = null;\n  let matches = [];\n  for (let i = 0; i < _matches.length; i++) {\n    let _match = _matches[i];\n    let routeId = _match.route.id;\n    let data2 = loaderData[routeId];\n    let params = _match.params;\n    let routeModule = routeModules[routeId];\n    let routeMeta = [];\n    let match = {\n      id: routeId,\n      data: data2,\n      meta: [],\n      params: _match.params,\n      pathname: _match.pathname,\n      handle: _match.route.handle,\n      error\n    };\n    matches[i] = match;\n    if (routeModule?.meta) {\n      routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data: data2,\n        params,\n        location,\n        matches,\n        error\n      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;\n    } else if (leafMeta) {\n      routeMeta = [...leafMeta];\n    }\n    routeMeta = routeMeta || [];\n    if (!Array.isArray(routeMeta)) {\n      throw new Error(\n        \"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must return an array of meta objects.\\n\\nTo reference the meta function API, see https://remix.run/route/meta\"\n      );\n    }\n    match.meta = routeMeta;\n    matches[i] = match;\n    meta = [...routeMeta];\n    leafMeta = meta;\n  }\n  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, meta.flat().map((metaProps) => {\n    if (!metaProps) {\n      return null;\n    }\n    if (\"tagName\" in metaProps) {\n      let { tagName, ...rest } = metaProps;\n      if (!isValidMetaTag(tagName)) {\n        console.warn(\n          `A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`\n        );\n        return null;\n      }\n      let Comp = tagName;\n      return /* @__PURE__ */ React8.createElement(Comp, { key: JSON.stringify(rest), ...rest });\n    }\n    if (\"title\" in metaProps) {\n      return /* @__PURE__ */ React8.createElement(\"title\", { key: \"title\" }, String(metaProps.title));\n    }\n    if (\"charset\" in metaProps) {\n      metaProps.charSet ?? (metaProps.charSet = metaProps.charset);\n      delete metaProps.charset;\n    }\n    if (\"charSet\" in metaProps && metaProps.charSet != null) {\n      return typeof metaProps.charSet === \"string\" ? /* @__PURE__ */ React8.createElement(\"meta\", { key: \"charSet\", charSet: metaProps.charSet }) : null;\n    }\n    if (\"script:ld+json\" in metaProps) {\n      try {\n        let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n        return /* @__PURE__ */ React8.createElement(\n          \"script\",\n          {\n            key: `script:ld+json:${json}`,\n            type: \"application/ld+json\",\n            dangerouslySetInnerHTML: { __html: json }\n          }\n        );\n      } catch (err) {\n        return null;\n      }\n    }\n    return /* @__PURE__ */ React8.createElement(\"meta\", { key: JSON.stringify(metaProps), ...metaProps });\n  }));\n}\nfunction isValidMetaTag(tagName) {\n  return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nvar isHydrated = false;\nfunction Scripts(scriptProps) {\n  let {\n    manifest,\n    serverHandoffString,\n    isSpaMode,\n    renderMeta,\n    routeDiscovery,\n    ssr\n  } = useFrameworkContext();\n  let { router, static: isStatic, staticContext } = useDataRouterContext2();\n  let { matches: routerMatches } = useDataRouterStateContext();\n  let isRSCRouterContext = useIsRSCRouterContext();\n  let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);\n  if (renderMeta) {\n    renderMeta.didRenderScripts = true;\n  }\n  let matches = getActiveMatches(routerMatches, null, isSpaMode);\n  React8.useEffect(() => {\n    isHydrated = true;\n  }, []);\n  let initialScripts = React8.useMemo(() => {\n    if (isRSCRouterContext) {\n      return null;\n    }\n    let streamScript = \"window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());\";\n    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : \" \";\n    let routeModulesScript = !isStatic ? \" \" : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : \"\"};\n${matches.map((match, routeIndex) => {\n      let routeVarName = `route${routeIndex}`;\n      let manifestEntry = manifest.routes[match.route.id];\n      invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);\n      let {\n        clientActionModule,\n        clientLoaderModule,\n        clientMiddlewareModule,\n        hydrateFallbackModule,\n        module\n      } = manifestEntry;\n      let chunks = [\n        ...clientActionModule ? [\n          {\n            module: clientActionModule,\n            varName: `${routeVarName}_clientAction`\n          }\n        ] : [],\n        ...clientLoaderModule ? [\n          {\n            module: clientLoaderModule,\n            varName: `${routeVarName}_clientLoader`\n          }\n        ] : [],\n        ...clientMiddlewareModule ? [\n          {\n            module: clientMiddlewareModule,\n            varName: `${routeVarName}_clientMiddleware`\n          }\n        ] : [],\n        ...hydrateFallbackModule ? [\n          {\n            module: hydrateFallbackModule,\n            varName: `${routeVarName}_HydrateFallback`\n          }\n        ] : [],\n        { module, varName: `${routeVarName}_main` }\n      ];\n      if (chunks.length === 1) {\n        return `import * as ${routeVarName} from ${JSON.stringify(module)};`;\n      }\n      let chunkImportsSnippet = chunks.map((chunk) => `import * as ${chunk.varName} from \"${chunk.module}\";`).join(\"\\n\");\n      let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk) => `...${chunk.varName}`).join(\",\")}};`;\n      return [chunkImportsSnippet, mergedChunksSnippet].join(\"\\n\");\n    }).join(\"\\n\")}\n  ${enableFogOfWar ? (\n      // Inline a minimal manifest with the SSR matches\n      `window.__reactRouterManifest = ${JSON.stringify(\n        getPartialManifest(manifest, router),\n        null,\n        2\n      )};`\n    ) : \"\"}\n  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n    return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(\n      \"script\",\n      {\n        ...scriptProps,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: createHtml(contextScript),\n        type: void 0\n      }\n    ), /* @__PURE__ */ React8.createElement(\n      \"script\",\n      {\n        ...scriptProps,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: createHtml(routeModulesScript),\n        type: \"module\",\n        async: true\n      }\n    ));\n  }, []);\n  let preloads = isHydrated || isRSCRouterContext ? [] : dedupe(\n    manifest.entry.imports.concat(\n      getModuleLinkHrefs(matches, manifest, {\n        includeHydrateFallback: true\n      })\n    )\n  );\n  let sri = typeof manifest.sri === \"object\" ? manifest.sri : {};\n  warnOnce(\n    !isRSCRouterContext,\n    \"The <Scripts /> element is a no-op when using RSC and can be safely removed.\"\n  );\n  return isHydrated || isRSCRouterContext ? null : /* @__PURE__ */ React8.createElement(React8.Fragment, null, typeof manifest.sri === \"object\" ? /* @__PURE__ */ React8.createElement(\n    \"script\",\n    {\n      \"rr-importmap\": \"\",\n      type: \"importmap\",\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: JSON.stringify({\n          integrity: sri\n        })\n      }\n    }\n  ) : null, !enableFogOfWar ? /* @__PURE__ */ React8.createElement(\n    \"link\",\n    {\n      rel: \"modulepreload\",\n      href: manifest.url,\n      crossOrigin: scriptProps.crossOrigin,\n      integrity: sri[manifest.url],\n      suppressHydrationWarning: true\n    }\n  ) : null, /* @__PURE__ */ React8.createElement(\n    \"link\",\n    {\n      rel: \"modulepreload\",\n      href: manifest.entry.module,\n      crossOrigin: scriptProps.crossOrigin,\n      integrity: sri[manifest.entry.module],\n      suppressHydrationWarning: true\n    }\n  ), preloads.map((path) => /* @__PURE__ */ React8.createElement(\n    \"link\",\n    {\n      key: path,\n      rel: \"modulepreload\",\n      href: path,\n      crossOrigin: scriptProps.crossOrigin,\n      integrity: sri[path],\n      suppressHydrationWarning: true\n    }\n  )), initialScripts);\n}\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\nfunction mergeRefs(...refs) {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n// lib/dom/ssr/errorBoundaries.tsx\nvar RemixErrorBoundary = class extends React9.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: props.error || null, location: props.location };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return { error: props.error || null, location: props.location };\n    }\n    return { error: props.error || state.error, location: state.location };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */ React9.createElement(\n        RemixRootDefaultErrorBoundary,\n        {\n          error: this.state.error,\n          isOutsideRemixApp: true\n        }\n      );\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction RemixRootDefaultErrorBoundary({\n  error,\n  isOutsideRemixApp\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */ React9.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n      }\n    }\n  );\n  if (isRouteErrorResponse(error)) {\n    return /* @__PURE__ */ React9.createElement(BoundaryShell, { title: \"Unhandled Thrown Response!\" }, /* @__PURE__ */ React9.createElement(\"h1\", { style: { fontSize: \"24px\" } }, error.status, \" \", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */ React9.createElement(\n    BoundaryShell,\n    {\n      title: \"Application Error!\",\n      isOutsideRemixApp\n    },\n    /* @__PURE__ */ React9.createElement(\"h1\", { style: { fontSize: \"24px\" } }, \"Application Error\"),\n    /* @__PURE__ */ React9.createElement(\n      \"pre\",\n      {\n        style: {\n          padding: \"2rem\",\n          background: \"hsla(10, 50%, 50%, 0.1)\",\n          color: \"red\",\n          overflow: \"auto\"\n        }\n      },\n      errorInstance.stack\n    ),\n    heyDeveloper\n  );\n}\nfunction BoundaryShell({\n  title,\n  renderScripts,\n  isOutsideRemixApp,\n  children\n}) {\n  let { routeModules } = useFrameworkContext();\n  if (routeModules.root?.Layout && !isOutsideRemixApp) {\n    return children;\n  }\n  return /* @__PURE__ */ React9.createElement(\"html\", { lang: \"en\" }, /* @__PURE__ */ React9.createElement(\"head\", null, /* @__PURE__ */ React9.createElement(\"meta\", { charSet: \"utf-8\" }), /* @__PURE__ */ React9.createElement(\n    \"meta\",\n    {\n      name: \"viewport\",\n      content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }\n  ), /* @__PURE__ */ React9.createElement(\"title\", null, title)), /* @__PURE__ */ React9.createElement(\"body\", null, /* @__PURE__ */ React9.createElement(\"main\", { style: { fontFamily: \"system-ui, sans-serif\", padding: \"2rem\" } }, children, renderScripts ? /* @__PURE__ */ React9.createElement(Scripts, null) : null)));\n}\n\n// lib/dom/lib.tsx\nimport * as React10 from \"react\";\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\ntry {\n  if (isBrowser) {\n    window.__reactRouterVersion = // @ts-expect-error\n    \"7.7.1\";\n  }\n} catch (e) {\n}\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    unstable_getContext: opts?.unstable_getContext,\n    future: opts?.future,\n    history: createBrowserHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    hydrationRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n    window: opts?.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    unstable_getContext: opts?.unstable_getContext,\n    future: opts?.future,\n    history: createHashHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    hydrationRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n    window: opts?.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  let state = window?.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = {\n      ...state,\n      errors: deserializeErrors(state.errors)\n    };\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction BrowserRouter({\n  basename,\n  children,\n  window: window2\n}) {\n  let historyRef = React10.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React10.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React10.useCallback(\n    (newState) => {\n      React10.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React10.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction HashRouter({ basename, children, window: window2 }) {\n  let historyRef = React10.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window: window2, v5Compat: true });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React10.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React10.useCallback(\n    (newState) => {\n      React10.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React10.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction HistoryRouter({\n  basename,\n  children,\n  history\n}) {\n  let [state, setStateImpl] = React10.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = React10.useCallback(\n    (newState) => {\n      React10.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ React10.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nHistoryRouter.displayName = \"unstable_HistoryRouter\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React10.forwardRef(\n  function LinkWithRef({\n    onClick,\n    discover = \"render\",\n    prefetch = \"none\",\n    relative,\n    reloadDocument,\n    replace: replace2,\n    state,\n    target,\n    to,\n    preventScrollReset,\n    viewTransition,\n    ...rest\n  }, forwardedRef) {\n    let { basename } = React10.useContext(NavigationContext);\n    let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to);\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && isAbsolute) {\n      absoluteHref = to;\n      if (isBrowser) {\n        try {\n          let currentUrl = new URL(window.location.href);\n          let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n          let path = stripBasename(targetUrl.pathname, basename);\n          if (targetUrl.origin === currentUrl.origin && path != null) {\n            to = path + targetUrl.search + targetUrl.hash;\n          } else {\n            isExternal = true;\n          }\n        } catch (e) {\n          warning(\n            false,\n            `<Link to=\"${to}\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`\n          );\n        }\n      }\n    }\n    let href = useHref(to, { relative });\n    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(\n      prefetch,\n      rest\n    );\n    let internalOnClick = useLinkClickHandler(to, {\n      replace: replace2,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n      viewTransition\n    });\n    function handleClick(event) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n    let link = (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      /* @__PURE__ */ React10.createElement(\n        \"a\",\n        {\n          ...rest,\n          ...prefetchHandlers,\n          href: absoluteHref || href,\n          onClick: isExternal || reloadDocument ? onClick : handleClick,\n          ref: mergeRefs(forwardedRef, prefetchRef),\n          target,\n          \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n        }\n      )\n    );\n    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href })) : link;\n  }\n);\nLink.displayName = \"Link\";\nvar NavLink = React10.forwardRef(\n  function NavLinkWithRef({\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    viewTransition,\n    children,\n    ...rest\n  }, ref) {\n    let path = useResolvedPath(to, { relative: rest.relative });\n    let location = useLocation();\n    let routerState = React10.useContext(DataRouterStateContext);\n    let { navigator, basename } = React10.useContext(NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n      toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n      isActive,\n      isPending,\n      isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n    let className;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp(renderProps);\n    } else {\n      className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null,\n        isTransitioning ? \"transitioning\" : null\n      ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /* @__PURE__ */ React10.createElement(\n      Link,\n      {\n        ...rest,\n        \"aria-current\": ariaCurrent,\n        className,\n        ref,\n        style,\n        to,\n        viewTransition\n      },\n      typeof children === \"function\" ? children(renderProps) : children\n    );\n  }\n);\nNavLink.displayName = \"NavLink\";\nvar Form = React10.forwardRef(\n  ({\n    discover = \"render\",\n    fetcherKey,\n    navigate,\n    reloadDocument,\n    replace: replace2,\n    state,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    relative,\n    preventScrollReset,\n    viewTransition,\n    ...props\n  }, forwardedRef) => {\n    let submit = useSubmit();\n    let formAction = useFormAction(action, { relative });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let isAbsolute = typeof action === \"string\" && ABSOLUTE_URL_REGEX2.test(action);\n    let submitHandler = (event) => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n      let submitter = event.nativeEvent.submitter;\n      let submitMethod = submitter?.getAttribute(\"formmethod\") || method;\n      submit(submitter || event.currentTarget, {\n        fetcherKey,\n        method: submitMethod,\n        navigate,\n        replace: replace2,\n        state,\n        relative,\n        preventScrollReset,\n        viewTransition\n      });\n    };\n    return /* @__PURE__ */ React10.createElement(\n      \"form\",\n      {\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler,\n        ...props,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n      }\n    );\n  }\n);\nForm.displayName = \"Form\";\nfunction ScrollRestoration({\n  getKey,\n  storageKey,\n  ...props\n}) {\n  let remixContext = React10.useContext(FrameworkContext);\n  let { basename } = React10.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  useScrollRestoration({ getKey, storageKey });\n  let ssrKey = React10.useMemo(\n    () => {\n      if (!remixContext || !getKey) return null;\n      let userKey = getScrollRestorationKey(\n        location,\n        matches,\n        basename,\n        getKey\n      );\n      return userKey !== location.key ? userKey : null;\n    },\n    // Nah, we only need this the first time for the SSR render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n  if (!remixContext || remixContext.isSpaMode) {\n    return null;\n  }\n  let restoreScroll = ((storageKey2, restoreKey) => {\n    if (!window.history.state || !window.history.state.key) {\n      let key = Math.random().toString(32).slice(2);\n      window.history.replaceState({ key }, \"\");\n    }\n    try {\n      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n      let storedY = positions[restoreKey || window.history.state.key];\n      if (typeof storedY === \"number\") {\n        window.scrollTo(0, storedY);\n      }\n    } catch (error) {\n      console.error(error);\n      sessionStorage.removeItem(storageKey2);\n    }\n  }).toString();\n  return /* @__PURE__ */ React10.createElement(\n    \"script\",\n    {\n      ...props,\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: `(${restoreScroll})(${JSON.stringify(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        )}, ${JSON.stringify(ssrKey)})`\n      }\n    }\n  );\n}\nScrollRestoration.displayName = \"ScrollRestoration\";\nfunction getDataRouterConsoleError2(hookName) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext3(hookName) {\n  let ctx = React10.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError2(hookName));\n  return ctx;\n}\nfunction useDataRouterState2(hookName) {\n  let state = React10.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError2(hookName));\n  return state;\n}\nfunction useLinkClickHandler(to, {\n  target,\n  replace: replaceProp,\n  state,\n  preventScrollReset,\n  relative,\n  viewTransition\n} = {}) {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, { relative });\n  return React10.useCallback(\n    (event) => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n        navigate(to, {\n          replace: replace2,\n          state,\n          preventScrollReset,\n          relative,\n          viewTransition\n        });\n      }\n    },\n    [\n      location,\n      navigate,\n      path,\n      replaceProp,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      relative,\n      viewTransition\n    ]\n  );\n}\nfunction useSearchParams(defaultInit) {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`\n  );\n  let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React10.useRef(false);\n  let location = useLocation();\n  let searchParams = React10.useMemo(\n    () => (\n      // Only merge in the defaults if we haven't yet called setSearchParams.\n      // Once we call that we want those to take precedence, otherwise you can't\n      // remove a param with setSearchParams({}) if it has an initial value\n      getSearchParamsForLocation(\n        location.search,\n        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n      )\n    ),\n    [location.search]\n  );\n  let navigate = useNavigate();\n  let setSearchParams = React10.useCallback(\n    (nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(\n        typeof nextInit === \"function\" ? nextInit(new URLSearchParams(searchParams)) : nextInit\n      );\n      hasSetSearchParamsRef.current = true;\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    },\n    [navigate, searchParams]\n  );\n  return [searchParams, setSearchParams];\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = () => `__${String(++fetcherId)}__`;\nfunction useSubmit() {\n  let { router } = useDataRouterContext3(\"useSubmit\" /* UseSubmit */);\n  let { basename } = React10.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n  return React10.useCallback(\n    async (target, options = {}) => {\n      let { action, method, encType, formData, body } = getFormSubmissionInfo(\n        target,\n        basename\n      );\n      if (options.navigate === false) {\n        let key = options.fetcherKey || getUniqueFetcherId();\n        await router.fetch(key, currentRouteId, options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          flushSync: options.flushSync\n        });\n      } else {\n        await router.navigate(options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          replace: options.replace,\n          state: options.state,\n          fromRouteId: currentRouteId,\n          flushSync: options.flushSync,\n          viewTransition: options.viewTransition\n        });\n      }\n    },\n    [router, basename, currentRouteId]\n  );\n}\nfunction useFormAction(action, { relative } = {}) {\n  let { basename } = React10.useContext(NavigationContext);\n  let routeContext = React10.useContext(RouteContext);\n  invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n  let [match] = routeContext.matches.slice(-1);\n  let path = { ...useResolvedPath(action ? action : \".\", { relative }) };\n  let location = useLocation();\n  if (action == null) {\n    path.search = location.search;\n    let params = new URLSearchParams(path.search);\n    let indexValues = params.getAll(\"index\");\n    let hasNakedIndexParam = indexValues.some((v) => v === \"\");\n    if (hasNakedIndexParam) {\n      params.delete(\"index\");\n      indexValues.filter((v) => v).forEach((v) => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? `?${qs}` : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction useFetcher({\n  key\n} = {}) {\n  let { router } = useDataRouterContext3(\"useFetcher\" /* UseFetcher */);\n  let state = useDataRouterState2(\"useFetcher\" /* UseFetcher */);\n  let fetcherData = React10.useContext(FetchersContext);\n  let route = React10.useContext(RouteContext);\n  let routeId = route.matches[route.matches.length - 1]?.route.id;\n  invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);\n  invariant(route, `useFetcher must be used inside a RouteContext`);\n  invariant(\n    routeId != null,\n    `useFetcher can only be used on routes that contain a unique \"id\"`\n  );\n  let defaultKey = React10.useId();\n  let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  }\n  React10.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => router.deleteFetcher(fetcherKey);\n  }, [router, fetcherKey]);\n  let load = React10.useCallback(\n    async (href, opts) => {\n      invariant(routeId, \"No routeId available for fetcher.load()\");\n      await router.fetch(fetcherKey, routeId, href, opts);\n    },\n    [fetcherKey, routeId, router]\n  );\n  let submitImpl = useSubmit();\n  let submit = React10.useCallback(\n    async (target, opts) => {\n      await submitImpl(target, {\n        ...opts,\n        navigate: false,\n        fetcherKey\n      });\n    },\n    [fetcherKey, submitImpl]\n  );\n  let FetcherForm = React10.useMemo(() => {\n    let FetcherForm2 = React10.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ React10.createElement(Form, { ...props, navigate: false, fetcherKey, ref });\n      }\n    );\n    FetcherForm2.displayName = \"fetcher.Form\";\n    return FetcherForm2;\n  }, [fetcherKey]);\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data2 = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React10.useMemo(\n    () => ({\n      Form: FetcherForm,\n      submit,\n      load,\n      ...fetcher,\n      data: data2\n    }),\n    [FetcherForm, submit, load, fetcher, data2]\n  );\n  return fetcherWithComponents;\n}\nfunction useFetchers() {\n  let state = useDataRouterState2(\"useFetchers\" /* UseFetchers */);\n  return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({\n    ...fetcher,\n    key\n  }));\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction getScrollRestorationKey(location, matches, basename, getKey) {\n  let key = null;\n  if (getKey) {\n    if (basename !== \"/\") {\n      key = getKey(\n        {\n          ...location,\n          pathname: stripBasename(location.pathname, basename) || location.pathname\n        },\n        matches\n      );\n    } else {\n      key = getKey(location, matches);\n    }\n  }\n  if (key == null) {\n    key = location.key;\n  }\n  return key;\n}\nfunction useScrollRestoration({\n  getKey,\n  storageKey\n} = {}) {\n  let { router } = useDataRouterContext3(\"useScrollRestoration\" /* UseScrollRestoration */);\n  let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(\n    \"useScrollRestoration\" /* UseScrollRestoration */\n  );\n  let { basename } = React10.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  React10.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  usePageHide(\n    React10.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = getScrollRestorationKey(location, matches, basename, getKey);\n        savedScrollPositions[key] = window.scrollY;\n      }\n      try {\n        sessionStorage.setItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY,\n          JSON.stringify(savedScrollPositions)\n        );\n      } catch (error) {\n        warning(\n          false,\n          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`\n        );\n      }\n      window.history.scrollRestoration = \"auto\";\n    }, [navigation.state, getKey, basename, location, matches, storageKey])\n  );\n  if (typeof document !== \"undefined\") {\n    React10.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        );\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n      }\n    }, [storageKey]);\n    React10.useLayoutEffect(() => {\n      let disableScrollRestoration = router?.enableScrollRestoration(\n        savedScrollPositions,\n        () => window.scrollY,\n        getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0\n      );\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    React10.useLayoutEffect(() => {\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      try {\n        if (location.hash) {\n          let el = document.getElementById(\n            decodeURIComponent(location.hash.slice(1))\n          );\n          if (el) {\n            el.scrollIntoView();\n            return;\n          }\n        }\n      } catch {\n        warning(\n          false,\n          `\"${location.hash.slice(\n            1\n          )}\" is not a decodable element ID. The view will not scroll to it.`\n        );\n      }\n      if (preventScrollReset === true) {\n        return;\n      }\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\nfunction useBeforeUnload(callback, options) {\n  let { capture } = options || {};\n  React10.useEffect(() => {\n    let opts = capture != null ? { capture } : void 0;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePageHide(callback, options) {\n  let { capture } = options || {};\n  React10.useEffect(() => {\n    let opts = capture != null ? { capture } : void 0;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePrompt({\n  when,\n  message\n}) {\n  let blocker = useBlocker(when);\n  React10.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React10.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\nfunction useViewTransitionState(to, { relative } = {}) {\n  let vtContext = React10.useContext(ViewTransitionContext);\n  invariant(\n    vtContext != null,\n    \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\"\n  );\n  let { basename } = useDataRouterContext3(\n    \"useViewTransitionState\" /* useViewTransitionState */\n  );\n  let path = useResolvedPath(to, { relative });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n\n// lib/dom/server.tsx\nimport * as React11 from \"react\";\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\"\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let action = \"POP\" /* Pop */;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state != null ? locationProp.state : null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /* @__PURE__ */ React11.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location,\n      navigationType: action,\n      navigator: staticNavigator,\n      static: true\n    }\n  );\n}\nfunction StaticRouterProvider({\n  context,\n  router,\n  hydrate: hydrate2 = true,\n  nonce\n}) {\n  invariant(\n    router && context,\n    \"You must provide `router` and `context` to <StaticRouterProvider>\"\n  );\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    staticContext: context,\n    basename: context.basename || \"/\"\n  };\n  let fetchersContext = /* @__PURE__ */ new Map();\n  let hydrateScript = \"\";\n  if (hydrate2 !== false) {\n    let data2 = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    };\n    let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  let { state } = dataRouterContext.router;\n  return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React11.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React11.createElement(FetchersContext.Provider, { value: fetchersContext }, /* @__PURE__ */ React11.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, /* @__PURE__ */ React11.createElement(\n    Router,\n    {\n      basename: dataRouterContext.basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: dataRouterContext.navigator,\n      static: dataRouterContext.static\n    },\n    /* @__PURE__ */ React11.createElement(\n      DataRoutes2,\n      {\n        routes: router.routes,\n        future: router.future,\n        state\n      }\n    )\n  ))))), hydrateScript ? /* @__PURE__ */ React11.createElement(\n    \"script\",\n    {\n      suppressHydrationWarning: true,\n      nonce,\n      dangerouslySetInnerHTML: { __html: hydrateScript }\n    }\n  ) : null);\n}\nfunction DataRoutes2({\n  routes,\n  future,\n  state\n}) {\n  return useRoutesImpl(routes, void 0, state, future);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.\n        ...val.name !== \"Error\" ? {\n          __subType: val.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(\n        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`\n      );\n    },\n    replace(to) {\n      throw new Error(\n        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere in your app.`\n      );\n    },\n    go(delta) {\n      throw new Error(\n        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${delta})\\` somewhere in your app.`\n      );\n    },\n    back() {\n      throw new Error(\n        `You cannot use navigator.back() on the server because it is a stateless environment.`\n      );\n    },\n    forward() {\n      throw new Error(\n        `You cannot use navigator.forward() on the server because it is a stateless environment.`\n      );\n    }\n  };\n}\nfunction createStaticHandler2(routes, opts) {\n  return createStaticHandler(routes, {\n    ...opts,\n    mapRouteProperties\n  });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    void 0,\n    manifest\n  );\n  let matches = context.matches.map((match) => {\n    let route = manifest[match.route.id] || match.route;\n    return {\n      ...match,\n      route\n    };\n  });\n  let msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get future() {\n      return {\n        unstable_middleware: false,\n        ...opts?.future\n      };\n    },\n    get state() {\n      return {\n        historyAction: \"POP\" /* Pop */,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: /* @__PURE__ */ new Map(),\n        blockers: /* @__PURE__ */ new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return void 0;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    getBlocker() {\n      return IDLE_BLOCKER;\n    },\n    deleteBlocker() {\n      throw msg(\"deleteBlocker\");\n    },\n    patchRoutes() {\n      throw msg(\"patchRoutes\");\n    },\n    _internalFetchControllers: /* @__PURE__ */ new Map(),\n    _internalSetRoutes() {\n      throw msg(\"_internalSetRoutes\");\n    },\n    _internalSetStateDoNotUseOrYouWillBreakYourApp() {\n      throw msg(\"_internalSetStateDoNotUseOrYouWillBreakYourApp\");\n    }\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n  let href = typeof to === \"string\" ? to : createPath(to);\n  href = href.replace(/ $/, \"%20\");\n  let encoded = ABSOLUTE_URL_REGEX3.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n  return {\n    pathname: encoded.pathname,\n    search: encoded.search,\n    hash: encoded.hash\n  };\n}\nvar ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar ESCAPE_LOOKUP2 = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX2 = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n  return str.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);\n}\n\nexport {\n  Action,\n  createBrowserHistory,\n  invariant,\n  createPath,\n  parsePath,\n  unstable_createContext,\n  unstable_RouterContextProvider,\n  convertRoutesToDataRoutes,\n  matchRoutes,\n  generatePath,\n  matchPath,\n  stripBasename,\n  resolvePath,\n  data,\n  redirect,\n  redirectDocument,\n  replace,\n  ErrorResponseImpl,\n  isRouteErrorResponse,\n  IDLE_NAVIGATION,\n  IDLE_FETCHER,\n  IDLE_BLOCKER,\n  createRouter,\n  createStaticHandler,\n  getStaticContextFromError,\n  isDataWithResponseInit,\n  isResponse,\n  isRedirectStatusCode,\n  isRedirectResponse,\n  isMutationMethod,\n  DataRouterContext,\n  DataRouterStateContext,\n  RSCRouterContext,\n  ViewTransitionContext,\n  FetchersContext,\n  NavigationContext,\n  LocationContext,\n  RouteContext,\n  ENABLE_DEV_WARNINGS,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useNavigationType,\n  useMatch,\n  useNavigate,\n  useOutletContext,\n  useOutlet,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n  useNavigation,\n  useRevalidator,\n  useMatches,\n  useLoaderData,\n  useRouteLoaderData,\n  useActionData,\n  useRouteError,\n  useAsyncValue,\n  useAsyncError,\n  useBlocker,\n  warnOnce,\n  mapRouteProperties,\n  hydrationRouteProperties,\n  createMemoryRouter,\n  RouterProvider,\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  Await,\n  createRoutesFromChildren,\n  createRoutesFromElements,\n  renderMatches,\n  WithComponentProps,\n  withComponentProps,\n  WithHydrateFallbackProps,\n  withHydrateFallbackProps,\n  WithErrorBoundaryProps,\n  withErrorBoundaryProps,\n  createSearchParams,\n  encode,\n  createRequestInit,\n  SingleFetchRedirectSymbol,\n  SINGLE_FETCH_REDIRECT_STATUS,\n  NO_BODY_STATUS_CODES,\n  StreamTransfer,\n  getTurboStreamSingleFetchDataStrategy,\n  getSingleFetchDataStrategyImpl,\n  stripIndexParam,\n  singleFetchUrl,\n  decodeViaTurboStream,\n  RemixErrorBoundary,\n  createServerRoutes,\n  createClientRoutesWithHMRRevalidationOptOut,\n  noActionDefinedError,\n  createClientRoutes,\n  shouldHydrateRouteLoader,\n  getPatchRoutesOnNavigationFunction,\n  useFogOFWarDiscovery,\n  getManifestPath,\n  FrameworkContext,\n  CRITICAL_CSS_DATA_ATTRIBUTE,\n  Links,\n  PrefetchPageLinks,\n  Meta,\n  Scripts,\n  createBrowserRouter,\n  createHashRouter,\n  BrowserRouter,\n  HashRouter,\n  HistoryRouter,\n  Link,\n  NavLink,\n  Form,\n  ScrollRestoration,\n  useLinkClickHandler,\n  useSearchParams,\n  useSubmit,\n  useFormAction,\n  useFetcher,\n  useFetchers,\n  useScrollRestoration,\n  useBeforeUnload,\n  usePrompt,\n  useViewTransitionState,\n  StaticRouter,\n  StaticRouterProvider,\n  createStaticHandler2,\n  createStaticRouter\n};\n", "/**\n * react-router v7.7.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport {\n  ENABLE_DEV_WARNINGS,\n  ErrorResponseImpl,\n  FrameworkContext,\n  NO_BODY_STATUS_CODES,\n  Outlet,\n  RSCRouterContext,\n  RemixErrorBoundary,\n  RouterProvider,\n  SINGLE_FETCH_REDIRECT_STATUS,\n  SingleFetchRedirectSymbol,\n  StaticRouterProvider,\n  StreamTransfer,\n  convertRoutesToDataRoutes,\n  createBrowserHistory,\n  createMemoryRouter,\n  createRequestInit,\n  createRouter,\n  createServerRoutes,\n  createStaticHandler,\n  createStaticRouter,\n  decodeViaTurboStream,\n  encode,\n  getManifestPath,\n  getSingleFetchDataStrategyImpl,\n  getStaticContextFromError,\n  invariant,\n  isDataWithResponseInit,\n  isMutationMethod,\n  isRedirectResponse,\n  isRedirectStatusCode,\n  isResponse,\n  isRouteErrorResponse,\n  matchRoutes,\n  noActionDefinedError,\n  redirect,\n  redirectDocument,\n  replace,\n  shouldHydrateRouteLoader,\n  singleFetchUrl,\n  stripBasename,\n  stripIndexParam,\n  unstable_RouterContextProvider,\n  unstable_createContext,\n  useRouteError,\n  warnOnce,\n  withComponentProps,\n  withErrorBoundaryProps,\n  withHydrateFallbackProps\n} from \"./chunk-C37GKA54.mjs\";\n\n// lib/dom/ssr/server.tsx\nimport * as React from \"react\";\nfunction ServerRouter({\n  context,\n  url,\n  nonce\n}) {\n  if (typeof url === \"string\") {\n    url = new URL(url);\n  }\n  let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n  let routes = createServerRoutes(\n    manifest.routes,\n    routeModules,\n    context.future,\n    context.isSpaMode\n  );\n  context.staticHandlerContext.loaderData = {\n    ...context.staticHandlerContext.loaderData\n  };\n  for (let match of context.staticHandlerContext.matches) {\n    let routeId = match.route.id;\n    let route = routeModules[routeId];\n    let manifestRoute = context.manifest.routes[routeId];\n    if (route && manifestRoute && shouldHydrateRouteLoader(\n      routeId,\n      route.clientLoader,\n      manifestRoute.hasLoader,\n      context.isSpaMode\n    ) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n      delete context.staticHandlerContext.loaderData[routeId];\n    }\n  }\n  let router = createStaticRouter(routes, context.staticHandlerContext);\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(\n    FrameworkContext.Provider,\n    {\n      value: {\n        manifest,\n        routeModules,\n        criticalCss,\n        serverHandoffString,\n        future: context.future,\n        ssr: context.ssr,\n        isSpaMode: context.isSpaMode,\n        routeDiscovery: context.routeDiscovery,\n        serializeError: context.serializeError,\n        renderMeta: context.renderMeta\n      }\n    },\n    /* @__PURE__ */ React.createElement(RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ React.createElement(\n      StaticRouterProvider,\n      {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n      }\n    ))\n  ), context.serverHandoffStream ? /* @__PURE__ */ React.createElement(React.Suspense, null, /* @__PURE__ */ React.createElement(\n    StreamTransfer,\n    {\n      context,\n      identifier: 0,\n      reader: context.serverHandoffStream.getReader(),\n      textDecoder: new TextDecoder(),\n      nonce\n    }\n  )) : null);\n}\n\n// lib/dom/ssr/routes-test-stub.tsx\nimport * as React2 from \"react\";\nfunction createRoutesStub(routes, _context) {\n  return function RoutesTestStub({\n    initialEntries,\n    initialIndex,\n    hydrationData,\n    future\n  }) {\n    let routerRef = React2.useRef();\n    let frameworkContextRef = React2.useRef();\n    if (routerRef.current == null) {\n      frameworkContextRef.current = {\n        future: {\n          unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n          unstable_middleware: future?.unstable_middleware === true\n        },\n        manifest: {\n          routes: {},\n          entry: { imports: [], module: \"\" },\n          url: \"\",\n          version: \"\"\n        },\n        routeModules: {},\n        ssr: false,\n        isSpaMode: false,\n        routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" }\n      };\n      let patched = processRoutes(\n        // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n        // types compared to `AgnosticRouteObject`\n        convertRoutesToDataRoutes(routes, (r) => r),\n        _context !== void 0 ? _context : future?.unstable_middleware ? new unstable_RouterContextProvider() : {},\n        frameworkContextRef.current.manifest,\n        frameworkContextRef.current.routeModules\n      );\n      routerRef.current = createMemoryRouter(patched, {\n        initialEntries,\n        initialIndex,\n        hydrationData\n      });\n    }\n    return /* @__PURE__ */ React2.createElement(FrameworkContext.Provider, { value: frameworkContextRef.current }, /* @__PURE__ */ React2.createElement(RouterProvider, { router: routerRef.current }));\n  };\n}\nfunction processRoutes(routes, context, manifest, routeModules, parentId) {\n  return routes.map((route) => {\n    if (!route.id) {\n      throw new Error(\n        \"Expected a route.id in react-router processRoutes() function\"\n      );\n    }\n    let newRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      Component: route.Component ? withComponentProps(route.Component) : void 0,\n      HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,\n      ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,\n      action: route.action ? (args) => route.action({ ...args, context }) : void 0,\n      loader: route.loader ? (args) => route.loader({ ...args, context }) : void 0,\n      handle: route.handle,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    let entryRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      parentId,\n      hasAction: route.action != null,\n      hasLoader: route.loader != null,\n      // When testing routes, you should be stubbing loader/action/middleware,\n      // not trying to re-implement the full loader/clientLoader/SSR/hydration\n      // flow. That is better tested via E2E tests.\n      hasClientAction: false,\n      hasClientLoader: false,\n      hasClientMiddleware: false,\n      hasErrorBoundary: route.ErrorBoundary != null,\n      // any need for these?\n      module: \"build/stub-path-to-module.js\",\n      clientActionModule: void 0,\n      clientLoaderModule: void 0,\n      clientMiddlewareModule: void 0,\n      hydrateFallbackModule: void 0\n    };\n    manifest.routes[newRoute.id] = entryRoute;\n    routeModules[route.id] = {\n      default: newRoute.Component || Outlet,\n      ErrorBoundary: newRoute.ErrorBoundary || void 0,\n      handle: route.handle,\n      links: route.links,\n      meta: route.meta,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    if (route.children) {\n      newRoute.children = processRoutes(\n        route.children,\n        context,\n        manifest,\n        routeModules,\n        newRoute.id\n      );\n    }\n    return newRoute;\n  });\n}\n\n// lib/server-runtime/cookies.ts\nimport { parse, serialize } from \"cookie\";\n\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */ new TextEncoder();\nvar sign = async (value, secret) => {\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"sign\"]);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    \"\"\n  );\n  return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret) => {\n  let index = cookie.lastIndexOf(\".\");\n  let value = cookie.slice(0, index);\n  let hash = cookie.slice(index + 1);\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"verify\"]);\n  try {\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n  } catch (error) {\n    return false;\n  }\n};\nvar createKey = async (secret, usages) => crypto.subtle.importKey(\n  \"raw\",\n  encoder.encode(secret),\n  { name: \"HMAC\", hash: \"SHA-256\" },\n  false,\n  usages\n);\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n  return array;\n}\n\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {}) => {\n  let { secrets = [], ...options } = {\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = parse(cookieHeader, { ...options, ...parseOptions });\n      if (name in cookies) {\n        let value = cookies[name];\n        if (typeof value === \"string\" && value !== \"\") {\n          let decoded = await decodeCookieValue(value, secrets);\n          return decoded;\n        } else {\n          return \"\";\n        }\n      } else {\n        return null;\n      }\n    },\n    async serialize(value, serializeOptions) {\n      return serialize(\n        name,\n        value === \"\" ? \"\" : await encodeCookieValue(value, secrets),\n        {\n          ...options,\n          ...serializeOptions\n        }\n      );\n    }\n  };\n};\nvar isCookie = (object) => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  warnOnce(\n    !expires,\n    `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`\n  );\n}\n\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo, routeId) => {\n    let route = manifest[routeId];\n    if (route) {\n      memo[routeId] = route.module;\n    }\n    return memo;\n  }, {});\n}\n\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2) => {\n  ServerMode2[\"Development\"] = \"development\";\n  ServerMode2[\"Production\"] = \"production\";\n  ServerMode2[\"Test\"] = \"test\";\n  return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n  return value === \"development\" /* Development */ || value === \"production\" /* Production */ || value === \"test\" /* Test */;\n}\n\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== \"development\" /* Development */) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = void 0;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });\n  }, {});\n}\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n  let matches = matchRoutes(\n    routes,\n    pathname,\n    basename\n  );\n  if (!matches) return null;\n  return matches.map((match) => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n  let result = await handler({\n    request: stripRoutesParam(stripIndexParam2(args.request)),\n    params: args.params,\n    context: args.context\n  });\n  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n    throw new Response(null, result.init);\n  }\n  return result;\n}\nfunction stripIndexParam2(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_routes\");\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\n\n// lib/server-runtime/invariant.ts\nfunction invariant2(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    console.error(\n      \"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\"\n    );\n    throw new Error(message);\n  }\n}\n\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n  globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n  return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n  if (typeof process !== \"undefined\") {\n    try {\n      if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n        return request.headers.get(headerName);\n      }\n    } catch (e) {\n    }\n  }\n  return null;\n}\n\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => ({\n    ...route,\n    children: createRoutes(manifest, route.id, routesByParentId)\n  }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let commonRoute = {\n      // Always include root due to default boundaries\n      hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n      id: route.id,\n      path: route.path,\n      unstable_middleware: route.module.unstable_middleware,\n      // Need to use RR's version in the param typed here to permit the optional\n      // context even though we know it'll always be provided in remix\n      loader: route.module.loader ? async (args) => {\n        let preRenderedData = getBuildTimeHeader(\n          args.request,\n          \"X-React-Router-Prerender-Data\"\n        );\n        if (preRenderedData != null) {\n          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n          invariant2(encoded, \"Missing prerendered data for route\");\n          let uint8array = new TextEncoder().encode(encoded);\n          let stream = new ReadableStream({\n            start(controller) {\n              controller.enqueue(uint8array);\n              controller.close();\n            }\n          });\n          let decoded = await decodeViaTurboStream(stream, global);\n          let data2 = decoded.value;\n          if (data2 && SingleFetchRedirectSymbol in data2) {\n            let result = data2[SingleFetchRedirectSymbol];\n            let init = { status: result.status };\n            if (result.reload) {\n              throw redirectDocument(result.redirect, init);\n            } else if (result.replace) {\n              throw replace(result.redirect, init);\n            } else {\n              throw redirect(result.redirect, init);\n            }\n          } else {\n            invariant2(\n              data2 && route.id in data2,\n              \"Unable to decode prerendered data\"\n            );\n            let result = data2[route.id];\n            invariant2(\n              \"data\" in result,\n              \"Unable to process prerendered data\"\n            );\n            return result.data;\n          }\n        }\n        let val = await callRouteHandler(route.module.loader, args);\n        return val;\n      } : void 0,\n      action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,\n      handle: route.module.handle\n    };\n    return route.index ? {\n      index: true,\n      ...commonRoute\n    } : {\n      caseSensitive: route.caseSensitive,\n      children: createStaticHandlerDataRoutes(\n        manifest,\n        future,\n        route.id,\n        routesByParentId\n      ),\n      ...commonRoute\n    };\n  });\n}\n\n// lib/server-runtime/markup.ts\nvar ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);\n}\n\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n  return escapeHtml(JSON.stringify(serverHandoff));\n}\n\n// lib/server-runtime/headers.ts\nimport { splitCookiesString } from \"set-cookie-parser\";\nfunction getDocumentHeaders(context, build) {\n  return getDocumentHeadersImpl(context, (m) => {\n    let route = build.routes[m.route.id];\n    invariant2(route, `Route with id \"${m.route.id}\" not found in build`);\n    return route.module.headers;\n  });\n}\nfunction getDocumentHeadersImpl(context, getRouteHeadersFn) {\n  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;\n  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n  let errorHeaders;\n  if (boundaryIdx >= 0) {\n    let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n    context.matches.slice(boundaryIdx).some((match) => {\n      let id = match.route.id;\n      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n        errorHeaders = actionHeaders[id];\n      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n        errorHeaders = loaderHeaders[id];\n      }\n      return errorHeaders != null;\n    });\n  }\n  return matches.reduce((parentHeaders, match, idx) => {\n    let { id } = match.route;\n    let loaderHeaders = context.loaderHeaders[id] || new Headers();\n    let actionHeaders = context.actionHeaders[id] || new Headers();\n    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n    let headersFn = getRouteHeadersFn(match);\n    if (headersFn == null) {\n      let headers2 = new Headers(parentHeaders);\n      if (includeErrorCookies) {\n        prependCookies(errorHeaders, headers2);\n      }\n      prependCookies(actionHeaders, headers2);\n      prependCookies(loaderHeaders, headers2);\n      return headers2;\n    }\n    let headers = new Headers(\n      typeof headersFn === \"function\" ? headersFn({\n        loaderHeaders,\n        parentHeaders,\n        actionHeaders,\n        errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n      }) : headersFn\n    );\n    if (includeErrorCookies) {\n      prependCookies(errorHeaders, headers);\n    }\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers());\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n  if (parentSetCookieString) {\n    let cookies = splitCookiesString(parentSetCookieString);\n    let childCookies = new Set(childHeaders.getSetCookie());\n    cookies.forEach((cookie) => {\n      if (!childCookies.has(cookie)) {\n        childHeaders.append(\"Set-Cookie\", cookie);\n      }\n    });\n  }\n}\n\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n  ...NO_BODY_STATUS_CODES,\n  304\n]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let respond2 = function(context) {\n      let headers = getDocumentHeaders(context, build);\n      if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n        return generateSingleFetchResponse(request, build, serverMode, {\n          result: getSingleFetchRedirect(\n            context.statusCode,\n            headers,\n            build.basename\n          ),\n          headers,\n          status: SINGLE_FETCH_REDIRECT_STATUS\n        });\n      }\n      if (context.errors) {\n        Object.values(context.errors).forEach((err) => {\n          if (!isRouteErrorResponse(err) || err.error) {\n            handleError(err);\n          }\n        });\n        context.errors = sanitizeErrors(context.errors, serverMode);\n      }\n      let singleFetchResult;\n      if (context.errors) {\n        singleFetchResult = { error: Object.values(context.errors)[0] };\n      } else {\n        singleFetchResult = {\n          data: Object.values(context.actionData || {})[0]\n        };\n      }\n      return generateSingleFetchResponse(request, build, serverMode, {\n        result: singleFetchResult,\n        headers,\n        status: context.statusCode\n      });\n    };\n    var respond = respond2;\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...request.body ? { duplex: \"half\" } : void 0\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      skipRevalidation: true,\n      unstable_respond: respond2\n    });\n    if (!isResponse(result)) {\n      result = respond2(result);\n    }\n    if (isRedirectResponse(result)) {\n      return generateSingleFetchResponse(request, build, serverMode, {\n        result: getSingleFetchRedirect(\n          result.status,\n          result.headers,\n          build.basename\n        ),\n        headers: result.headers,\n        status: SINGLE_FETCH_REDIRECT_STATUS\n      });\n    }\n    return result;\n  } catch (error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: { error },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let respond2 = function(context) {\n      let headers = getDocumentHeaders(context, build);\n      if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n        return generateSingleFetchResponse(request, build, serverMode, {\n          result: {\n            [SingleFetchRedirectSymbol]: getSingleFetchRedirect(\n              context.statusCode,\n              headers,\n              build.basename\n            )\n          },\n          headers,\n          status: SINGLE_FETCH_REDIRECT_STATUS\n        });\n      }\n      if (context.errors) {\n        Object.values(context.errors).forEach((err) => {\n          if (!isRouteErrorResponse(err) || err.error) {\n            handleError(err);\n          }\n        });\n        context.errors = sanitizeErrors(context.errors, serverMode);\n      }\n      let results = {};\n      let loadedMatches = new Set(\n        context.matches.filter(\n          (m) => loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null\n        ).map((m) => m.route.id)\n      );\n      if (context.errors) {\n        for (let [id, error] of Object.entries(context.errors)) {\n          results[id] = { error };\n        }\n      }\n      for (let [id, data2] of Object.entries(context.loaderData)) {\n        if (!(id in results) && loadedMatches.has(id)) {\n          results[id] = { data: data2 };\n        }\n      }\n      return generateSingleFetchResponse(request, build, serverMode, {\n        result: results,\n        headers,\n        status: context.statusCode\n      });\n    };\n    var respond = respond2;\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n    let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      filterMatchesToLoad: (m) => !loadRouteIds || loadRouteIds.has(m.route.id),\n      skipLoaderErrorBubbling: true,\n      unstable_respond: respond2\n    });\n    if (!isResponse(result)) {\n      result = respond2(result);\n    }\n    if (isRedirectResponse(result)) {\n      return generateSingleFetchResponse(request, build, serverMode, {\n        result: {\n          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(\n            result.status,\n            result.headers,\n            build.basename\n          )\n        },\n        headers: result.headers,\n        status: SINGLE_FETCH_REDIRECT_STATUS\n      });\n    }\n    return result;\n  } catch (error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: { root: { error } },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, {\n  result,\n  headers,\n  status\n}) {\n  let resultHeaders = new Headers(headers);\n  resultHeaders.set(\"X-Remix-Response\", \"yes\");\n  if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n    return new Response(null, { status, headers: resultHeaders });\n  }\n  resultHeaders.set(\"Content-Type\", \"text/x-script\");\n  resultHeaders.delete(\"Content-Length\");\n  return new Response(\n    encodeViaTurboStream(\n      result,\n      request.signal,\n      build.entry.module.streamTimeout,\n      serverMode\n    ),\n    {\n      status: status || 200,\n      headers: resultHeaders\n    }\n  );\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n  let redirect2 = headers.get(\"Location\");\n  if (basename) {\n    redirect2 = stripBasename(redirect2, basename) || redirect2;\n  }\n  return {\n    redirect: redirect2,\n    status,\n    revalidate: (\n      // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n      // detail of ?_data requests as our way to tell the front end to revalidate when\n      // we didn't have a response body to include that information in.\n      // With single fetch, we tell the front end via this revalidate boolean field.\n      // However, we're respecting it for now because it may be something folks have\n      // used in their own responses\n      // TODO(v3): Consider removing or making this official public API\n      headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\")\n    ),\n    reload: headers.has(\"X-Remix-Reload-Document\"),\n    replace: headers.has(\"X-Remix-Replace\")\n  };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  let timeoutId = setTimeout(\n    () => controller.abort(new Error(\"Server Timeout\")),\n    typeof streamTimeout === \"number\" ? streamTimeout : 4950\n  );\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return encode(data2, {\n    signal: controller.signal,\n    plugins: [\n      (value) => {\n        if (value instanceof Error) {\n          let { name, message, stack } = serverMode === \"production\" /* Production */ ? sanitizeError(value, serverMode) : value;\n          return [\"SanitizedError\", name, message, stack];\n        }\n        if (value instanceof ErrorResponseImpl) {\n          let { data: data3, status, statusText } = value;\n          return [\"ErrorResponse\", data3, status, statusText];\n        }\n        if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n          return [\"SingleFetchRedirect\", value[SingleFetchRedirectSymbol]];\n        }\n      }\n    ],\n    postPlugins: [\n      (value) => {\n        if (!value) return;\n        if (typeof value !== \"object\") return;\n        return [\n          \"SingleFetchClassInstance\",\n          Object.fromEntries(Object.entries(value))\n        ];\n      },\n      () => [\"SingleFetchFallback\"]\n    ]\n  });\n}\n\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n  let routes = createRoutes(build.routes);\n  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n  let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */;\n  let staticHandler = createStaticHandler(dataRoutes, {\n    basename: build.basename\n  });\n  let errorHandler = build.entry.module.handleError || ((error, { request }) => {\n    if (serverMode !== \"test\" /* Test */ && !request.signal.aborted) {\n      console.error(\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        isRouteErrorResponse(error) && error.error ? error.error : error\n      );\n    }\n  });\n  return {\n    routes,\n    dataRoutes,\n    serverMode,\n    staticHandler,\n    errorHandler\n  };\n}\nvar createRequestHandler = (build, mode) => {\n  let _build;\n  let routes;\n  let serverMode;\n  let staticHandler;\n  let errorHandler;\n  return async function requestHandler(request, initialContext) {\n    _build = typeof build === \"function\" ? await build() : build;\n    if (typeof build === \"function\") {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    }\n    let params = {};\n    let loadContext;\n    let handleError = (error) => {\n      if (mode === \"development\" /* Development */) {\n        getDevServerHooks()?.processRequestError?.(error);\n      }\n      errorHandler(error, {\n        context: loadContext,\n        params,\n        request\n      });\n    };\n    if (_build.future.unstable_middleware) {\n      if (initialContext == null) {\n        loadContext = new unstable_RouterContextProvider();\n      } else {\n        try {\n          loadContext = new unstable_RouterContextProvider(\n            initialContext\n          );\n        } catch (e) {\n          let error = new Error(\n            `Unable to create initial \\`unstable_RouterContextProvider\\` instance. Please confirm you are returning an instance of \\`Map<unstable_routerContext, unknown>\\` from your \\`getLoadContext\\` function.\n\nError: ${e instanceof Error ? e.toString() : e}`\n          );\n          handleError(error);\n          return returnLastResortErrorResponse(error, serverMode);\n        }\n      }\n    } else {\n      loadContext = initialContext || {};\n    }\n    let url = new URL(request.url);\n    let normalizedBasename = _build.basename || \"/\";\n    let normalizedPath = url.pathname;\n    if (stripBasename(normalizedPath, normalizedBasename) === \"/_root.data\") {\n      normalizedPath = normalizedBasename;\n    } else if (normalizedPath.endsWith(\".data\")) {\n      normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n    }\n    if (stripBasename(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n      normalizedPath = normalizedPath.slice(0, -1);\n    }\n    let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n    if (!_build.ssr) {\n      let decodedPath = decodeURI(normalizedPath);\n      if (_build.prerender.length === 0) {\n        isSpaMode = true;\n      } else if (!_build.prerender.includes(decodedPath) && !_build.prerender.includes(decodedPath + \"/\")) {\n        if (url.pathname.endsWith(\".data\")) {\n          errorHandler(\n            new ErrorResponseImpl(\n              404,\n              \"Not Found\",\n              `Refusing to SSR the path \\`${decodedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`\n            ),\n            {\n              context: loadContext,\n              params,\n              request\n            }\n          );\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        } else {\n          isSpaMode = true;\n        }\n      }\n    }\n    let manifestUrl = getManifestPath(\n      _build.routeDiscovery.manifestPath,\n      normalizedBasename\n    );\n    if (url.pathname === manifestUrl) {\n      try {\n        let res = await handleManifestRequest(_build, routes, url);\n        return res;\n      } catch (e) {\n        handleError(e);\n        return new Response(\"Unknown Server Error\", { status: 500 });\n      }\n    }\n    let matches = matchServerRoutes(routes, normalizedPath, _build.basename);\n    if (matches && matches.length > 0) {\n      Object.assign(params, matches[0].params);\n    }\n    let response;\n    if (url.pathname.endsWith(\".data\")) {\n      let handlerUrl = new URL(request.url);\n      handlerUrl.pathname = normalizedPath;\n      let singleFetchMatches = matchServerRoutes(\n        routes,\n        handlerUrl.pathname,\n        _build.basename\n      );\n      response = await handleSingleFetchRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        request,\n        handlerUrl,\n        loadContext,\n        handleError\n      );\n      if (_build.entry.module.handleDataRequest) {\n        response = await _build.entry.module.handleDataRequest(response, {\n          context: loadContext,\n          params: singleFetchMatches ? singleFetchMatches[0].params : {},\n          request\n        });\n        if (isRedirectResponse(response)) {\n          let result = getSingleFetchRedirect(\n            response.status,\n            response.headers,\n            _build.basename\n          );\n          if (request.method === \"GET\") {\n            result = {\n              [SingleFetchRedirectSymbol]: result\n            };\n          }\n          let headers = new Headers(response.headers);\n          headers.set(\"Content-Type\", \"text/x-script\");\n          return new Response(\n            encodeViaTurboStream(\n              result,\n              request.signal,\n              _build.entry.module.streamTimeout,\n              serverMode\n            ),\n            {\n              status: SINGLE_FETCH_REDIRECT_STATUS,\n              headers\n            }\n          );\n        }\n      }\n    } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n      response = await handleResourceRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        matches.slice(-1)[0].route.id,\n        request,\n        loadContext,\n        handleError\n      );\n    } else {\n      let { pathname } = url;\n      let criticalCss = void 0;\n      if (_build.unstable_getCriticalCss) {\n        criticalCss = await _build.unstable_getCriticalCss({ pathname });\n      } else if (mode === \"development\" /* Development */ && getDevServerHooks()?.getCriticalCss) {\n        criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n      }\n      response = await handleDocumentRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        request,\n        loadContext,\n        handleError,\n        isSpaMode,\n        criticalCss\n      );\n    }\n    if (request.method === \"HEAD\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n    return response;\n  };\n};\nasync function handleManifestRequest(build, routes, url) {\n  if (build.assets.version !== url.searchParams.get(\"version\")) {\n    return new Response(null, {\n      status: 204,\n      headers: {\n        \"X-Remix-Reload-Document\": \"true\"\n      }\n    });\n  }\n  let patches = {};\n  if (url.searchParams.has(\"p\")) {\n    let paths = /* @__PURE__ */ new Set();\n    url.searchParams.getAll(\"p\").forEach((path) => {\n      if (!path.startsWith(\"/\")) {\n        path = `/${path}`;\n      }\n      let segments = path.split(\"/\").slice(1);\n      segments.forEach((_, i) => {\n        let partialPath = segments.slice(0, i + 1).join(\"/\");\n        paths.add(`/${partialPath}`);\n      });\n    });\n    for (let path of paths) {\n      let matches = matchServerRoutes(routes, path, build.basename);\n      if (matches) {\n        for (let match of matches) {\n          let routeId = match.route.id;\n          let route = build.assets.routes[routeId];\n          if (route) {\n            patches[routeId] = route;\n          }\n        }\n      }\n    }\n    return Response.json(patches, {\n      headers: {\n        \"Cache-Control\": \"public, max-age=31536000, immutable\"\n      }\n    });\n  }\n  return new Response(\"Invalid Request\", { status: 400 });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let response = request.method !== \"GET\" ? await singleFetchAction(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  ) : await singleFetchLoaders(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  );\n  return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n  try {\n    let response = await staticHandler.query(request, {\n      requestContext: loadContext,\n      unstable_respond: build.future.unstable_middleware ? (ctx) => renderHtml(ctx, isSpaMode) : void 0\n    });\n    return isResponse(response) ? response : renderHtml(response, isSpaMode);\n  } catch (error) {\n    handleError(error);\n    return new Response(null, { status: 500 });\n  }\n  async function renderHtml(context, isSpaMode2) {\n    if (isResponse(context)) {\n      return context;\n    }\n    let headers = getDocumentHeaders(context, build);\n    if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!isRouteErrorResponse(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let state = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors, serverMode)\n    };\n    let baseServerHandoff = {\n      basename: build.basename,\n      future: build.future,\n      routeDiscovery: build.routeDiscovery,\n      ssr: build.ssr,\n      isSpaMode: isSpaMode2\n    };\n    let entryContext = {\n      manifest: build.assets,\n      routeModules: createEntryRouteModules(build.routes),\n      staticHandlerContext: context,\n      criticalCss,\n      serverHandoffString: createServerHandoffString({\n        ...baseServerHandoff,\n        criticalCss\n      }),\n      serverHandoffStream: encodeViaTurboStream(\n        state,\n        request.signal,\n        build.entry.module.streamTimeout,\n        serverMode\n      ),\n      renderMeta: {},\n      future: build.future,\n      ssr: build.ssr,\n      routeDiscovery: build.routeDiscovery,\n      isSpaMode: isSpaMode2,\n      serializeError: (err) => serializeError(err, serverMode)\n    };\n    let handleDocumentRequestFunction = build.entry.module.default;\n    try {\n      return await handleDocumentRequestFunction(\n        request,\n        context.statusCode,\n        headers,\n        entryContext,\n        loadContext\n      );\n    } catch (error) {\n      handleError(error);\n      let errorForSecondRender = error;\n      if (isResponse(error)) {\n        try {\n          let data2 = await unwrapResponse(error);\n          errorForSecondRender = new ErrorResponseImpl(\n            error.status,\n            error.statusText,\n            data2\n          );\n        } catch (e) {\n        }\n      }\n      context = getStaticContextFromError(\n        staticHandler.dataRoutes,\n        context,\n        errorForSecondRender\n      );\n      if (context.errors) {\n        context.errors = sanitizeErrors(context.errors, serverMode);\n      }\n      let state2 = {\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: serializeErrors(context.errors, serverMode)\n      };\n      entryContext = {\n        ...entryContext,\n        staticHandlerContext: context,\n        serverHandoffString: createServerHandoffString(baseServerHandoff),\n        serverHandoffStream: encodeViaTurboStream(\n          state2,\n          request.signal,\n          build.entry.module.streamTimeout,\n          serverMode\n        ),\n        renderMeta: {}\n      };\n      try {\n        return await handleDocumentRequestFunction(\n          request,\n          context.statusCode,\n          headers,\n          entryContext,\n          loadContext\n        );\n      } catch (error2) {\n        handleError(error2);\n        return returnLastResortErrorResponse(error2, serverMode);\n      }\n    }\n  }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    let response = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext,\n      unstable_respond: build.future.unstable_middleware ? (ctx) => ctx : void 0\n    });\n    if (isResponse(response)) {\n      return response;\n    }\n    if (typeof response === \"string\") {\n      return new Response(response);\n    }\n    return Response.json(response);\n  } catch (error) {\n    if (isResponse(error)) {\n      error.headers.set(\"X-Remix-Catch\", \"yes\");\n      return error;\n    }\n    if (isRouteErrorResponse(error)) {\n      if (error) {\n        handleError(error);\n      }\n      return errorResponseToJson(error, serverMode);\n    }\n    if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n      let newError = new Error(\n        \"Expected a Response to be returned from resource route handler\"\n      );\n      handleError(newError);\n      return returnLastResortErrorResponse(newError, serverMode);\n    }\n    handleError(error);\n    return returnLastResortErrorResponse(error, serverMode);\n  }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n  return Response.json(\n    serializeError(\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      errorResponse.error || new Error(\"Unexpected Server Error\"),\n      serverMode\n    ),\n    {\n      status: errorResponse.status,\n      statusText: errorResponse.statusText,\n      headers: {\n        \"X-Remix-Error\": \"yes\"\n      }\n    }\n  );\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n  let message = \"Unexpected Server Error\";\n  if (serverMode !== \"production\" /* Production */) {\n    message += `\n\n${String(error)}`;\n  }\n  return new Response(message, {\n    status: 500,\n    headers: {\n      \"Content-Type\": \"text/plain\"\n    }\n  });\n}\nfunction unwrapResponse(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n  return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return void 0;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\nvar isSession = (object) => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && await cookie.parse(cookieHeader, options);\n      let data2 = id && await readData(id);\n      return createSession(data2 || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let { id, data: data2 } = session;\n      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n      if (id) {\n        await updateData(id, data2, expires);\n      } else {\n        id = await createData(data2, expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  warnOnce(\n    cookie.isSigned,\n    `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`\n  );\n}\n\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(\n        cookieHeader && await cookie.parse(cookieHeader, options) || {}\n      );\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\n          \"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length\n        );\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\n\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n  let map = /* @__PURE__ */ new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data2, expires) {\n      let id = Math.random().toString(36).substring(2, 10);\n      map.set(id, { data: data2, expires });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let { data: data2, expires } = map.get(id);\n        if (!expires || expires > /* @__PURE__ */ new Date()) {\n          return data2;\n        }\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data2, expires) {\n      map.set(id, { data: data2, expires });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n}\n\n// lib/href.ts\nfunction href(path, ...args) {\n  let params = args[0];\n  return path.split(\"/\").map((segment) => {\n    if (segment === \"*\") {\n      return params ? params[\"*\"] : void 0;\n    }\n    const match = segment.match(/^:([\\w-]+)(\\?)?/);\n    if (!match) return segment;\n    const param = match[1];\n    const value = params ? params[param] : void 0;\n    const isRequired = match[2] === void 0;\n    if (isRequired && value === void 0) {\n      throw Error(\n        `Path '${path}' requires param '${param}' but it was not provided`\n      );\n    }\n    return value;\n  }).filter((segment) => segment !== void 0).join(\"/\");\n}\n\n// lib/rsc/browser.tsx\nimport * as React4 from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData(state, routes, getRouteInfo, location2, basename, isSpaMode) {\n  let hydrationData = {\n    ...state,\n    loaderData: { ...state.loaderData }\n  };\n  let initialMatches = matchRoutes(routes, location2, basename);\n  if (initialMatches) {\n    for (let match of initialMatches) {\n      let routeId = match.route.id;\n      let routeInfo = getRouteInfo(routeId);\n      if (shouldHydrateRouteLoader(\n        routeId,\n        routeInfo.clientLoader,\n        routeInfo.hasLoader,\n        isSpaMode\n      ) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n        delete hydrationData.loaderData[routeId];\n      } else if (!routeInfo.hasLoader) {\n        hydrationData.loaderData[routeId] = null;\n      }\n    }\n  }\n  return hydrationData;\n}\n\n// lib/rsc/errorBoundaries.tsx\nimport React3 from \"react\";\nvar RSCRouterGlobalErrorBoundary = class extends React3.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: null, location: props.location };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return { error: null, location: props.location };\n    }\n    return { error: state.error, location: state.location };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */ React3.createElement(\n        RSCDefaultRootErrorBoundaryImpl,\n        {\n          error: this.state.error,\n          renderAppShell: true\n        }\n      );\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction ErrorWrapper({\n  renderAppShell,\n  title,\n  children\n}) {\n  if (!renderAppShell) {\n    return children;\n  }\n  return /* @__PURE__ */ React3.createElement(\"html\", { lang: \"en\" }, /* @__PURE__ */ React3.createElement(\"head\", null, /* @__PURE__ */ React3.createElement(\"meta\", { charSet: \"utf-8\" }), /* @__PURE__ */ React3.createElement(\n    \"meta\",\n    {\n      name: \"viewport\",\n      content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }\n  ), /* @__PURE__ */ React3.createElement(\"title\", null, title)), /* @__PURE__ */ React3.createElement(\"body\", null, /* @__PURE__ */ React3.createElement(\"main\", { style: { fontFamily: \"system-ui, sans-serif\", padding: \"2rem\" } }, children)));\n}\nfunction RSCDefaultRootErrorBoundaryImpl({\n  error,\n  renderAppShell\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */ React3.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n      }\n    }\n  );\n  if (isRouteErrorResponse(error)) {\n    return /* @__PURE__ */ React3.createElement(\n      ErrorWrapper,\n      {\n        renderAppShell,\n        title: \"Unhandled Thrown Response!\"\n      },\n      /* @__PURE__ */ React3.createElement(\"h1\", { style: { fontSize: \"24px\" } }, error.status, \" \", error.statusText),\n      ENABLE_DEV_WARNINGS ? heyDeveloper : null\n    );\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */ React3.createElement(ErrorWrapper, { renderAppShell, title: \"Application Error!\" }, /* @__PURE__ */ React3.createElement(\"h1\", { style: { fontSize: \"24px\" } }, \"Application Error\"), /* @__PURE__ */ React3.createElement(\n    \"pre\",\n    {\n      style: {\n        padding: \"2rem\",\n        background: \"hsla(10, 50%, 50%, 0.1)\",\n        color: \"red\",\n        overflow: \"auto\"\n      }\n    },\n    errorInstance.stack\n  ), heyDeveloper);\n}\nfunction RSCDefaultRootErrorBoundary({\n  hasRootLayout\n}) {\n  let error = useRouteError();\n  if (hasRootLayout === void 0) {\n    throw new Error(\"Missing 'hasRootLayout' prop\");\n  }\n  return /* @__PURE__ */ React3.createElement(\n    RSCDefaultRootErrorBoundaryImpl,\n    {\n      renderAppShell: !hasRootLayout,\n      error\n    }\n  );\n}\n\n// lib/rsc/browser.tsx\nfunction createCallServer({\n  createFromReadableStream,\n  createTemporaryReferenceSet,\n  encodeReply,\n  fetch: fetchImplementation = fetch\n}) {\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const response = await fetchImplementation(\n      new Request(location.href, {\n        body: await encodeReply(args, { temporaryReferences }),\n        method: \"POST\",\n        headers: {\n          Accept: \"text/x-component\",\n          \"rsc-action-id\": id\n        }\n      })\n    );\n    if (!response.body) {\n      throw new Error(\"No response body\");\n    }\n    const payload = await createFromReadableStream(response.body, {\n      temporaryReferences\n    });\n    if (payload.type === \"redirect\") {\n      if (payload.reload) {\n        window.location.href = payload.location;\n        return;\n      }\n      globalVar.__router.navigate(payload.location, {\n        replace: payload.replace\n      });\n      return payload.actionResult;\n    }\n    if (payload.type !== \"action\") {\n      throw new Error(\"Unexpected payload type\");\n    }\n    if (payload.rerender) {\n      React4.startTransition(\n        // @ts-expect-error - We have old react types that don't know this can be async\n        async () => {\n          const rerender = await payload.rerender;\n          if (!rerender) return;\n          if (landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n            landedActionId = actionId;\n            if (rerender.type === \"redirect\") {\n              if (rerender.reload) {\n                window.location.href = rerender.location;\n                return;\n              }\n              globalVar.__router.navigate(rerender.location, {\n                replace: rerender.replace\n              });\n              return;\n            }\n            let lastMatch;\n            for (const match of rerender.matches) {\n              globalVar.__router.patchRoutes(\n                lastMatch?.id ?? null,\n                [createRouteFromServerManifest(match)],\n                true\n              );\n              lastMatch = match;\n            }\n            window.__router._internalSetStateDoNotUseOrYouWillBreakYourApp({});\n            React4.startTransition(() => {\n              window.__router._internalSetStateDoNotUseOrYouWillBreakYourApp({\n                loaderData: Object.assign(\n                  {},\n                  globalVar.__router.state.loaderData,\n                  rerender.loaderData\n                ),\n                errors: rerender.errors ? Object.assign(\n                  {},\n                  globalVar.__router.state.errors,\n                  rerender.errors\n                ) : null\n              });\n            });\n          }\n        }\n      );\n    }\n    return payload.actionResult;\n  };\n}\nfunction createRouterFromPayload({\n  fetchImplementation,\n  createFromReadableStream,\n  unstable_getContext,\n  payload\n}) {\n  const globalVar = window;\n  if (globalVar.__router) return globalVar.__router;\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let patches = /* @__PURE__ */ new Map();\n  payload.patches?.forEach((patch) => {\n    invariant(patch.parentId, \"Invalid patch parentId\");\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n    patches.get(patch.parentId)?.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(\n      match,\n      payload\n    );\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n      if (childrenToPatch) {\n        route.children.push(\n          ...childrenToPatch.map((r) => createRouteFromServerManifest(r))\n        );\n      }\n    }\n    return [route];\n  }, []);\n  globalVar.__router = createRouter({\n    routes,\n    unstable_getContext,\n    basename: payload.basename,\n    history: createBrowserHistory(),\n    hydrationData: getHydrationData(\n      {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      (routeId) => {\n        let match = payload.matches.find((m) => m.id === routeId);\n        invariant(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      payload.location,\n      void 0,\n      false\n    ),\n    async patchRoutesOnNavigation({ path, signal }) {\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n      await fetchAndApplyManifestPatches(\n        [path],\n        createFromReadableStream,\n        fetchImplementation,\n        signal\n      );\n    },\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(\n      () => globalVar.__router,\n      true,\n      payload.basename,\n      createFromReadableStream,\n      fetchImplementation\n    )\n  });\n  if (globalVar.__router.state.initialized) {\n    globalVar.__routerInitialized = true;\n    globalVar.__router.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n  let lastLoaderData = void 0;\n  globalVar.__router.subscribe(({ loaderData, actionData }) => {\n    if (lastLoaderData !== loaderData) {\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    }\n  });\n  return globalVar.__router;\n}\nvar renderedRoutesContext = unstable_createContext();\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(\n    getRouter,\n    (match) => {\n      let M = match;\n      return {\n        hasLoader: M.route.hasLoader,\n        hasClientLoader: M.route.hasClientLoader,\n        hasComponent: M.route.hasComponent,\n        hasAction: M.route.hasAction,\n        hasClientAction: M.route.hasClientAction,\n        hasShouldRevalidate: M.route.hasShouldRevalidate\n      };\n    },\n    // pass map into fetchAndDecode so it can add payloads\n    getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation),\n    ssr,\n    basename,\n    // If the route has a component but we don't have an element, we need to hit\n    // the server loader flow regardless of whether the client loader calls\n    // `serverLoader` or not, otherwise we'll have nothing to render.\n    (match) => {\n      let M = match;\n      return M.route.hasComponent && !M.route.element;\n    }\n  );\n  return async (args) => args.unstable_runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */ new Map();\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n      renderedRoutesById.get(route.id).push(route);\n    }\n    for (const match of args.matches) {\n      const renderedRoutes = renderedRoutesById.get(match.route.id);\n      if (renderedRoutes) {\n        for (const rendered of renderedRoutes) {\n          window.__router.patchRoutes(\n            rendered.parentId ?? null,\n            [createRouteFromServerManifest(rendered)],\n            true\n          );\n        }\n      }\n    }\n    return results;\n  });\n}\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, targetRoutes) => {\n    let { request, context } = args;\n    let url = singleFetchUrl(request.url, basename, \"rsc\");\n    if (request.method === \"GET\") {\n      url = stripIndexParam(url);\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n    let res = await fetchImplementation(\n      new Request(url, await createRequestInit(request))\n    );\n    if (res.status === 404 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new ErrorResponseImpl(404, \"Not Found\", true);\n    }\n    invariant(res.body, \"No response body to decode\");\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = { routes: {} };\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\n      for (let [routeId, data2] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = { data: data2 };\n      }\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = { error };\n        }\n      }\n      return { status: res.status, data: results };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\nfunction RSCHydratedRouter({\n  createFromReadableStream,\n  fetch: fetchImplementation = fetch,\n  payload,\n  routeDiscovery = \"eager\",\n  unstable_getContext\n}) {\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let router = React4.useMemo(\n    () => createRouterFromPayload({\n      payload,\n      fetchImplementation,\n      unstable_getContext,\n      createFromReadableStream\n    }),\n    [\n      createFromReadableStream,\n      payload,\n      fetchImplementation,\n      unstable_getContext\n    ]\n  );\n  React4.useLayoutEffect(() => {\n    const globalVar = window;\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n      globalVar.__router.initialize();\n    }\n  }, []);\n  let [location2, setLocation] = React4.useState(router.state.location);\n  React4.useLayoutEffect(\n    () => router.subscribe((newState) => {\n      if (newState.location !== location2) {\n        setLocation(newState.location);\n      }\n    }),\n    [router, location2]\n  );\n  React4.useEffect(() => {\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (paths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          paths,\n          createFromReadableStream,\n          fetchImplementation\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      unstable_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: true,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules: {}\n  };\n  return /* @__PURE__ */ React4.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React4.createElement(RSCRouterGlobalErrorBoundary, { location: location2 }, /* @__PURE__ */ React4.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React4.createElement(RouterProvider, { router, flushSync: ReactDOM.flushSync }))));\n}\nfunction createRouteFromServerManifest(match, payload) {\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload?.loaderData[match.id];\n  let hasInitialError = payload?.errors && match.id in payload.errors;\n  let initialError = payload?.errors?.[match.id];\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader({\n          ...args,\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\n              \"loader\",\n              match.id,\n              match.hasLoader\n            );\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n            return callSingleFetch(singleFetch);\n          }\n        });\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } : (\n      // We always make the call in this RSC world since even if we don't\n      // have a `loader` we may need to get the `element` implementation\n      (_, singleFetch) => callSingleFetch(singleFetch)\n    ),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\n      ...args,\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\n          \"action\",\n          match.id,\n          match.hasLoader\n        );\n        return await callSingleFetch(singleFetch);\n      }\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw noActionDefinedError(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    );\n  }\n  return dataRoute;\n}\nfunction callSingleFetch(singleFetch) {\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction getManifestUrl(paths) {\n  if (paths.length === 0) {\n    return null;\n  }\n  if (paths.length === 1) {\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\n  }\n  const globalVar = window;\n  let basename = (globalVar.__router.basename ?? \"\").replace(/^\\/|\\/$/g, \"\");\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\n  paths.sort().forEach((path) => url.searchParams.append(\"p\", path));\n  return url;\n}\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n  if (url == null) {\n    return;\n  }\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let response = await fetchImplementation(new Request(url, { signal }));\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  payload.patches.forEach((p) => {\n    window.__router.patchRoutes(\n      p.parentId ?? null,\n      [createRouteFromServerManifest(p)]\n    );\n  });\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\n\n// lib/rsc/server.ssr.tsx\nimport * as React5 from \"react\";\n\n// lib/rsc/html-stream/server.ts\nvar encoder2 = new TextEncoder();\nvar trailer = \"</body></html>\";\nfunction injectRSCPayload(rscStream) {\n  let decoder = new TextDecoder();\n  let resolveFlightDataPromise;\n  let flightDataPromise = new Promise(\n    (resolve) => resolveFlightDataPromise = resolve\n  );\n  let startedRSC = false;\n  let buffered = [];\n  let timeout = null;\n  function flushBufferedChunks(controller) {\n    for (let chunk of buffered) {\n      let buf = decoder.decode(chunk, { stream: true });\n      if (buf.endsWith(trailer)) {\n        buf = buf.slice(0, -trailer.length);\n      }\n      controller.enqueue(encoder2.encode(buf));\n    }\n    buffered.length = 0;\n    timeout = null;\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      buffered.push(chunk);\n      if (timeout) {\n        return;\n      }\n      timeout = setTimeout(async () => {\n        flushBufferedChunks(controller);\n        if (!startedRSC) {\n          startedRSC = true;\n          writeRSCStream(rscStream, controller).catch((err) => controller.error(err)).then(resolveFlightDataPromise);\n        }\n      }, 0);\n    },\n    async flush(controller) {\n      await flightDataPromise;\n      if (timeout) {\n        clearTimeout(timeout);\n        flushBufferedChunks(controller);\n      }\n      controller.enqueue(encoder2.encode(\"</body></html>\"));\n    }\n  });\n}\nasync function writeRSCStream(rscStream, controller) {\n  let decoder = new TextDecoder(\"utf-8\", { fatal: true });\n  const reader = rscStream.getReader();\n  try {\n    let read;\n    while ((read = await reader.read()) && !read.done) {\n      const chunk = read.value;\n      try {\n        writeChunk(\n          JSON.stringify(decoder.decode(chunk, { stream: true })),\n          controller\n        );\n      } catch (err) {\n        let base64 = JSON.stringify(btoa(String.fromCodePoint(...chunk)));\n        writeChunk(\n          `Uint8Array.from(atob(${base64}), m => m.codePointAt(0))`,\n          controller\n        );\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  let remaining = decoder.decode();\n  if (remaining.length) {\n    writeChunk(JSON.stringify(remaining), controller);\n  }\n}\nfunction writeChunk(chunk, controller) {\n  controller.enqueue(\n    encoder2.encode(\n      `<script>${escapeScript(\n        `(self.__FLIGHT_DATA||=[]).push(${chunk})`\n      )}</script>`\n    )\n  );\n}\nfunction escapeScript(script) {\n  return script.replace(/<!--/g, \"<\\\\!--\").replace(/<\\/(script)/gi, \"</\\\\$1\");\n}\n\n// lib/rsc/server.ssr.tsx\nasync function routeRSCServerRequest({\n  request,\n  fetchServer,\n  createFromReadableStream,\n  renderHTML,\n  hydrate = true\n}) {\n  const url = new URL(request.url);\n  const isDataRequest = isReactServerRequest(url);\n  const respondWithRSCPayload = isDataRequest || isManifestRequest(url) || request.headers.has(\"rsc-action-id\");\n  const serverResponse = await fetchServer(request);\n  if (respondWithRSCPayload || serverResponse.headers.get(\"React-Router-Resource\") === \"true\") {\n    return serverResponse;\n  }\n  if (!serverResponse.body) {\n    throw new Error(\"Missing body in server response\");\n  }\n  let serverResponseB = null;\n  if (hydrate) {\n    serverResponseB = serverResponse.clone();\n  }\n  const body = serverResponse.body;\n  let payloadPromise;\n  const getPayload = async () => {\n    if (payloadPromise) return payloadPromise;\n    payloadPromise = createFromReadableStream(body);\n    return payloadPromise;\n  };\n  try {\n    const html = await renderHTML(getPayload);\n    const headers = new Headers(serverResponse.headers);\n    headers.set(\"Content-Type\", \"text/html\");\n    if (!hydrate) {\n      return new Response(html, {\n        status: serverResponse.status,\n        headers\n      });\n    }\n    if (!serverResponseB?.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n    return new Response(body2, {\n      status: serverResponse.status,\n      headers\n    });\n  } catch (reason) {\n    if (reason instanceof Response) {\n      return reason;\n    }\n    throw reason;\n  }\n}\nfunction RSCStaticRouter({ getPayload }) {\n  const payload = React5.use(getPayload());\n  if (payload.type === \"redirect\") {\n    throw new Response(null, {\n      status: payload.status,\n      headers: {\n        Location: payload.location\n      }\n    });\n  }\n  if (payload.type !== \"render\") return null;\n  let patchedLoaderData = { ...payload.loaderData };\n  for (const match of payload.matches) {\n    if (shouldHydrateRouteLoader(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    ) && (match.hydrateFallbackElement || !match.hasLoader)) {\n      delete patchedLoaderData[match.id];\n    }\n  }\n  const context = {\n    actionData: payload.actionData,\n    actionHeaders: {},\n    basename: payload.basename,\n    errors: payload.errors,\n    loaderData: patchedLoaderData,\n    loaderHeaders: {},\n    location: payload.location,\n    statusCode: 200,\n    matches: payload.matches.map((match) => ({\n      params: match.params,\n      pathname: match.pathname,\n      pathnameBase: match.pathnameBase,\n      route: {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        handle: match.handle,\n        hasErrorBoundary: match.hasErrorBoundary,\n        loader: match.hasLoader || !!match.clientLoader,\n        index: match.index,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      }\n    }))\n  };\n  const router = createStaticRouter(\n    payload.matches.reduceRight((previous, match) => {\n      const route = {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        element: match.element,\n        errorElement: match.errorElement,\n        handle: match.handle,\n        hasErrorBoundary: !!match.errorElement,\n        hydrateFallbackElement: match.hydrateFallbackElement,\n        index: match.index,\n        loader: match.hasLoader || !!match.clientLoader,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      };\n      if (previous.length > 0) {\n        route.children = previous;\n      }\n      return [route];\n    }, []),\n    context\n  );\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      unstable_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules: {}\n  };\n  return /* @__PURE__ */ React5.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React5.createElement(RSCRouterGlobalErrorBoundary, { location: payload.location }, /* @__PURE__ */ React5.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React5.createElement(\n    StaticRouterProvider,\n    {\n      context,\n      router,\n      hydrate: false,\n      nonce: payload.nonce\n    }\n  ))));\n}\nfunction isReactServerRequest(url) {\n  return url.pathname.endsWith(\".rsc\");\n}\nfunction isManifestRequest(url) {\n  return url.pathname.endsWith(\".manifest\");\n}\n\n// lib/rsc/html-stream/browser.ts\nfunction getRSCStream() {\n  let encoder3 = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      let handleChunk = (chunk) => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder3.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n      window.__FLIGHT_DATA.forEach(handleChunk);\n      window.__FLIGHT_DATA.push = (chunk) => {\n        handleChunk(chunk);\n        return 0;\n      };\n      streamController = controller;\n    }\n  });\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      streamController?.close();\n    });\n  } else {\n    streamController?.close();\n  }\n  return rscStream;\n}\n\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexport {\n  ServerRouter,\n  createRoutesStub,\n  createCookie,\n  isCookie,\n  ServerMode,\n  setDevServerHooks,\n  createRequestHandler,\n  createSession,\n  isSession,\n  createSessionStorage,\n  createCookieSessionStorage,\n  createMemorySessionStorage,\n  href,\n  getHydrationData,\n  RSCDefaultRootErrorBoundary,\n  createCallServer,\n  RSCHydratedRouter,\n  routeRSCServerRequest,\n  RSCStaticRouter,\n  getRSCStream,\n  deserializeErrors\n};\n", "/**\n * react-router v7.7.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\"use client\";\nimport {\n  deserializeErrors,\n  getHydrationData\n} from \"./chunk-KIUJAIYX.mjs\";\nimport {\n  CRITICAL_CSS_DATA_ATTRIBUTE,\n  FrameworkContext,\n  RemixErrorBoundary,\n  RouterProvider,\n  createBrowserHistory,\n  createClientRoutes,\n  createClientRoutesWithHMRRevalidationOptOut,\n  createRouter,\n  decodeViaTurboStream,\n  getPatchRoutesOnNavigationFunction,\n  getTurboStreamSingleFetchDataStrategy,\n  hydrationRouteProperties,\n  invariant,\n  mapRouteProperties,\n  useFogOFWarDiscovery\n} from \"./chunk-C37GKA54.mjs\";\n\n// lib/dom-export/dom-router-provider.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nfunction RouterProvider2(props) {\n  return /* @__PURE__ */ React.createElement(RouterProvider, { flushSync: ReactDOM.flushSync, ...props });\n}\n\n// lib/dom-export/hydrated-router.tsx\nimport * as React2 from \"react\";\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n    if (window.__reactRouterManifest.sri === true) {\n      const importMap = document.querySelector(\"script[rr-importmap]\");\n      if (importMap?.textContent) {\n        try {\n          window.__reactRouterManifest.sri = JSON.parse(\n            importMap.textContent\n          ).integrity;\n        } catch (err) {\n          console.error(\"Failed to parse import map\", err);\n        }\n      }\n    }\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: void 0,\n      router: void 0,\n      routerInitialized: false\n    };\n  }\n}\nfunction createHydratedRouter({\n  unstable_getContext\n}) {\n  initSsrInfo();\n  if (!ssrInfo) {\n    throw new Error(\n      \"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\"\n    );\n  }\n  let localSsrInfo = ssrInfo;\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = void 0;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {\n      ssrInfo.context.state = value.value;\n      localSsrInfo.stateDecodingPromise.value = true;\n    }).catch((e) => {\n      localSsrInfo.stateDecodingPromise.error = e;\n    });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n  let routes = createClientRoutes(\n    ssrInfo.manifest.routes,\n    ssrInfo.routeModules,\n    ssrInfo.context.state,\n    ssrInfo.context.ssr,\n    ssrInfo.context.isSpaMode\n  );\n  let hydrationData = void 0;\n  if (ssrInfo.context.isSpaMode) {\n    let { loaderData } = ssrInfo.context.state;\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n      hydrationData = {\n        loaderData: {\n          root: loaderData.root\n        }\n      };\n    }\n  } else {\n    hydrationData = getHydrationData(\n      ssrInfo.context.state,\n      routes,\n      (routeId) => ({\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n      }),\n      window.location,\n      window.__reactRouterContext?.basename,\n      ssrInfo.context.isSpaMode\n    );\n    if (hydrationData && hydrationData.errors) {\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n  let router2 = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    unstable_getContext,\n    hydrationData,\n    hydrationRouteProperties,\n    mapRouteProperties,\n    future: {\n      unstable_middleware: ssrInfo.context.future.unstable_middleware\n    },\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(\n      () => router2,\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.ssr,\n      ssrInfo.context.basename\n    ),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.ssr,\n      ssrInfo.context.routeDiscovery,\n      ssrInfo.context.isSpaMode,\n      ssrInfo.context.basename\n    )\n  });\n  ssrInfo.router = router2;\n  if (router2.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router2.initialize();\n  }\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\n  createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router2;\n  return router2;\n}\nfunction HydratedRouter(props) {\n  if (!router) {\n    router = createHydratedRouter({\n      unstable_getContext: props.unstable_getContext\n    });\n  }\n  let [criticalCss, setCriticalCss] = React2.useState(\n    process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0\n  );\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      setCriticalCss(void 0);\n    }\n  }, []);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());\n    }\n  }, [criticalCss]);\n  let [location, setLocation] = React2.useState(router.state.location);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe((newState) => {\n        if (newState.location !== location) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location]);\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n  useFogOFWarDiscovery(\n    router,\n    ssrInfo.manifest,\n    ssrInfo.routeModules,\n    ssrInfo.context.ssr,\n    ssrInfo.context.routeDiscovery,\n    ssrInfo.context.isSpaMode\n  );\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\n      FrameworkContext.Provider,\n      {\n        value: {\n          manifest: ssrInfo.manifest,\n          routeModules: ssrInfo.routeModules,\n          future: ssrInfo.context.future,\n          criticalCss,\n          ssr: ssrInfo.context.ssr,\n          isSpaMode: ssrInfo.context.isSpaMode,\n          routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n      },\n      /* @__PURE__ */ React2.createElement(RemixErrorBoundary, { location }, /* @__PURE__ */ React2.createElement(RouterProvider2, { router }))\n    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))\n  );\n}\nexport {\n  HydratedRouter,\n  RouterProvider2 as RouterProvider\n};\n", null, null, "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext, createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { createSlot } from '@radix-ui/react-slot';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Dialog\n * -----------------------------------------------------------------------------------------------*/\n\nconst DIALOG_NAME = 'Dialog';\n\ntype ScopedProps<P> = P & { __scopeDialog?: Scope };\nconst [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);\n\ntype DialogContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement | null>;\n  contentRef: React.RefObject<DialogContentElement | null>;\n  contentId: string;\n  titleId: string;\n  descriptionId: string;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal: boolean;\n};\n\nconst [DialogProvider, useDialogContext] = createDialogContext<DialogContextValue>(DIALOG_NAME);\n\ninterface DialogProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  modal?: boolean;\n}\n\nconst Dialog: React.FC<DialogProps> = (props: ScopedProps<DialogProps>) => {\n  const {\n    __scopeDialog,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    modal = true,\n  } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentRef = React.useRef<DialogContentElement>(null);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: DIALOG_NAME,\n  });\n\n  return (\n    <DialogProvider\n      scope={__scopeDialog}\n      triggerRef={triggerRef}\n      contentRef={contentRef}\n      contentId={useId()}\n      titleId={useId()}\n      descriptionId={useId()}\n      open={open}\n      onOpenChange={setOpen}\n      onOpenToggle={React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen])}\n      modal={modal}\n    >\n      {children}\n    </DialogProvider>\n  );\n};\n\nDialog.displayName = DIALOG_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'DialogTrigger';\n\ntype DialogTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface DialogTriggerProps extends PrimitiveButtonProps {}\n\nconst DialogTrigger = React.forwardRef<DialogTriggerElement, DialogTriggerProps>(\n  (props: ScopedProps<DialogTriggerProps>, forwardedRef) => {\n    const { __scopeDialog, ...triggerProps } = props;\n    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n    return (\n      <Primitive.button\n        type=\"button\"\n        aria-haspopup=\"dialog\"\n        aria-expanded={context.open}\n        aria-controls={context.contentId}\n        data-state={getState(context.open)}\n        {...triggerProps}\n        ref={composedTriggerRef}\n        onClick={composeEventHandlers(props.onClick, context.onOpenToggle)}\n      />\n    );\n  }\n);\n\nDialogTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'DialogPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createDialogContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface DialogPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogPortal: React.FC<DialogPortalProps> = (props: ScopedProps<DialogPortalProps>) => {\n  const { __scopeDialog, forceMount, children, container } = props;\n  const context = useDialogContext(PORTAL_NAME, __scopeDialog);\n  return (\n    <PortalProvider scope={__scopeDialog} forceMount={forceMount}>\n      {React.Children.map(children, (child) => (\n        <Presence present={forceMount || context.open}>\n          <PortalPrimitive asChild container={container}>\n            {child}\n          </PortalPrimitive>\n        </Presence>\n      ))}\n    </PortalProvider>\n  );\n};\n\nDialogPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogOverlay\n * -----------------------------------------------------------------------------------------------*/\n\nconst OVERLAY_NAME = 'DialogOverlay';\n\ntype DialogOverlayElement = DialogOverlayImplElement;\ninterface DialogOverlayProps extends DialogOverlayImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogOverlay = React.forwardRef<DialogOverlayElement, DialogOverlayProps>(\n  (props: ScopedProps<DialogOverlayProps>, forwardedRef) => {\n    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);\n    const { forceMount = portalContext.forceMount, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);\n    return context.modal ? (\n      <Presence present={forceMount || context.open}>\n        <DialogOverlayImpl {...overlayProps} ref={forwardedRef} />\n      </Presence>\n    ) : null;\n  }\n);\n\nDialogOverlay.displayName = OVERLAY_NAME;\n\ntype DialogOverlayImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DialogOverlayImplProps extends PrimitiveDivProps {}\n\nconst Slot = createSlot('DialogOverlay.RemoveScroll');\n\nconst DialogOverlayImpl = React.forwardRef<DialogOverlayImplElement, DialogOverlayImplProps>(\n  (props: ScopedProps<DialogOverlayImplProps>, forwardedRef) => {\n    const { __scopeDialog, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);\n    return (\n      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`\n      // ie. when `Overlay` and `Content` are siblings\n      <RemoveScroll as={Slot} allowPinchZoom shards={[context.contentRef]}>\n        <Primitive.div\n          data-state={getState(context.open)}\n          {...overlayProps}\n          ref={forwardedRef}\n          // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.\n          style={{ pointerEvents: 'auto', ...overlayProps.style }}\n        />\n      </RemoveScroll>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * DialogContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'DialogContent';\n\ntype DialogContentElement = DialogContentTypeElement;\ninterface DialogContentProps extends DialogContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogContent = React.forwardRef<DialogContentElement, DialogContentProps>(\n  (props: ScopedProps<DialogContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    return (\n      <Presence present={forceMount || context.open}>\n        {context.modal ? (\n          <DialogContentModal {...contentProps} ref={forwardedRef} />\n        ) : (\n          <DialogContentNonModal {...contentProps} ref={forwardedRef} />\n        )}\n      </Presence>\n    );\n  }\n);\n\nDialogContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DialogContentTypeElement = DialogContentImplElement;\ninterface DialogContentTypeProps\n  extends Omit<DialogContentImplProps, 'trapFocus' | 'disableOutsidePointerEvents'> {}\n\nconst DialogContentModal = React.forwardRef<DialogContentTypeElement, DialogContentTypeProps>(\n  (props: ScopedProps<DialogContentTypeProps>, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);\n\n    // aria-hide everything except the content (better supported equivalent to setting aria-modal)\n    React.useEffect(() => {\n      const content = contentRef.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <DialogContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure focus isn't trapped once `DialogContent` has been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        disableOutsidePointerEvents\n        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          event.preventDefault();\n          context.triggerRef.current?.focus();\n        })}\n        onPointerDownOutside={composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const originalEvent = event.detail.originalEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n\n          // If the event is a right-click, we shouldn't close because\n          // it is effectively as if we right-clicked the `Overlay`.\n          if (isRightClick) event.preventDefault();\n        })}\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) =>\n          event.preventDefault()\n        )}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst DialogContentNonModal = React.forwardRef<DialogContentTypeElement, DialogContentTypeProps>(\n  (props: ScopedProps<DialogContentTypeProps>, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const hasInteractedOutsideRef = React.useRef(false);\n    const hasPointerDownOutsideRef = React.useRef(false);\n\n    return (\n      <DialogContentImpl\n        {...props}\n        ref={forwardedRef}\n        trapFocus={false}\n        disableOutsidePointerEvents={false}\n        onCloseAutoFocus={(event) => {\n          props.onCloseAutoFocus?.(event);\n\n          if (!event.defaultPrevented) {\n            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n            // Always prevent auto focus because we either focus manually or want user agent focus\n            event.preventDefault();\n          }\n\n          hasInteractedOutsideRef.current = false;\n          hasPointerDownOutsideRef.current = false;\n        }}\n        onInteractOutside={(event) => {\n          props.onInteractOutside?.(event);\n\n          if (!event.defaultPrevented) {\n            hasInteractedOutsideRef.current = true;\n            if (event.detail.originalEvent.type === 'pointerdown') {\n              hasPointerDownOutsideRef.current = true;\n            }\n          }\n\n          // Prevent dismissing when clicking the trigger.\n          // As the trigger is already setup to close, without doing so would\n          // cause it to close and immediately open.\n          const target = event.target as HTMLElement;\n          const targetIsTrigger = context.triggerRef.current?.contains(target);\n          if (targetIsTrigger) event.preventDefault();\n\n          // On Safari if the trigger is inside a container with tabIndex={0}, when clicked\n          // we will get the pointer down outside event on the trigger, but then a subsequent\n          // focus outside event on the container, we ignore any focus outside event when we've\n          // already had a pointer down outside event.\n          if (event.detail.originalEvent.type === 'focusin' && hasPointerDownOutsideRef.current) {\n            event.preventDefault();\n          }\n        }}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DialogContentImplElement = React.ComponentRef<typeof DismissableLayer>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ninterface DialogContentImplProps extends Omit<DismissableLayerProps, 'onDismiss'> {\n  /**\n   * When `true`, focus cannot escape the `Content` via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n\n  /**\n   * Event handler called when auto-focusing on open.\n   * Can be prevented.\n   */\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n}\n\nconst DialogContentImpl = React.forwardRef<DialogContentImplElement, DialogContentImplProps>(\n  (props: ScopedProps<DialogContentImplProps>, forwardedRef) => {\n    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, __scopeDialog);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef);\n\n    // Make sure the whole tree has focus guards as our `Dialog` will be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    return (\n      <>\n        <FocusScope\n          asChild\n          loop\n          trapped={trapFocus}\n          onMountAutoFocus={onOpenAutoFocus}\n          onUnmountAutoFocus={onCloseAutoFocus}\n        >\n          <DismissableLayer\n            role=\"dialog\"\n            id={context.contentId}\n            aria-describedby={context.descriptionId}\n            aria-labelledby={context.titleId}\n            data-state={getState(context.open)}\n            {...contentProps}\n            ref={composedRefs}\n            onDismiss={() => context.onOpenChange(false)}\n          />\n        </FocusScope>\n        {process.env.NODE_ENV !== 'production' && (\n          <>\n            <TitleWarning titleId={context.titleId} />\n            <DescriptionWarning contentRef={contentRef} descriptionId={context.descriptionId} />\n          </>\n        )}\n      </>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * DialogTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'DialogTitle';\n\ntype DialogTitleElement = React.ComponentRef<typeof Primitive.h2>;\ntype PrimitiveHeading2Props = React.ComponentPropsWithoutRef<typeof Primitive.h2>;\ninterface DialogTitleProps extends PrimitiveHeading2Props {}\n\nconst DialogTitle = React.forwardRef<DialogTitleElement, DialogTitleProps>(\n  (props: ScopedProps<DialogTitleProps>, forwardedRef) => {\n    const { __scopeDialog, ...titleProps } = props;\n    const context = useDialogContext(TITLE_NAME, __scopeDialog);\n    return <Primitive.h2 id={context.titleId} {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nDialogTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'DialogDescription';\n\ntype DialogDescriptionElement = React.ComponentRef<typeof Primitive.p>;\ntype PrimitiveParagraphProps = React.ComponentPropsWithoutRef<typeof Primitive.p>;\ninterface DialogDescriptionProps extends PrimitiveParagraphProps {}\n\nconst DialogDescription = React.forwardRef<DialogDescriptionElement, DialogDescriptionProps>(\n  (props: ScopedProps<DialogDescriptionProps>, forwardedRef) => {\n    const { __scopeDialog, ...descriptionProps } = props;\n    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);\n    return <Primitive.p id={context.descriptionId} {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nDialogDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'DialogClose';\n\ntype DialogCloseElement = React.ComponentRef<typeof Primitive.button>;\ninterface DialogCloseProps extends PrimitiveButtonProps {}\n\nconst DialogClose = React.forwardRef<DialogCloseElement, DialogCloseProps>(\n  (props: ScopedProps<DialogCloseProps>, forwardedRef) => {\n    const { __scopeDialog, ...closeProps } = props;\n    const context = useDialogContext(CLOSE_NAME, __scopeDialog);\n    return (\n      <Primitive.button\n        type=\"button\"\n        {...closeProps}\n        ref={forwardedRef}\n        onClick={composeEventHandlers(props.onClick, () => context.onOpenChange(false))}\n      />\n    );\n  }\n);\n\nDialogClose.displayName = CLOSE_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nconst TITLE_WARNING_NAME = 'DialogTitleWarning';\n\nconst [WarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {\n  contentName: CONTENT_NAME,\n  titleName: TITLE_NAME,\n  docsSlug: 'dialog',\n});\n\ntype TitleWarningProps = { titleId?: string };\n\nconst TitleWarning: React.FC<TitleWarningProps> = ({ titleId }) => {\n  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);\n\n  const MESSAGE = `\\`${titleWarningContext.contentName}\\` requires a \\`${titleWarningContext.titleName}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${titleWarningContext.titleName}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;\n\n  React.useEffect(() => {\n    if (titleId) {\n      const hasTitle = document.getElementById(titleId);\n      if (!hasTitle) console.error(MESSAGE);\n    }\n  }, [MESSAGE, titleId]);\n\n  return null;\n};\n\nconst DESCRIPTION_WARNING_NAME = 'DialogDescriptionWarning';\n\ntype DescriptionWarningProps = {\n  contentRef: React.RefObject<DialogContentElement | null>;\n  descriptionId?: string;\n};\n\nconst DescriptionWarning: React.FC<DescriptionWarningProps> = ({ contentRef, descriptionId }) => {\n  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);\n  const MESSAGE = `Warning: Missing \\`Description\\` or \\`aria-describedby={undefined}\\` for {${descriptionWarningContext.contentName}}.`;\n\n  React.useEffect(() => {\n    const describedById = contentRef.current?.getAttribute('aria-describedby');\n    // if we have an id and the user hasn't set aria-describedby={undefined}\n    if (descriptionId && describedById) {\n      const hasDescription = document.getElementById(descriptionId);\n      if (!hasDescription) console.warn(MESSAGE);\n    }\n  }, [MESSAGE, contentRef, descriptionId]);\n\n  return null;\n};\n\nconst Root = Dialog;\nconst Trigger = DialogTrigger;\nconst Portal = DialogPortal;\nconst Overlay = DialogOverlay;\nconst Content = DialogContent;\nconst Title = DialogTitle;\nconst Description = DialogDescription;\nconst Close = DialogClose;\n\nexport {\n  createDialogScope,\n  //\n  Dialog,\n  DialogTrigger,\n  DialogPortal,\n  DialogOverlay,\n  DialogContent,\n  DialogTitle,\n  DialogDescription,\n  DialogClose,\n  //\n  Root,\n  Trigger,\n  Portal,\n  Overlay,\n  Content,\n  Title,\n  Description,\n  Close,\n  //\n  WarningProvider,\n};\nexport type {\n  DialogProps,\n  DialogTriggerProps,\n  DialogPortalProps,\n  DialogOverlayProps,\n  DialogContentProps,\n  DialogTitleProps,\n  DialogDescriptionProps,\n  DialogCloseProps,\n};\n", "function composeEventHandlers<E extends { defaultPrevented: boolean }>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n", "import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n", "import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We spaces with `.trim().toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)[' useId '.trim().toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\nexport { useId };\n", "import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// Prevent bundlers from trying to optimize the import\nconst useInsertionEffect: typeof useLayoutEffect =\n  (React as any)[' useInsertionEffect '.trim().toString()] || useLayoutEffect;\n\ntype ChangeHandler<T> = (state: T) => void;\ntype SetStateFn<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseControllableStateParams<T> {\n  prop?: T | undefined;\n  defaultProp: T;\n  onChange?: ChangeHandler<T>;\n  caller?: string;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n  caller,\n}: UseControllableStateParams<T>): [T, SetStateFn<T>] {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(prop !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  const setValue = React.useCallback<SetStateFn<T>>(\n    (nextValue) => {\n      if (isControlled) {\n        const value = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value !== prop) {\n          onChangeRef.current?.(value);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n\n  return [value, setValue];\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>): [\n  Value: T,\n  setValue: React.Dispatch<React.SetStateAction<T>>,\n  OnChangeRef: React.RefObject<ChangeHandler<T> | undefined>,\n] {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n\n  return [value, setValue, onChangeRef];\n}\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "import * as React from 'react';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype ChangeHandler<T> = (state: T) => void;\n\ninterface UseControllableStateParams<T> {\n  prop: T | undefined;\n  defaultProp: T;\n  onChange: ChangeHandler<T> | undefined;\n  caller: string;\n}\n\ninterface AnyAction {\n  type: string;\n}\n\nconst SYNC_STATE = Symbol('RADIX:SYNC_STATE');\n\ninterface SyncStateAction<T> {\n  type: typeof SYNC_STATE;\n  state: T;\n}\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialState: S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, I, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: I,\n  init: (i: I & { state: T }) => S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: any,\n  init?: (i: any) => Omit<S, 'state'>\n): [S & { state: T }, React.Dispatch<A>] {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== undefined;\n\n  const onChange = useEffectEvent(onChangeProp);\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(controlledState !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  type InternalState = S & { state: T };\n  const args: [InternalState] = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    // @ts-expect-error\n    args.push(init);\n  }\n\n  const [internalState, dispatch] = React.useReducer(\n    (state: InternalState, action: A | SyncStateAction<T>): InternalState => {\n      if (action.type === SYNC_STATE) {\n        return { ...state, state: action.state };\n      }\n\n      const next = reducer(state, action);\n      if (isControlled && !Object.is(next.state, state.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React.useRef(uncontrolledState);\n  React.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n\n  const state = React.useMemo(() => {\n    const isControlled = controlledState !== undefined;\n    if (isControlled) {\n      return { ...internalState, state: controlledState };\n    }\n\n    return internalState;\n  }, [internalState, controlledState]);\n\n  React.useEffect(() => {\n    // Sync internal state for controlled components so that reducer is called\n    // with the correct state values\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n\n  return [state, dispatch as React.Dispatch<A>];\n}\n", "/* eslint-disable react-hooks/rules-of-hooks */\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport * as React from 'react';\n\ntype AnyFunction = (...args: any[]) => any;\n\n// See https://github.com/webpack/webpack/issues/14814\nconst useReactEffectEvent = (React as any)[' useEffectEvent '.trim().toString()];\nconst useReactInsertionEffect = (React as any)[' useInsertionEffect '.trim().toString()];\n\n/**\n * Designed to approximate the behavior on `experimental_useEffectEvent` as best\n * as possible until its stable release, and back-fill it as a shim as needed.\n */\nexport function useEffectEvent<T extends AnyFunction>(callback?: T): T {\n  if (typeof useReactEffectEvent === 'function') {\n    return useReactEffectEvent(callback);\n  }\n\n  const ref = React.useRef<AnyFunction | undefined>(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  // See https://github.com/webpack/webpack/issues/14814\n  if (typeof useReactInsertionEffect === 'function') {\n    useReactInsertionEffect(() => {\n      ref.current = callback;\n    });\n  } else {\n    useLayoutEffect(() => {\n      ref.current = callback;\n    });\n  }\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => ref.current?.(...args)) as T, []);\n}\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled!); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ComponentRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { createSlot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'select',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not necessary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click \uD83D\uDC4E\n * target.dispatchEvent(new Event(\u2018click\u2019))\n *\n * dispatching a custom type within a non-discrete event \uD83D\uDC4E\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(\u2018customType\u2019))}\n *\n * dispatching a custom type within a `discrete` event \uD83D\uDC4D\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(\u2018customType\u2019))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n", "import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n", "import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nexport { useCallbackRef };\n", "import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\n/**\n * Listens for when the escape key is down\n */\nfunction useEscapeKeydown(\n  onEscapeKeyDownProp?: (event: KeyboardEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        onEscapeKeyDown(event);\n      }\n    };\n    ownerDocument.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => ownerDocument.removeEventListener('keydown', handleKeyDown, { capture: true });\n  }, [onEscapeKeyDown, ownerDocument]);\n}\n\nexport { useEscapeKeydown };\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n", "import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  /**\n   * An optional container where the portaled content should be appended.\n   */\n  container?: Element | DocumentFragment | null;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { container: containerProp, ...portalProps } = props;\n  const [mounted, setMounted] = React.useState(false);\n  useLayoutEffect(() => setMounted(true), []);\n  const container = containerProp || (mounted && globalThis?.document?.body);\n  return container\n    ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n    : null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  //\n  Root,\n};\nexport type { PortalProps };\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './use-state-machine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration | null>(null);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      stylesRef.current = node ? getComputedStyle(node) : null;\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles: CSSStyleDeclaration | null) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Presence;\n\nexport {\n  Presence,\n  //\n  Root,\n};\nexport type { PresenceProps };\n", "import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// \uD83E\uDD2F https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n", "import * as React from 'react';\n\n/** Number of components which have requested interest to have focus guards */\nlet count = 0;\n\nfunction FocusGuards(props: any) {\n  useFocusGuards();\n  return props.children;\n}\n\n/**\n * Injects a pair of focus guards at the edges of the whole DOM tree\n * to ensure `focusin` & `focusout` events can be caught consistently.\n */\nfunction useFocusGuards() {\n  React.useEffect(() => {\n    const edgeGuards = document.querySelectorAll('[data-radix-focus-guard]');\n    document.body.insertAdjacentElement('afterbegin', edgeGuards[0] ?? createFocusGuard());\n    document.body.insertAdjacentElement('beforeend', edgeGuards[1] ?? createFocusGuard());\n    count++;\n\n    return () => {\n      if (count === 1) {\n        document.querySelectorAll('[data-radix-focus-guard]').forEach((node) => node.remove());\n      }\n      count--;\n    };\n  }, []);\n}\n\nfunction createFocusGuard() {\n  const element = document.createElement('span');\n  element.setAttribute('data-radix-focus-guard', '');\n  element.tabIndex = 0;\n  element.style.outline = 'none';\n  element.style.opacity = '0';\n  element.style.position = 'fixed';\n  element.style.pointerEvents = 'none';\n  return element;\n}\n\nconst Root = FocusGuards;\n\nexport {\n  FocusGuards,\n  //\n  Root,\n  //\n  useFocusGuards,\n};\n", "/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n", "import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { RemoveScroll } from './UI';\nimport SideCar from './sidecar';\nvar ReactRemoveScroll = React.forwardRef(function (props, ref) { return (React.createElement(RemoveScroll, __assign({}, props, { ref: ref, sideCar: SideCar }))); });\nReactRemoveScroll.classNames = RemoveScroll.classNames;\nexport default ReactRemoveScroll;\n", "import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { fullWidthClassName, zeroRightClassName } from 'react-remove-scroll-bar/constants';\nimport { useMergeRefs } from 'use-callback-ref';\nimport { effectCar } from './medium';\nvar nothing = function () {\n    return;\n};\n/**\n * Removes scrollbar from the page and contain the scroll within the Lock\n */\nvar RemoveScroll = React.forwardRef(function (props, parentRef) {\n    var ref = React.useRef(null);\n    var _a = React.useState({\n        onScrollCapture: nothing,\n        onWheelCapture: nothing,\n        onTouchMoveCapture: nothing,\n    }), callbacks = _a[0], setCallbacks = _a[1];\n    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? 'div' : _b, gapMode = props.gapMode, rest = __rest(props, [\"forwardProps\", \"children\", \"className\", \"removeScrollBar\", \"enabled\", \"shards\", \"sideCar\", \"noRelative\", \"noIsolation\", \"inert\", \"allowPinchZoom\", \"as\", \"gapMode\"]);\n    var SideCar = sideCar;\n    var containerRef = useMergeRefs([ref, parentRef]);\n    var containerProps = __assign(__assign({}, rest), callbacks);\n    return (React.createElement(React.Fragment, null,\n        enabled && (React.createElement(SideCar, { sideCar: effectCar, removeScrollBar: removeScrollBar, shards: shards, noRelative: noRelative, noIsolation: noIsolation, inert: inert, setCallbacks: setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode: gapMode })),\n        forwardProps ? (React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef }))) : (React.createElement(Container, __assign({}, containerProps, { className: className, ref: containerRef }), children))));\n});\nRemoveScroll.defaultProps = {\n    enabled: true,\n    removeScrollBar: true,\n    inert: false,\n};\nRemoveScroll.classNames = {\n    fullWidth: fullWidthClassName,\n    zeroRight: zeroRightClassName,\n};\nexport { RemoveScroll };\n", "export var zeroRightClassName = 'right-scroll-bar-position';\nexport var fullWidthClassName = 'width-before-scroll-bar';\nexport var noScrollbarsClassName = 'with-scroll-bars-hidden';\n/**\n * Name of a CSS variable containing the amount of \"hidden\" scrollbar\n * ! might be undefined ! use will fallback!\n */\nexport var removedBarSizeVariable = '--removed-body-scroll-bar-size';\n", "/**\n * Assigns a value for a given ref, no matter of the ref format\n * @param {RefObject} ref - a callback function or ref object\n * @param value - a new value\n *\n * @see https://github.com/theKashey/use-callback-ref#assignref\n * @example\n * const refObject = useRef();\n * const refFn = (ref) => {....}\n *\n * assignRef(refObject, \"refValue\");\n * assignRef(refFn, \"refValue\");\n */\nexport function assignRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref) {\n        ref.current = value;\n    }\n    return ref;\n}\n", "import { useState } from 'react';\n/**\n * creates a MutableRef with ref change callback\n * @param initialValue - initial ref value\n * @param {Function} callback - a callback to run when value changes\n *\n * @example\n * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);\n * ref.current = 1;\n * // prints 0 -> 1\n *\n * @see https://reactjs.org/docs/hooks-reference.html#useref\n * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref\n * @returns {MutableRefObject}\n */\nexport function useCallbackRef(initialValue, callback) {\n    var ref = useState(function () { return ({\n        // value\n        value: initialValue,\n        // last callback\n        callback: callback,\n        // \"memoized\" public interface\n        facade: {\n            get current() {\n                return ref.value;\n            },\n            set current(value) {\n                var last = ref.value;\n                if (last !== value) {\n                    ref.value = value;\n                    ref.callback(value, last);\n                }\n            },\n        },\n    }); })[0];\n    // update callback\n    ref.callback = callback;\n    return ref.facade;\n}\n", "import * as React from 'react';\nimport { assignRef } from './assignRef';\nimport { useCallbackRef } from './useRef';\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar currentValues = new WeakMap();\n/**\n * Merges two or more refs together providing a single interface to set their value\n * @param {RefObject|Ref} refs\n * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}\n *\n * @see {@link mergeRefs} a version without buit-in memoization\n * @see https://github.com/theKashey/use-callback-ref#usemergerefs\n * @example\n * const Component = React.forwardRef((props, ref) => {\n *   const ownRef = useRef();\n *   const domRef = useMergeRefs([ref, ownRef]); //  merge together\n *   return <div ref={domRef}>...</div>\n * }\n */\nexport function useMergeRefs(refs, defaultValue) {\n    var callbackRef = useCallbackRef(defaultValue || null, function (newValue) {\n        return refs.forEach(function (ref) { return assignRef(ref, newValue); });\n    });\n    // handle refs changes - added or removed\n    useIsomorphicLayoutEffect(function () {\n        var oldValue = currentValues.get(callbackRef);\n        if (oldValue) {\n            var prevRefs_1 = new Set(oldValue);\n            var nextRefs_1 = new Set(refs);\n            var current_1 = callbackRef.current;\n            prevRefs_1.forEach(function (ref) {\n                if (!nextRefs_1.has(ref)) {\n                    assignRef(ref, null);\n                }\n            });\n            nextRefs_1.forEach(function (ref) {\n                if (!prevRefs_1.has(ref)) {\n                    assignRef(ref, current_1);\n                }\n            });\n        }\n        currentValues.set(callbackRef, refs);\n    }, [refs]);\n    return callbackRef;\n}\n", "import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { useSidecar } from './hook';\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function sidecar(importer, errorComponent) {\n    var ErrorCase = function () { return errorComponent; };\n    return function Sidecar(props) {\n        var _a = useSidecar(importer, props.sideCar), Car = _a[0], error = _a[1];\n        if (error && errorComponent) {\n            return ErrorCase;\n        }\n        // @ts-expect-error type shenanigans\n        return Car ? React.createElement(Car, __assign({}, props)) : null;\n    };\n}\n", "import { useState, useEffect } from 'react';\nimport { env } from './env';\nvar cache = new WeakMap();\nvar NO_OPTIONS = {};\nexport function useSidecar(importer, effect) {\n    var options = (effect && effect.options) || NO_OPTIONS;\n    if (env.isNode && !options.ssr) {\n        return [null, null];\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useRealSidecar(importer, effect);\n}\nfunction useRealSidecar(importer, effect) {\n    var options = (effect && effect.options) || NO_OPTIONS;\n    var couldUseCache = env.forceCache || (env.isNode && !!options.ssr) || !options.async;\n    var _a = useState(couldUseCache ? function () { return cache.get(importer); } : undefined), Car = _a[0], setCar = _a[1];\n    var _b = useState(null), error = _b[0], setError = _b[1];\n    useEffect(function () {\n        if (!Car) {\n            importer().then(function (car) {\n                var resolved = effect ? effect.read() : car.default || car;\n                if (!resolved) {\n                    console.error('Sidecar error: with importer', importer);\n                    var error_1;\n                    if (effect) {\n                        console.error('Sidecar error: with medium', effect);\n                        error_1 = new Error('Sidecar medium was not found');\n                    }\n                    else {\n                        error_1 = new Error('Sidecar was not found in exports');\n                    }\n                    setError(function () { return error_1; });\n                    throw error_1;\n                }\n                cache.set(importer, resolved);\n                setCar(function () { return resolved; });\n            }, function (e) { return setError(function () { return e; }); });\n        }\n    }, []);\n    return [Car, error];\n}\n", "import { __assign } from \"tslib\";\nfunction ItoI(a) {\n    return a;\n}\nfunction innerCreateMedium(defaults, middleware) {\n    if (middleware === void 0) { middleware = ItoI; }\n    var buffer = [];\n    var assigned = false;\n    var medium = {\n        read: function () {\n            if (assigned) {\n                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');\n            }\n            if (buffer.length) {\n                return buffer[buffer.length - 1];\n            }\n            return defaults;\n        },\n        useMedium: function (data) {\n            var item = middleware(data, assigned);\n            buffer.push(item);\n            return function () {\n                buffer = buffer.filter(function (x) { return x !== item; });\n            };\n        },\n        assignSyncMedium: function (cb) {\n            assigned = true;\n            while (buffer.length) {\n                var cbs = buffer;\n                buffer = [];\n                cbs.forEach(cb);\n            }\n            buffer = {\n                push: function (x) { return cb(x); },\n                filter: function () { return buffer; },\n            };\n        },\n        assignMedium: function (cb) {\n            assigned = true;\n            var pendingQueue = [];\n            if (buffer.length) {\n                var cbs = buffer;\n                buffer = [];\n                cbs.forEach(cb);\n                pendingQueue = buffer;\n            }\n            var executeQueue = function () {\n                var cbs = pendingQueue;\n                pendingQueue = [];\n                cbs.forEach(cb);\n            };\n            var cycle = function () { return Promise.resolve().then(executeQueue); };\n            cycle();\n            buffer = {\n                push: function (x) {\n                    pendingQueue.push(x);\n                    cycle();\n                },\n                filter: function (filter) {\n                    pendingQueue = pendingQueue.filter(filter);\n                    return buffer;\n                },\n            };\n        },\n    };\n    return medium;\n}\nexport function createMedium(defaults, middleware) {\n    if (middleware === void 0) { middleware = ItoI; }\n    return innerCreateMedium(defaults, middleware);\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function createSidecarMedium(options) {\n    if (options === void 0) { options = {}; }\n    var medium = innerCreateMedium(null);\n    medium.options = __assign({ async: true, ssr: false }, options);\n    return medium;\n}\n", "import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { useState, useCallback, useEffect, useLayoutEffect } from 'react';\nexport function renderCar(WrappedComponent, defaults) {\n    function State(_a) {\n        var stateRef = _a.stateRef, props = _a.props;\n        var renderTarget = useCallback(function SideTarget() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            useLayoutEffect(function () {\n                stateRef.current(args);\n            });\n            return null;\n        }, []);\n        // @ts-ignore\n        return React.createElement(WrappedComponent, __assign({}, props, { children: renderTarget }));\n    }\n    var Children = React.memo(function (_a) {\n        var stateRef = _a.stateRef, defaultState = _a.defaultState, children = _a.children;\n        var _b = useState(defaultState.current), state = _b[0], setState = _b[1];\n        useEffect(function () {\n            stateRef.current = setState;\n        }, []);\n        return children.apply(void 0, state);\n    }, function () { return true; });\n    return function Combiner(props) {\n        var defaultState = React.useRef(defaults(props));\n        var ref = React.useRef(function (state) { return (defaultState.current = state); });\n        return (React.createElement(React.Fragment, null,\n            React.createElement(State, { stateRef: ref, props: props }),\n            React.createElement(Children, { stateRef: ref, defaultState: defaultState, children: props.children })));\n    };\n}\n", "import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nvar SideCar = function (_a) {\n    var sideCar = _a.sideCar, rest = __rest(_a, [\"sideCar\"]);\n    if (!sideCar) {\n        throw new Error('Sidecar: please provide `sideCar` property to import the right car');\n    }\n    var Target = sideCar.read();\n    if (!Target) {\n        throw new Error('Sidecar medium not found');\n    }\n    return React.createElement(Target, __assign({}, rest));\n};\nSideCar.isSideCarExport = true;\nexport function exportSidecar(medium, exported) {\n    medium.useMedium(exported);\n    return SideCar;\n}\n", "import { createSidecarMedium } from 'use-sidecar';\nexport var effectCar = createSidecarMedium();\n", "import { __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { RemoveScrollBar } from 'react-remove-scroll-bar';\nimport { styleSingleton } from 'react-style-singleton';\nimport { nonPassive } from './aggresiveCapture';\nimport { handleScroll, locationCouldBeScrolled } from './handleScroll';\nexport var getTouchXY = function (event) {\n    return 'changedTouches' in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];\n};\nexport var getDeltaXY = function (event) { return [event.deltaX, event.deltaY]; };\nvar extractRef = function (ref) {\n    return ref && 'current' in ref ? ref.current : ref;\n};\nvar deltaCompare = function (x, y) { return x[0] === y[0] && x[1] === y[1]; };\nvar generateStyle = function (id) { return \"\\n  .block-interactivity-\".concat(id, \" {pointer-events: none;}\\n  .allow-interactivity-\").concat(id, \" {pointer-events: all;}\\n\"); };\nvar idCounter = 0;\nvar lockStack = [];\nexport function RemoveScrollSideCar(props) {\n    var shouldPreventQueue = React.useRef([]);\n    var touchStartRef = React.useRef([0, 0]);\n    var activeAxis = React.useRef();\n    var id = React.useState(idCounter++)[0];\n    var Style = React.useState(styleSingleton)[0];\n    var lastProps = React.useRef(props);\n    React.useEffect(function () {\n        lastProps.current = props;\n    }, [props]);\n    React.useEffect(function () {\n        if (props.inert) {\n            document.body.classList.add(\"block-interactivity-\".concat(id));\n            var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);\n            allow_1.forEach(function (el) { return el.classList.add(\"allow-interactivity-\".concat(id)); });\n            return function () {\n                document.body.classList.remove(\"block-interactivity-\".concat(id));\n                allow_1.forEach(function (el) { return el.classList.remove(\"allow-interactivity-\".concat(id)); });\n            };\n        }\n        return;\n    }, [props.inert, props.lockRef.current, props.shards]);\n    var shouldCancelEvent = React.useCallback(function (event, parent) {\n        if (('touches' in event && event.touches.length === 2) || (event.type === 'wheel' && event.ctrlKey)) {\n            return !lastProps.current.allowPinchZoom;\n        }\n        var touch = getTouchXY(event);\n        var touchStart = touchStartRef.current;\n        var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];\n        var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];\n        var currentAxis;\n        var target = event.target;\n        var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';\n        // allow horizontal touch move on Range inputs. They will not cause any scroll\n        if ('touches' in event && moveDirection === 'h' && target.type === 'range') {\n            return false;\n        }\n        var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n        if (!canBeScrolledInMainDirection) {\n            return true;\n        }\n        if (canBeScrolledInMainDirection) {\n            currentAxis = moveDirection;\n        }\n        else {\n            currentAxis = moveDirection === 'v' ? 'h' : 'v';\n            canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);\n            // other axis might be not scrollable\n        }\n        if (!canBeScrolledInMainDirection) {\n            return false;\n        }\n        if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {\n            activeAxis.current = currentAxis;\n        }\n        if (!currentAxis) {\n            return true;\n        }\n        var cancelingAxis = activeAxis.current || currentAxis;\n        return handleScroll(cancelingAxis, parent, event, cancelingAxis === 'h' ? deltaX : deltaY, true);\n    }, []);\n    var shouldPrevent = React.useCallback(function (_event) {\n        var event = _event;\n        if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {\n            // not the last active\n            return;\n        }\n        var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);\n        var sourceEvent = shouldPreventQueue.current.filter(function (e) { return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta); })[0];\n        // self event, and should be canceled\n        if (sourceEvent && sourceEvent.should) {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            return;\n        }\n        // outside or shard event\n        if (!sourceEvent) {\n            var shardNodes = (lastProps.current.shards || [])\n                .map(extractRef)\n                .filter(Boolean)\n                .filter(function (node) { return node.contains(event.target); });\n            var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;\n            if (shouldStop) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, []);\n    var shouldCancel = React.useCallback(function (name, delta, target, should) {\n        var event = { name: name, delta: delta, target: target, should: should, shadowParent: getOutermostShadowParent(target) };\n        shouldPreventQueue.current.push(event);\n        setTimeout(function () {\n            shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) { return e !== event; });\n        }, 1);\n    }, []);\n    var scrollTouchStart = React.useCallback(function (event) {\n        touchStartRef.current = getTouchXY(event);\n        activeAxis.current = undefined;\n    }, []);\n    var scrollWheel = React.useCallback(function (event) {\n        shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n    }, []);\n    var scrollTouchMove = React.useCallback(function (event) {\n        shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));\n    }, []);\n    React.useEffect(function () {\n        lockStack.push(Style);\n        props.setCallbacks({\n            onScrollCapture: scrollWheel,\n            onWheelCapture: scrollWheel,\n            onTouchMoveCapture: scrollTouchMove,\n        });\n        document.addEventListener('wheel', shouldPrevent, nonPassive);\n        document.addEventListener('touchmove', shouldPrevent, nonPassive);\n        document.addEventListener('touchstart', scrollTouchStart, nonPassive);\n        return function () {\n            lockStack = lockStack.filter(function (inst) { return inst !== Style; });\n            document.removeEventListener('wheel', shouldPrevent, nonPassive);\n            document.removeEventListener('touchmove', shouldPrevent, nonPassive);\n            document.removeEventListener('touchstart', scrollTouchStart, nonPassive);\n        };\n    }, []);\n    var removeScrollBar = props.removeScrollBar, inert = props.inert;\n    return (React.createElement(React.Fragment, null,\n        inert ? React.createElement(Style, { styles: generateStyle(id) }) : null,\n        removeScrollBar ? React.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null));\n}\nfunction getOutermostShadowParent(node) {\n    var shadowParent = null;\n    while (node !== null) {\n        if (node instanceof ShadowRoot) {\n            shadowParent = node.host;\n            node = node.host;\n        }\n        node = node.parentNode;\n    }\n    return shadowParent;\n}\n", "import * as React from 'react';\nimport { styleSingleton } from 'react-style-singleton';\nimport { fullWidthClassName, zeroRightClassName, noScrollbarsClassName, removedBarSizeVariable } from './constants';\nimport { getGapWidth } from './utils';\nvar Style = styleSingleton();\nexport var lockAttribute = 'data-scroll-locked';\n// important tip - once we measure scrollBar width and remove them\n// we could not repeat this operation\n// thus we are using style-singleton - only the first \"yet correct\" style will be applied.\nvar getStyles = function (_a, allowRelative, gapMode, important) {\n    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;\n    if (gapMode === void 0) { gapMode = 'margin'; }\n    return \"\\n  .\".concat(noScrollbarsClassName, \" {\\n   overflow: hidden \").concat(important, \";\\n   padding-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  body[\").concat(lockAttribute, \"] {\\n    overflow: hidden \").concat(important, \";\\n    overscroll-behavior: contain;\\n    \").concat([\n        allowRelative && \"position: relative \".concat(important, \";\"),\n        gapMode === 'margin' &&\n            \"\\n    padding-left: \".concat(left, \"px;\\n    padding-top: \").concat(top, \"px;\\n    padding-right: \").concat(right, \"px;\\n    margin-left:0;\\n    margin-top:0;\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n    \"),\n        gapMode === 'padding' && \"padding-right: \".concat(gap, \"px \").concat(important, \";\"),\n    ]\n        .filter(Boolean)\n        .join(''), \"\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" {\\n    right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" {\\n    margin-right: \").concat(gap, \"px \").concat(important, \";\\n  }\\n  \\n  .\").concat(zeroRightClassName, \" .\").concat(zeroRightClassName, \" {\\n    right: 0 \").concat(important, \";\\n  }\\n  \\n  .\").concat(fullWidthClassName, \" .\").concat(fullWidthClassName, \" {\\n    margin-right: 0 \").concat(important, \";\\n  }\\n  \\n  body[\").concat(lockAttribute, \"] {\\n    \").concat(removedBarSizeVariable, \": \").concat(gap, \"px;\\n  }\\n\");\n};\nvar getCurrentUseCounter = function () {\n    var counter = parseInt(document.body.getAttribute(lockAttribute) || '0', 10);\n    return isFinite(counter) ? counter : 0;\n};\nexport var useLockAttribute = function () {\n    React.useEffect(function () {\n        document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());\n        return function () {\n            var newCounter = getCurrentUseCounter() - 1;\n            if (newCounter <= 0) {\n                document.body.removeAttribute(lockAttribute);\n            }\n            else {\n                document.body.setAttribute(lockAttribute, newCounter.toString());\n            }\n        };\n    }, []);\n};\n/**\n * Removes page scrollbar and blocks page scroll when mounted\n */\nexport var RemoveScrollBar = function (_a) {\n    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? 'margin' : _b;\n    useLockAttribute();\n    /*\n     gap will be measured on every component mount\n     however it will be used only by the \"first\" invocation\n     due to singleton nature of <Style\n     */\n    var gap = React.useMemo(function () { return getGapWidth(gapMode); }, [gapMode]);\n    return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : '') });\n};\n", "import * as React from 'react';\nimport { stylesheetSingleton } from './singleton';\n/**\n * creates a hook to control style singleton\n * @see {@link styleSingleton} for a safer component version\n * @example\n * ```tsx\n * const useStyle = styleHookSingleton();\n * ///\n * useStyle('body { overflow: hidden}');\n */\nexport var styleHookSingleton = function () {\n    var sheet = stylesheetSingleton();\n    return function (styles, isDynamic) {\n        React.useEffect(function () {\n            sheet.add(styles);\n            return function () {\n                sheet.remove();\n            };\n        }, [styles && isDynamic]);\n    };\n};\n", "var currentNonce;\nexport var setNonce = function (nonce) {\n    currentNonce = nonce;\n};\nexport var getNonce = function () {\n    if (currentNonce) {\n        return currentNonce;\n    }\n    if (typeof __webpack_nonce__ !== 'undefined') {\n        return __webpack_nonce__;\n    }\n    return undefined;\n};\n", "import { getNonce } from 'get-nonce';\nfunction makeStyleTag() {\n    if (!document)\n        return null;\n    var tag = document.createElement('style');\n    tag.type = 'text/css';\n    var nonce = getNonce();\n    if (nonce) {\n        tag.setAttribute('nonce', nonce);\n    }\n    return tag;\n}\nfunction injectStyles(tag, css) {\n    // @ts-ignore\n    if (tag.styleSheet) {\n        // @ts-ignore\n        tag.styleSheet.cssText = css;\n    }\n    else {\n        tag.appendChild(document.createTextNode(css));\n    }\n}\nfunction insertStyleTag(tag) {\n    var head = document.head || document.getElementsByTagName('head')[0];\n    head.appendChild(tag);\n}\nexport var stylesheetSingleton = function () {\n    var counter = 0;\n    var stylesheet = null;\n    return {\n        add: function (style) {\n            if (counter == 0) {\n                if ((stylesheet = makeStyleTag())) {\n                    injectStyles(stylesheet, style);\n                    insertStyleTag(stylesheet);\n                }\n            }\n            counter++;\n        },\n        remove: function () {\n            counter--;\n            if (!counter && stylesheet) {\n                stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);\n                stylesheet = null;\n            }\n        },\n    };\n};\n", "import { styleHookSingleton } from './hook';\n/**\n * create a Component to add styles on demand\n * - styles are added when first instance is mounted\n * - styles are removed when the last instance is unmounted\n * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior\n */\nexport var styleSingleton = function () {\n    var useStyle = styleHookSingleton();\n    var Sheet = function (_a) {\n        var styles = _a.styles, dynamic = _a.dynamic;\n        useStyle(styles, dynamic);\n        return null;\n    };\n    return Sheet;\n};\n", "export var zeroGap = {\n    left: 0,\n    top: 0,\n    right: 0,\n    gap: 0,\n};\nvar parse = function (x) { return parseInt(x || '', 10) || 0; };\nvar getOffset = function (gapMode) {\n    var cs = window.getComputedStyle(document.body);\n    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];\n    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];\n    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];\n    return [parse(left), parse(top), parse(right)];\n};\nexport var getGapWidth = function (gapMode) {\n    if (gapMode === void 0) { gapMode = 'margin'; }\n    if (typeof window === 'undefined') {\n        return zeroGap;\n    }\n    var offsets = getOffset(gapMode);\n    var documentWidth = document.documentElement.clientWidth;\n    var windowWidth = window.innerWidth;\n    return {\n        left: offsets[0],\n        top: offsets[1],\n        right: offsets[2],\n        gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),\n    };\n};\n", "var passiveSupported = false;\nif (typeof window !== 'undefined') {\n    try {\n        var options = Object.defineProperty({}, 'passive', {\n            get: function () {\n                passiveSupported = true;\n                return true;\n            },\n        });\n        // @ts-ignore\n        window.addEventListener('test', options, options);\n        // @ts-ignore\n        window.removeEventListener('test', options, options);\n    }\n    catch (err) {\n        passiveSupported = false;\n    }\n}\nexport var nonPassive = passiveSupported ? { passive: false } : false;\n", "var alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    if (!(node instanceof Element)) {\n        return false;\n    }\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nexport var locationCouldBeScrolled = function (axis, node) {\n    var ownerDocument = node.ownerDocument;\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];\n            if (scrollHeight > clientHeight) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== ownerDocument.body);\n    return false;\n};\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        if (!target) {\n            break;\n        }\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        var parent_1 = target.parentNode;\n        // we will \"bubble\" from ShadowDom in case we are, or just to the parent in normal case\n        // this is the same logic used in focus-lock\n        target = (parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1);\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    // handle epsilon around 0 (non standard zoom levels)\n    if (isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScroll) < 1) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScrollTop) < 1) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\n", "import { exportSidecar } from 'use-sidecar';\nimport { RemoveScrollSideCar } from './SideEffect';\nimport { effectCar } from './medium';\nexport default exportSidecar(effectCar, RemoveScrollSideCar);\n", "var getDefaultParent = function (originalTarget) {\n    if (typeof document === 'undefined') {\n        return null;\n    }\n    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;\n    return sampleTarget.ownerDocument.body;\n};\nvar counterMap = new WeakMap();\nvar uncontrolledNodes = new WeakMap();\nvar markerMap = {};\nvar lockCount = 0;\nvar unwrapHost = function (node) {\n    return node && (node.host || unwrapHost(node.parentNode));\n};\nvar correctTargets = function (parent, targets) {\n    return targets\n        .map(function (target) {\n        if (parent.contains(target)) {\n            return target;\n        }\n        var correctedTarget = unwrapHost(target);\n        if (correctedTarget && parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');\n        return null;\n    })\n        .filter(function (x) { return Boolean(x); });\n};\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @param {String} [controlAttribute] - html Attribute to control\n * @return {Undo} undo command\n */\nvar applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {\n    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    var markerCounter = markerMap[markerName];\n    var hiddenNodes = [];\n    var elementsToKeep = new Set();\n    var elementsToStop = new Set(targets);\n    var keep = function (el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        keep(el.parentNode);\n    };\n    targets.forEach(keep);\n    var deep = function (parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        Array.prototype.forEach.call(parent.children, function (node) {\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            }\n            else {\n                try {\n                    var attr = node.getAttribute(controlAttribute);\n                    var alreadyHidden = attr !== null && attr !== 'false';\n                    var counterValue = (counterMap.get(node) || 0) + 1;\n                    var markerValue = (markerCounter.get(node) || 0) + 1;\n                    counterMap.set(node, counterValue);\n                    markerCounter.set(node, markerValue);\n                    hiddenNodes.push(node);\n                    if (counterValue === 1 && alreadyHidden) {\n                        uncontrolledNodes.set(node, true);\n                    }\n                    if (markerValue === 1) {\n                        node.setAttribute(markerName, 'true');\n                    }\n                    if (!alreadyHidden) {\n                        node.setAttribute(controlAttribute, 'true');\n                    }\n                }\n                catch (e) {\n                    console.error('aria-hidden: cannot operate on ', node, e);\n                }\n            }\n        });\n    };\n    deep(parentNode);\n    elementsToKeep.clear();\n    lockCount++;\n    return function () {\n        hiddenNodes.forEach(function (node) {\n            var counterValue = counterMap.get(node) - 1;\n            var markerValue = markerCounter.get(node) - 1;\n            counterMap.set(node, counterValue);\n            markerCounter.set(node, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledNodes.has(node)) {\n                    node.removeAttribute(controlAttribute);\n                }\n                uncontrolledNodes.delete(node);\n            }\n            if (!markerValue) {\n                node.removeAttribute(markerName);\n            }\n        });\n        lockCount--;\n        if (!lockCount) {\n            // clear\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledNodes = new WeakMap();\n            markerMap = {};\n        }\n    };\n};\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var hideOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-aria-hidden'; }\n    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n        return function () { return null; };\n    }\n    // we should not hide aria-live elements - https://github.com/theKashey/aria-hidden/issues/10\n    // and script elements, as they have no impact on accessibility.\n    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live], script')));\n    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');\n};\n/**\n * Marks everything except given node(or nodes) as inert\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var inertOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-inert-ed'; }\n    var activeParentNode = parentNode || getDefaultParent(originalTarget);\n    if (!activeParentNode) {\n        return function () { return null; };\n    }\n    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');\n};\n/**\n * @returns if current browser supports inert\n */\nexport var supportsInert = function () {\n    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');\n};\n/**\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Undo} undo command\n */\nexport var suppressOthers = function (originalTarget, parentNode, markerName) {\n    if (markerName === void 0) { markerName = 'data-suppressed'; }\n    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\n};\n", "function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;", "[data-dapp-kit]:where(*), [data-dapp-kit] :where(*) {\n  box-sizing: border-box;\n  color: var(--dapp-kit-colors-body);\n  font-family: var(--dapp-kit-typography-fontFamily);\n  font-size: var(--dapp-kit-fontWeights-normal);\n  font-style: var(--dapp-kit-typography-fontStyle);\n  font-weight: var(--dapp-kit-fontWeights-normal);\n  line-height: var(--dapp-kit-typography-lineHeight);\n  letter-spacing: var(--dapp-kit-typography-letterSpacing);\n}\n[data-dapp-kit]:where(button), [data-dapp-kit] :where(button) {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background-color: transparent;\n  font-size: inherit;\n  font-family: inherit;\n  line-height: inherit;\n  letter-spacing: inherit;\n  color: inherit;\n  border: 0;\n  padding: 0;\n  margin: 0;\n}\n[data-dapp-kit]:where(a), [data-dapp-kit] :where(a) {\n  text-decoration: none;\n  color: inherit;\n  outline: none;\n}\n[data-dapp-kit]:where(ol, ul), [data-dapp-kit] :where(ol, ul) {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n[data-dapp-kit]:where(h1, h2, h3, h4, h5, h6), [data-dapp-kit] :where(h1, h2, h3, h4, h5, h6) {\n  font-size: inherit;\n  font-weight: inherit;\n  margin: 0;\n}", "import 'src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithRequiredFeatures } from '@mysten/wallet-standard';\nimport * as Dialog from '@radix-ui/react-dialog';\nimport clsx from 'clsx';\nimport { useState } from 'react';\nimport type { ReactNode } from 'react';\n\nimport { DEFAULT_WALLET_FILTER } from '../../constants/walletDefaults.js';\nimport { useConnectWallet } from '../../hooks/wallet/useConnectWallet.js';\nimport { useWallets } from '../../hooks/wallet/useWallets.js';\nimport { getWalletUniqueIdentifier } from '../../utils/walletUtils.js';\nimport { BackIcon } from '../icons/BackIcon.js';\nimport { CloseIcon } from '../icons/CloseIcon.js';\nimport { StyleMarker } from '../styling/StyleMarker.js';\nimport { Heading } from '../ui/Heading.js';\nimport { IconButton } from '../ui/IconButton.js';\nimport * as styles from './ConnectModal.css.js';\nimport { ConnectionStatus } from './views/ConnectionStatus.js';\nimport { GettingStarted } from './views/GettingStarted.js';\nimport { WhatIsAWallet } from './views/WhatIsAWallet.js';\nimport { WalletList } from './wallet-list/WalletList.js';\n\ntype ConnectModalView = 'getting-started' | 'what-is-a-wallet' | 'connection-status';\n\ntype ControlledModalProps = {\n\t/** The controlled open state of the dialog. */\n\topen: boolean;\n\n\t/** Event handler called when the open state of the dialog changes. */\n\tonOpenChange: (open: boolean) => void;\n\n\tdefaultOpen?: never;\n};\n\ntype UncontrolledModalProps = {\n\topen?: never;\n\n\tonOpenChange?: never;\n\n\t/** The open state of the dialog when it is initially rendered. Use when you do not need to control its open state. */\n\tdefaultOpen?: boolean;\n};\n\ntype ConnectModalProps = {\n\t/** The trigger button that opens the dialog. */\n\ttrigger: NonNullable<ReactNode>;\n\n\t/** Filter the wallets shown in the modal. */\n\twalletFilter?: (wallet: WalletWithRequiredFeatures) => boolean;\n} & (ControlledModalProps | UncontrolledModalProps);\n\nexport function ConnectModal({\n\ttrigger,\n\topen,\n\tdefaultOpen,\n\tonOpenChange,\n\twalletFilter = DEFAULT_WALLET_FILTER,\n}: ConnectModalProps) {\n\tconst [isModalOpen, setModalOpen] = useState(open ?? defaultOpen);\n\tconst [currentView, setCurrentView] = useState<ConnectModalView>();\n\tconst [selectedWallet, setSelectedWallet] = useState<WalletWithRequiredFeatures>();\n\n\tconst wallets = useWallets().filter(walletFilter);\n\tconst { mutate, isError } = useConnectWallet();\n\n\tconst resetSelection = () => {\n\t\tsetSelectedWallet(undefined);\n\t\tsetCurrentView(undefined);\n\t};\n\n\tconst handleOpenChange = (open: boolean) => {\n\t\tif (!open) {\n\t\t\tresetSelection();\n\t\t}\n\t\tsetModalOpen(open);\n\t\tonOpenChange?.(open);\n\t};\n\n\tconst connectWallet = (wallet: WalletWithRequiredFeatures) => {\n\t\tsetCurrentView('connection-status');\n\t\tmutate(\n\t\t\t{ wallet },\n\t\t\t{\n\t\t\t\tonSuccess: () => handleOpenChange(false),\n\t\t\t},\n\t\t);\n\t};\n\n\tlet modalContent: ReactNode | undefined;\n\tswitch (currentView) {\n\t\tcase 'what-is-a-wallet':\n\t\t\tmodalContent = <WhatIsAWallet />;\n\t\t\tbreak;\n\t\tcase 'getting-started':\n\t\t\tmodalContent = <GettingStarted />;\n\t\t\tbreak;\n\t\tcase 'connection-status':\n\t\t\tmodalContent = (\n\t\t\t\t<ConnectionStatus\n\t\t\t\t\tselectedWallet={selectedWallet!}\n\t\t\t\t\thadConnectionError={isError}\n\t\t\t\t\tonRetryConnection={connectWallet}\n\t\t\t\t/>\n\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmodalContent = <WhatIsAWallet />;\n\t}\n\n\treturn (\n\t\t<Dialog.Root open={open ?? isModalOpen} onOpenChange={handleOpenChange}>\n\t\t\t<Dialog.Trigger asChild>{trigger}</Dialog.Trigger>\n\t\t\t<Dialog.Portal>\n\t\t\t\t<StyleMarker>\n\t\t\t\t\t<Dialog.Overlay className={styles.overlay}>\n\t\t\t\t\t\t<Dialog.Content className={styles.content} aria-describedby={undefined}>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName={clsx(styles.walletListContainer, {\n\t\t\t\t\t\t\t\t\t[styles.walletListContainerWithViewSelected]: !!currentView,\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div className={styles.walletListContent}>\n\t\t\t\t\t\t\t\t\t<Dialog.Title className={styles.title} asChild>\n\t\t\t\t\t\t\t\t\t\t<Heading as=\"h2\">Connect a Wallet</Heading>\n\t\t\t\t\t\t\t\t\t</Dialog.Title>\n\t\t\t\t\t\t\t\t\t<WalletList\n\t\t\t\t\t\t\t\t\t\twallets={wallets}\n\t\t\t\t\t\t\t\t\t\tselectedWalletName={getWalletUniqueIdentifier(selectedWallet)}\n\t\t\t\t\t\t\t\t\t\tonPlaceholderClick={() => setCurrentView('getting-started')}\n\t\t\t\t\t\t\t\t\t\tonSelect={(wallet) => {\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\tgetWalletUniqueIdentifier(selectedWallet) !==\n\t\t\t\t\t\t\t\t\t\t\t\tgetWalletUniqueIdentifier(wallet)\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tsetSelectedWallet(wallet);\n\t\t\t\t\t\t\t\t\t\t\t\tconnectWallet(wallet);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tclassName={styles.whatIsAWalletButton}\n\t\t\t\t\t\t\t\t\tonClick={() => setCurrentView('what-is-a-wallet')}\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tWhat is a Wallet?\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName={clsx(styles.viewContainer, {\n\t\t\t\t\t\t\t\t\t[styles.selectedViewContainer]: !!currentView,\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div className={styles.backButtonContainer}>\n\t\t\t\t\t\t\t\t\t<IconButton type=\"button\" aria-label=\"Back\" onClick={() => resetSelection()}>\n\t\t\t\t\t\t\t\t\t\t<BackIcon />\n\t\t\t\t\t\t\t\t\t</IconButton>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t{modalContent}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<Dialog.Close className={styles.closeButtonContainer} asChild>\n\t\t\t\t\t\t\t\t<IconButton type=\"button\" aria-label=\"Close\">\n\t\t\t\t\t\t\t\t\t<CloseIcon />\n\t\t\t\t\t\t\t\t</IconButton>\n\t\t\t\t\t\t\t</Dialog.Close>\n\t\t\t\t\t\t</Dialog.Content>\n\t\t\t\t\t</Dialog.Overlay>\n\t\t\t\t</StyleMarker>\n\t\t\t</Dialog.Portal>\n\t\t</Dialog.Root>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiWalletFeatures, WalletWithRequiredFeatures } from '@mysten/wallet-standard';\nimport { SLUSH_WALLET_NAME } from '@mysten/slush-wallet';\n\nimport { createInMemoryStore } from '../utils/stateStorage.js';\n\nexport const SUI_WALLET_NAME = 'Sui Wallet';\n\nexport const DEFAULT_STORAGE =\n\ttypeof window !== 'undefined' && window.localStorage ? localStorage : createInMemoryStore();\n\nexport const DEFAULT_STORAGE_KEY = 'sui-dapp-kit:wallet-connection-info';\n\nconst SIGN_FEATURES = [\n\t'sui:signTransaction',\n\t'sui:signTransactionBlock',\n] satisfies (keyof SuiWalletFeatures)[];\n\nexport const DEFAULT_WALLET_FILTER = (wallet: WalletWithRequiredFeatures) =>\n\tSIGN_FEATURES.some((feature) => wallet.features[feature]);\n\nexport const DEFAULT_PREFERRED_WALLETS = [SUI_WALLET_NAME, SLUSH_WALLET_NAME];\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { StateStorage } from 'zustand/middleware';\n\nexport function createInMemoryStore(): StateStorage {\n\tconst store = new Map();\n\treturn {\n\t\tgetItem(key: string) {\n\t\t\treturn store.get(key);\n\t\t},\n\t\tsetItem(key: string, value: string) {\n\t\t\tstore.set(key, value);\n\t\t},\n\t\tremoveItem(key: string) {\n\t\t\tstore.delete(key);\n\t\t},\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tStandardConnectInput,\n\tStandardConnectOutput,\n\tWalletAccount,\n\tWalletWithRequiredFeatures,\n} from '@mysten/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport { useWalletStore } from './useWalletStore.js';\n\ntype ConnectWalletArgs = {\n\t/** The wallet to connect to. */\n\twallet: WalletWithRequiredFeatures;\n\n\t/** An optional account address to connect to. Defaults to the first authorized account. */\n\taccountAddress?: string;\n} & StandardConnectInput;\n\ntype ConnectWalletResult = StandardConnectOutput;\n\ntype UseConnectWalletMutationOptions = Omit<\n\tUseMutationOptions<ConnectWalletResult, Error, ConnectWalletArgs, unknown>,\n\t'mutationFn'\n>;\n\n/**\n * Mutation hook for establishing a connection to a specific wallet.\n */\nexport function useConnectWallet({\n\tmutationKey,\n\t...mutationOptions\n}: UseConnectWalletMutationOptions = {}): UseMutationResult<\n\tConnectWalletResult,\n\tError,\n\tConnectWalletArgs,\n\tunknown\n> {\n\tconst setWalletConnected = useWalletStore((state) => state.setWalletConnected);\n\tconst setConnectionStatus = useWalletStore((state) => state.setConnectionStatus);\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.connectWallet(mutationKey),\n\t\tmutationFn: async ({ wallet, accountAddress, ...connectArgs }) => {\n\t\t\ttry {\n\t\t\t\tsetConnectionStatus('connecting');\n\n\t\t\t\tconst connectResult = await wallet.features['standard:connect'].connect(connectArgs);\n\t\t\t\tconst connectedSuiAccounts = connectResult.accounts.filter((account) =>\n\t\t\t\t\taccount.chains.some((chain) => chain.split(':')[0] === 'sui'),\n\t\t\t\t);\n\t\t\t\tconst selectedAccount = getSelectedAccount(connectedSuiAccounts, accountAddress);\n\n\t\t\t\tsetWalletConnected(\n\t\t\t\t\twallet,\n\t\t\t\t\tconnectedSuiAccounts,\n\t\t\t\t\tselectedAccount,\n\t\t\t\t\tconnectResult.supportedIntents,\n\t\t\t\t);\n\n\t\t\t\treturn { accounts: connectedSuiAccounts };\n\t\t\t} catch (error) {\n\t\t\t\tsetConnectionStatus('disconnected');\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n\nfunction getSelectedAccount(connectedAccounts: readonly WalletAccount[], accountAddress?: string) {\n\tif (connectedAccounts.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (accountAddress) {\n\t\tconst selectedAccount = connectedAccounts.find((account) => account.address === accountAddress);\n\t\treturn selectedAccount ?? connectedAccounts[0];\n\t}\n\n\treturn connectedAccounts[0];\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { MutationKey } from '@tanstack/react-query';\n\nexport const walletMutationKeys = {\n\tall: { baseScope: 'wallet' },\n\tconnectWallet: formMutationKeyFn('connect-wallet'),\n\tautoconnectWallet: formMutationKeyFn('autoconnect-wallet'),\n\tdisconnectWallet: formMutationKeyFn('disconnect-wallet'),\n\tsignPersonalMessage: formMutationKeyFn('sign-personal-message'),\n\tsignTransaction: formMutationKeyFn('sign-transaction'),\n\tsignAndExecuteTransaction: formMutationKeyFn('sign-and-execute-transaction'),\n\tswitchAccount: formMutationKeyFn('switch-account'),\n\treportTransactionEffects: formMutationKeyFn('report-transaction-effects'),\n};\n\nfunction formMutationKeyFn(baseEntity: string) {\n\treturn function mutationKeyFn(additionalKeys: MutationKey = []) {\n\t\treturn [{ ...walletMutationKeys.all, baseEntity }, ...additionalKeys];\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useContext } from 'react';\nimport { useStore } from 'zustand';\n\nimport { WalletContext } from '../../contexts/walletContext.js';\nimport type { StoreState } from '../../walletStore.js';\n\nexport function useWalletStore<T>(selector: (state: StoreState) => T): T {\n\tconst store = useContext(WalletContext);\n\tif (!store) {\n\t\tthrow new Error(\n\t\t\t'Could not find WalletContext. Ensure that you have set up the WalletProvider.',\n\t\t);\n\t}\n\treturn useStore(store, selector);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createContext } from 'react';\n\nimport type { WalletStore } from '../walletStore.js';\n\nexport const WalletContext = createContext<WalletStore | null>(null);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Retrieves a list of registered wallets available to the dApp sorted by preference.\n */\nexport function useWallets() {\n\treturn useWalletStore((state) => state.wallets);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tMinimallyRequiredFeatures,\n\tWallet,\n\tWalletWithFeatures,\n\tWalletWithRequiredFeatures,\n} from '@mysten/wallet-standard';\nimport { getWallets, isWalletWithRequiredFeatureSet } from '@mysten/wallet-standard';\n\nexport function getRegisteredWallets<AdditionalFeatures extends Wallet['features']>(\n\tpreferredWallets: string[],\n\twalletFilter?: (wallet: WalletWithRequiredFeatures) => boolean,\n) {\n\tconst walletsApi = getWallets();\n\tconst wallets = walletsApi.get();\n\n\tconst suiWallets = wallets.filter(\n\t\t(wallet): wallet is WalletWithFeatures<MinimallyRequiredFeatures & AdditionalFeatures> =>\n\t\t\tisWalletWithRequiredFeatureSet(wallet) && (!walletFilter || walletFilter(wallet)),\n\t);\n\n\treturn [\n\t\t// Preferred wallets, in order:\n\t\t...(preferredWallets\n\t\t\t.map((name) => suiWallets.find((wallet) => wallet.name === name))\n\t\t\t.filter(Boolean) as WalletWithFeatures<MinimallyRequiredFeatures & AdditionalFeatures>[]),\n\n\t\t// Wallets in default order:\n\t\t...suiWallets.filter((wallet) => !preferredWallets.includes(wallet.name)),\n\t];\n}\n\nexport function getWalletUniqueIdentifier(wallet?: Wallet) {\n\treturn wallet?.id ?? wallet?.name;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ComponentProps } from 'react';\n\n// FIXME: Replace this with a 10x10 icon to match the CheckIcon, or alternatively make the CheckIcon bigger\n// Right now, the icons don't align on mobile :(\nexport function BackIcon(props: ComponentProps<'svg'>) {\n\treturn (\n\t\t<svg width={24} height={24} fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" {...props}>\n\t\t\t<path\n\t\t\t\td=\"M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z\"\n\t\t\t\tfill=\"currentColor\"\n\t\t\t/>\n\t\t</svg>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ComponentProps } from 'react';\n\nexport function CloseIcon(props: ComponentProps<'svg'>) {\n\treturn (\n\t\t<svg width={10} height={10} fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" {...props}>\n\t\t\t<path\n\t\t\t\td=\"M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z\"\n\t\t\t\tfill=\"currentColor\"\n\t\t\t/>\n\t\t</svg>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Slot } from '@radix-ui/react-slot';\nimport type { ComponentPropsWithoutRef, ElementRef, ReactNode } from 'react';\nimport { forwardRef } from 'react';\n\nimport { styleDataAttribute } from '../../constants/styleDataAttribute.js';\n\nimport './StyleMarker.css.js';\n\ntype StyleMarker = {\n\tchildren: ReactNode;\n};\n\nexport const StyleMarker = forwardRef<\n\tElementRef<typeof Slot>,\n\tComponentPropsWithoutRef<typeof Slot>\n>(({ children, ...props }, forwardedRef) => (\n\t<Slot ref={forwardedRef} {...props} {...styleDataAttribute}>\n\t\t{children}\n\t</Slot>\n));\nStyleMarker.displayName = 'StyleMarker';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport const styleDataAttributeName = 'data-dapp-kit';\n\nexport const styleDataAttributeSelector = `[${styleDataAttributeName}]`;\n\nexport const styleDataAttribute = { [styleDataAttributeName]: '' };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Slot } from '@radix-ui/react-slot';\nimport clsx from 'clsx';\nimport { forwardRef } from 'react';\n\nimport { headingVariants } from './Heading.css.js';\nimport type { HeadingVariants } from './Heading.css.js';\n\ntype HeadingAsChildProps = {\n\tasChild?: boolean;\n\tas?: never;\n};\n\ntype HeadingAsProps = {\n\tas?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\tasChild?: never;\n};\n\ntype HeadingProps = (HeadingAsChildProps | HeadingAsProps) &\n\tReact.HTMLAttributes<HTMLHeadingElement> &\n\tHeadingVariants;\n\nconst Heading = forwardRef<HTMLHeadingElement, HeadingProps>(\n\t(\n\t\t{\n\t\t\tchildren,\n\t\t\tclassName,\n\t\t\tasChild = false,\n\t\t\tas: Tag = 'h1',\n\t\t\tsize,\n\t\t\tweight,\n\t\t\ttruncate,\n\t\t\t...headingProps\n\t\t},\n\t\tforwardedRef,\n\t) => {\n\t\treturn (\n\t\t\t<Slot\n\t\t\t\t{...headingProps}\n\t\t\t\tref={forwardedRef}\n\t\t\t\tclassName={clsx(headingVariants({ size, weight, truncate }), className)}\n\t\t\t>\n\t\t\t\t{asChild ? children : <Tag>{children}</Tag>}\n\t\t\t</Slot>\n\t\t);\n\t},\n);\nHeading.displayName = 'Heading';\n\nexport { Heading };\n", "import 'src/components/ui/Heading.css.ts.vanilla.css?source=LkhlYWRpbmdfaGVhZGluZ1ZhcmlhbnRzX3NpemVfc21fXzFhYTgzNWsxIHsKICBmb250LXNpemU6IHZhcigtLWRhcHAta2l0LWZvbnRTaXplcy1zbWFsbCk7Cn0KLkhlYWRpbmdfaGVhZGluZ1ZhcmlhbnRzX3NpemVfbWRfXzFhYTgzNWsyIHsKICBmb250LXNpemU6IHZhcigtLWRhcHAta2l0LWZvbnRTaXplcy1tZWRpdW0pOwp9Ci5IZWFkaW5nX2hlYWRpbmdWYXJpYW50c19zaXplX2xnX18xYWE4MzVrMyB7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250U2l6ZXMtbGFyZ2UpOwp9Ci5IZWFkaW5nX2hlYWRpbmdWYXJpYW50c19zaXplX3hsX18xYWE4MzVrNCB7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250U2l6ZXMteGxhcmdlKTsKfQouSGVhZGluZ19oZWFkaW5nVmFyaWFudHNfd2VpZ2h0X25vcm1hbF9fMWFhODM1azUgewogIGZvbnQtd2VpZ2h0OiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwp9Ci5IZWFkaW5nX2hlYWRpbmdWYXJpYW50c193ZWlnaHRfYm9sZF9fMWFhODM1azYgewogIGZvbnQtd2VpZ2h0OiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ib2xkKTsKfQouSGVhZGluZ19oZWFkaW5nVmFyaWFudHNfdHJ1bmNhdGVfdHJ1ZV9fMWFhODM1azcgewogIG92ZXJmbG93OiBoaWRkZW47CiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7CiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsKfQ==';\nimport { createRuntimeFn as _7a468 } from '@vanilla-extract/recipes/createRuntimeFn';\nexport var headingVariants = _7a468({defaultClassName:'Heading__1aa835k0',variantClassNames:{size:{sm:'Heading_headingVariants_size_sm__1aa835k1',md:'Heading_headingVariants_size_md__1aa835k2',lg:'Heading_headingVariants_size_lg__1aa835k3',xl:'Heading_headingVariants_size_xl__1aa835k4'},weight:{normal:'Heading_headingVariants_weight_normal__1aa835k5',bold:'Heading_headingVariants_weight_bold__1aa835k6'},truncate:{true:'Heading_headingVariants_truncate_true__1aa835k7'}},defaultVariants:{size:'lg',weight:'bold'},compoundVariants:[]});", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Slot } from '@radix-ui/react-slot';\nimport clsx from 'clsx';\nimport type { ButtonHTMLAttributes } from 'react';\nimport { forwardRef } from 'react';\n\nimport * as styles from './IconButton.css.js';\n\ntype IconButtonProps = {\n\tasChild?: boolean;\n\t'aria-label': string;\n} & ButtonHTMLAttributes<HTMLButtonElement>;\n\nconst IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(\n\t({ className, asChild = false, ...props }, forwardedRef) => {\n\t\tconst Comp = asChild ? Slot : 'button';\n\t\treturn <Comp {...props} className={clsx(styles.container, className)} ref={forwardedRef} />;\n\t},\n);\nIconButton.displayName = 'Button';\n\nexport { IconButton };\n", "import 'src/components/ui/IconButton.css.ts.vanilla.css?source=Lkljb25CdXR0b25fY29udGFpbmVyX19zNm43YnEwIHsKICBib3JkZXItcmFkaXVzOiA5OTk5cHg7CiAgcGFkZGluZzogOHB4OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtaWNvbkJ1dHRvbik7CiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGFwcC1raXQtYmFja2dyb3VuZENvbG9ycy1pY29uQnV0dG9uKTsKfQouSWNvbkJ1dHRvbl9jb250YWluZXJfX3M2bjdicTA6aG92ZXIgewogIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWRhcHAta2l0LWJhY2tncm91bmRDb2xvcnMtaWNvbkJ1dHRvbkhvdmVyKTsKfQ==';\nexport var container = 'IconButton_container__s6n7bq0';", "import 'src/components/connect-modal/ConnectModal.css.ts.vanilla.css?source=#H4sIAAAAAAAAA61UTW8aMRC98yt8iUSkOlrSkJDNpS2nSq1aKVJzjMx6dteN117Zs0BS8d8rfwAh6wAS4QB4vPNm5s17ezHVSkGBPzVn8lHPwUj2/PhYvUxebjPyb0DIjBVPldGd4rTQUpuczJkZUspZ29IngXT7wNTdW9o4rF8B6vwuQnCjW1oKiZBAkF0qrdVWoNAqJ6VYAnchoSxgTjL3/4UKxWGZk9v1526wGlzsDIQCJcRxRn6clnEuVEUllJiTSbvsJxVaISiMaZensPDbiIaZyII2HAw1jIvO9vJdWNClZKYC/3i6TBHAZ5q/y9FMI+omJ6NrNxwhYdL1yYiqfnXkwraSPeeklOAD7pdyYaAIsIWWXaPczd/OoiifaaQnJ7ZlBdAZ4ALAP+HkU0q9yEktOA+xRihaQyg6zua1j7HlJjYZb2MLwbHOyU2WpdayqBl+t18fmJSA3zpEreKKPp+yonsotOLrJUV5rAl628NcwGKqFTKhwMTqV776hkilFewgXWbtltnKOHpGfWQLEgoE/idRYbxbIazqLYCbLrDyNv06CH+jFDazWnbou0TdbjsMSrlMsl9IbSGNf3MIP6m93nr9Xn8Ii9Md/01Sw+/T6S7PhFTMjXgVWuht5WRj75/jNU+36UkO++rYWY9o5UFg7SR2H+UWW2MpDa8GXxrgghFbGABFmOJk6Py89un1pF2e+8zDL9D+FEYv7vxFhBtl2VkIeNGM16egys0RDVO21KbJw1/JEIZ0nJ19Iu7bu3jVa+nQyyNh4D7I++5PrLWffsihR/Ww3yYf9BY8VLav6j3r9RczZoV1Noy225Fu9ipiayPUU4wd1cdeSScXs/oP5e4DaPYIAAA=';\nexport var backButtonContainer = 'ConnectModal_backButtonContainer__gz8z96';\nexport var closeButtonContainer = 'ConnectModal_closeButtonContainer__gz8z97';\nexport var content = 'ConnectModal_content__gz8z92';\nexport var overlay = 'ConnectModal_overlay__gz8z90';\nexport var selectedViewContainer = 'ConnectModal_selectedViewContainer__gz8z95';\nexport var title = 'ConnectModal_title__gz8z91';\nexport var viewContainer = 'ConnectModal_viewContainer__gz8z94';\nexport var walletListContainer = 'ConnectModal_walletListContainer__gz8z99';\nexport var walletListContainerWithViewSelected = 'ConnectModal_walletListContainerWithViewSelected__gz8z9a';\nexport var walletListContent = 'ConnectModal_walletListContent__gz8z98';\nexport var whatIsAWalletButton = 'ConnectModal_whatIsAWalletButton__gz8z93';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Slot } from '@radix-ui/react-slot';\nimport clsx from 'clsx';\nimport type { ButtonHTMLAttributes } from 'react';\nimport { forwardRef } from 'react';\n\nimport { buttonVariants } from './Button.css.js';\nimport type { ButtonVariants } from './Button.css.js';\n\ntype ButtonProps = {\n\tasChild?: boolean;\n} & ButtonHTMLAttributes<HTMLButtonElement> &\n\tButtonVariants;\n\nconst Button = forwardRef<HTMLButtonElement, ButtonProps>(\n\t({ className, variant, size, asChild = false, ...props }, forwardedRef) => {\n\t\tconst Comp = asChild ? Slot : 'button';\n\t\treturn (\n\t\t\t<Comp\n\t\t\t\t{...props}\n\t\t\t\tclassName={clsx(buttonVariants({ variant, size }), className)}\n\t\t\t\tref={forwardedRef}\n\t\t\t/>\n\t\t);\n\t},\n);\nButton.displayName = 'Button';\n\nexport { Button };\n", "import 'src/components/ui/Button.css.ts.vanilla.css?source=#H4sIAAAAAAAAA62TwVLCMBCG732KPcohDEV0mPSmF59Aj520Ce1KmsQkhVaHd3fS0gGsIoyemtl/d79/N+n0ofZeqzTrPs/MIlPepWkTu2X8NoOPCICjM5K1FFBJVIKspGiSCIBJLBRBLypHIRfKCxvCr7XzuGpJrpUXyh9LK6082QosSk9hw+wNIZwZQ9boSdBeOsmRSnCsq0kS7aLpeYOUo2OZFLxzqg3L0bcUZtO7M8Wb/pAaixWz7dAs7npkLF8XVteKk1xLbUdGDwmPQXdk36ZnTcKc3xfmP6VnuiGuZFxvRzV9eFx09Wy01Bth/2PCp9DoEgu69uG9DBbmPVxbLizZIvclhdg0ySHofCsFBacl8qPwDyY7cW9wj7r0Cr6mXz3Kn7Z5Qv91mw7fRVrxAX17vEXLONZuRAxhPPxEAIZxjqqgsDQNxPdh6ed5shh4i4t5ktlCnOICCuYL00AS7T4BZ4uE22sEAAA=';\nimport { createRuntimeFn as _7a468 } from '@vanilla-extract/recipes/createRuntimeFn';\nexport var buttonVariants = _7a468({defaultClassName:'Button_buttonVariants__x1s81q0',variantClassNames:{variant:{primary:'Button_buttonVariants_variant_primary__x1s81q1',outline:'Button_buttonVariants_variant_outline__x1s81q2'},size:{md:'Button_buttonVariants_size_md__x1s81q3',lg:'Button_buttonVariants_size_lg__x1s81q4'}},defaultVariants:{variant:'primary',size:'md'},compoundVariants:[]});", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Slot } from '@radix-ui/react-slot';\nimport clsx from 'clsx';\nimport { forwardRef } from 'react';\n\nimport { textVariants } from './Text.css.js';\nimport type { TextVariants } from './Text.css.js';\n\ntype TextAsChildProps = {\n\tasChild?: boolean;\n\tas?: never;\n};\n\ntype TextDivProps = { as: 'div'; asChild?: never };\n\ntype TextProps = (TextAsChildProps | TextDivProps) &\n\tReact.HTMLAttributes<HTMLDivElement> &\n\tTextVariants;\n\nconst Text = forwardRef<HTMLDivElement, TextProps>(\n\t(\n\t\t{\n\t\t\tchildren,\n\t\t\tclassName,\n\t\t\tasChild = false,\n\t\t\tas: Tag = 'div',\n\t\t\tsize,\n\t\t\tweight,\n\t\t\tcolor,\n\t\t\tmono,\n\t\t\t...textProps\n\t\t},\n\t\tforwardedRef,\n\t) => {\n\t\treturn (\n\t\t\t<Slot\n\t\t\t\t{...textProps}\n\t\t\t\tref={forwardedRef}\n\t\t\t\tclassName={clsx(textVariants({ size, weight, color, mono }), className)}\n\t\t\t>\n\t\t\t\t{asChild ? children : <Tag>{children}</Tag>}\n\t\t\t</Slot>\n\t\t);\n\t},\n);\nText.displayName = 'Text';\n\nexport { Text };\n", "import 'src/components/ui/Text.css.ts.vanilla.css?source=LlRleHRfdGV4dFZhcmlhbnRzX3NpemVfc21fXzJidjF1cjEgewogIGZvbnQtc2l6ZTogdmFyKC0tZGFwcC1raXQtZm9udFNpemVzLXNtYWxsKTsKfQouVGV4dF90ZXh0VmFyaWFudHNfd2VpZ2h0X25vcm1hbF9fMmJ2MXVyMiB7CiAgZm9udC13ZWlnaHQ6IHZhcigtLWRhcHAta2l0LWZvbnRXZWlnaHRzLW5vcm1hbCk7Cn0KLlRleHRfdGV4dFZhcmlhbnRzX3dlaWdodF9tZWRpdW1fXzJidjF1cjMgewogIGZvbnQtd2VpZ2h0OiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1tZWRpdW0pOwp9Ci5UZXh0X3RleHRWYXJpYW50c193ZWlnaHRfYm9sZF9fMmJ2MXVyNCB7CiAgZm9udC13ZWlnaHQ6IHZhcigtLWRhcHAta2l0LWZvbnRXZWlnaHRzLWJvbGQpOwp9Ci5UZXh0X3RleHRWYXJpYW50c19jb2xvcl9tdXRlZF9fMmJ2MXVyNSB7CiAgY29sb3I6IHZhcigtLWRhcHAta2l0LWNvbG9ycy1ib2R5TXV0ZWQpOwp9Ci5UZXh0X3RleHRWYXJpYW50c19jb2xvcl9kYW5nZXJfXzJidjF1cjYgewogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keURhbmdlcik7Cn0KLlRleHRfdGV4dFZhcmlhbnRzX21vbm9fdHJ1ZV9fMmJ2MXVyNyB7CiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCAiTGliZXJhdGlvbiBNb25vIiwgIkNvdXJpZXIgTmV3IiwgbW9ub3NwYWNlOwp9';\nimport { createRuntimeFn as _7a468 } from '@vanilla-extract/recipes/createRuntimeFn';\nexport var textVariants = _7a468({defaultClassName:'Text__2bv1ur0',variantClassNames:{size:{sm:'Text_textVariants_size_sm__2bv1ur1'},weight:{normal:'Text_textVariants_weight_normal__2bv1ur2',medium:'Text_textVariants_weight_medium__2bv1ur3',bold:'Text_textVariants_weight_bold__2bv1ur4'},color:{muted:'Text_textVariants_color_muted__2bv1ur5',danger:'Text_textVariants_color_danger__2bv1ur6'},mono:{true:'Text_textVariants_mono_true__2bv1ur7'}},defaultVariants:{size:'sm',weight:'normal'},compoundVariants:[]});", "import 'src/components/connect-modal/views/ConnectionStatus.css.ts.vanilla.css?source=LkNvbm5lY3Rpb25TdGF0dXNfY29udGFpbmVyX19uY2ttMmQwIHsKICBkaXNwbGF5OiBmbGV4OwogIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7CiAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICB3aWR0aDogMTAwJTsKfQouQ29ubmVjdGlvblN0YXR1c193YWxsZXRJY29uX19uY2ttMmQxIHsKICBvYmplY3QtZml0OiBjb3ZlcjsKICB3aWR0aDogNzJweDsKICBoZWlnaHQ6IDcycHg7CiAgYm9yZGVyLXJhZGl1czogdmFyKC0tZGFwcC1raXQtcmFkaWktbGFyZ2UpOwp9Ci5Db25uZWN0aW9uU3RhdHVzX3RpdGxlX19uY2ttMmQyIHsKICBtYXJnaW4tdG9wOiAxMnB4Owp9Ci5Db25uZWN0aW9uU3RhdHVzX2Nvbm5lY3Rpb25TdGF0dXNfX25ja20yZDMgewogIG1hcmdpbi10b3A6IDRweDsKfQouQ29ubmVjdGlvblN0YXR1c19yZXRyeUJ1dHRvbkNvbnRhaW5lcl9fbmNrbTJkNCB7CiAgcG9zaXRpb246IGFic29sdXRlOwogIGJvdHRvbTogMjBweDsKICByaWdodDogMjBweDsKfQ==';\nexport var connectionStatus = 'ConnectionStatus_connectionStatus__nckm2d3';\nexport var container = 'ConnectionStatus_container__nckm2d0';\nexport var retryButtonContainer = 'ConnectionStatus_retryButtonContainer__nckm2d4';\nexport var title = 'ConnectionStatus_title__nckm2d2';\nexport var walletIcon = 'ConnectionStatus_walletIcon__nckm2d1';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithRequiredFeatures } from '@mysten/wallet-standard';\n\nimport { Button } from '../../ui/Button.js';\nimport { Heading } from '../../ui/Heading.js';\nimport { Text } from '../../ui/Text.js';\nimport * as styles from './ConnectionStatus.css.js';\n\ntype ConnectionStatusProps = {\n\tselectedWallet: WalletWithRequiredFeatures;\n\thadConnectionError: boolean;\n\tonRetryConnection: (selectedWallet: WalletWithRequiredFeatures) => void;\n};\n\nexport function ConnectionStatus({\n\tselectedWallet,\n\thadConnectionError,\n\tonRetryConnection,\n}: ConnectionStatusProps) {\n\treturn (\n\t\t<div className={styles.container}>\n\t\t\t{selectedWallet.icon && (\n\t\t\t\t<img\n\t\t\t\t\tclassName={styles.walletIcon}\n\t\t\t\t\tsrc={selectedWallet.icon}\n\t\t\t\t\talt={`${selectedWallet.name} logo`}\n\t\t\t\t/>\n\t\t\t)}\n\t\t\t<div className={styles.title}>\n\t\t\t\t<Heading as=\"h2\" size=\"xl\">\n\t\t\t\t\tOpening {selectedWallet.name}\n\t\t\t\t</Heading>\n\t\t\t</div>\n\t\t\t<div className={styles.connectionStatus}>\n\t\t\t\t{hadConnectionError ? (\n\t\t\t\t\t<Text color=\"danger\">Connection failed</Text>\n\t\t\t\t) : (\n\t\t\t\t\t<Text color=\"muted\">Confirm connection in the wallet...</Text>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t{hadConnectionError ? (\n\t\t\t\t<div className={styles.retryButtonContainer}>\n\t\t\t\t\t<Button type=\"button\" variant=\"outline\" onClick={() => onRetryConnection(selectedWallet)}>\n\t\t\t\t\t\tRetry Connection\n\t\t\t\t\t</Button>\n\t\t\t\t</div>\n\t\t\t) : null}\n\t\t</div>\n\t);\n}\n", "import 'src/components/connect-modal/InfoSection.css.ts.vanilla.css?source=LkluZm9TZWN0aW9uX2NvbnRhaW5lcl9fMXd0aW9pNzAgewogIGRpc3BsYXk6IGZsZXg7CiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICBnYXA6IDRweDsKfQ==';\nexport var container = 'InfoSection_container__1wtioi70';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Heading } from '../ui/Heading.js';\nimport { Text } from '../ui/Text.js';\nimport * as styles from './InfoSection.css.js';\n\ntype InfoSectionProps = {\n\ttitle: string;\n\tchildren: string;\n};\n\nexport function InfoSection({ title, children }: InfoSectionProps) {\n\treturn (\n\t\t<section className={styles.container}>\n\t\t\t<Heading as=\"h3\" size=\"sm\" weight=\"normal\">\n\t\t\t\t{title}\n\t\t\t</Heading>\n\t\t\t<Text weight=\"medium\" color=\"muted\">\n\t\t\t\t{children}\n\t\t\t</Text>\n\t\t</section>\n\t);\n}\n", "import 'src/components/connect-modal/views/GettingStarted.css.ts.vanilla.css?source=LkdldHRpbmdTdGFydGVkX2NvbnRhaW5lcl9fMWZwMDdlMTAgewogIGRpc3BsYXk6IGZsZXg7CiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICBhbGlnbi1pdGVtczogY2VudGVyOwp9Ci5HZXR0aW5nU3RhcnRlZF9jb250ZW50X18xZnAwN2UxMSB7CiAgZGlzcGxheTogZmxleDsKICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogIGp1c3RpZnktY29udGVudDogY2VudGVyOwogIGZsZXgtZ3JvdzogMTsKICBnYXA6IDIwcHg7CiAgcGFkZGluZzogNDBweDsKfQouR2V0dGluZ1N0YXJ0ZWRfaW5zdGFsbEJ1dHRvbkNvbnRhaW5lcl9fMWZwMDdlMTIgewogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICBib3R0b206IDIwcHg7CiAgcmlnaHQ6IDIwcHg7Cn0=';\nexport var container = 'GettingStarted_container__1fp07e10';\nexport var content = 'GettingStarted_content__1fp07e11';\nexport var installButtonContainer = 'GettingStarted_installButtonContainer__1fp07e12';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Button } from '../../ui/Button.js';\nimport { Heading } from '../../ui/Heading.js';\nimport { InfoSection } from '../InfoSection.js';\nimport * as styles from './GettingStarted.css.js';\n\nexport function GettingStarted() {\n\treturn (\n\t\t<div className={styles.container}>\n\t\t\t<Heading as=\"h2\">Get Started with Sui</Heading>\n\t\t\t<div className={styles.content}>\n\t\t\t\t<InfoSection title=\"Install the Sui Wallet Extension\">\n\t\t\t\t\tWe recommend pinning Sui Wallet to your taskbar for quicker access.\n\t\t\t\t</InfoSection>\n\t\t\t\t<InfoSection title=\"Create or Import a Wallet\">\n\t\t\t\t\tBe sure to back up your wallet using a secure method. Never share your secret phrase with\n\t\t\t\t\tanyone.\n\t\t\t\t</InfoSection>\n\t\t\t\t<InfoSection title=\"Refresh Your Browser\">\n\t\t\t\t\tOnce you set up your wallet, refresh this window browser to load up the extension.\n\t\t\t\t</InfoSection>\n\t\t\t\t<div className={styles.installButtonContainer}>\n\t\t\t\t\t<Button variant=\"outline\" asChild>\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\thref=\"https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil\"\n\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\trel=\"noreferrer\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tInstall Wallet Extension\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</Button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n", "import 'src/components/connect-modal/views/WhatIsAWallet.css.ts.vanilla.css?source=LldoYXRJc0FXYWxsZXRfY29udGFpbmVyX18xa3Rwa3E5MCB7CiAgZGlzcGxheTogZmxleDsKICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogIGFsaWduLWl0ZW1zOiBjZW50ZXI7Cn0KLldoYXRJc0FXYWxsZXRfY29udGVudF9fMWt0cGtxOTEgewogIGRpc3BsYXk6IGZsZXg7CiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICBmbGV4LWdyb3c6IDE7CiAgZ2FwOiAyMHB4OwogIHBhZGRpbmc6IDQwcHg7Cn0=';\nexport var container = 'WhatIsAWallet_container__1ktpkq90';\nexport var content = 'WhatIsAWallet_content__1ktpkq91';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Heading } from '../../ui/Heading.js';\nimport { InfoSection } from '../InfoSection.js';\nimport * as styles from './WhatIsAWallet.css.js';\n\nexport function WhatIsAWallet() {\n\treturn (\n\t\t<div className={styles.container}>\n\t\t\t<Heading as=\"h2\">What is a Wallet</Heading>\n\t\t\t<div className={styles.content}>\n\t\t\t\t<InfoSection title=\"Easy Login\">\n\t\t\t\t\tNo need to create new accounts and passwords for every website. Just connect your wallet\n\t\t\t\t\tand get going.\n\t\t\t\t</InfoSection>\n\t\t\t\t<InfoSection title=\"Store your Digital Assets\">\n\t\t\t\t\tSend, receive, store, and display your digital assets like NFTs & coins.\n\t\t\t\t</InfoSection>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ComponentProps } from 'react';\n\nexport function SuiIcon(props: ComponentProps<'svg'>) {\n\treturn (\n\t\t<svg width={28} height={28} fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" {...props}>\n\t\t\t<rect width={28} height={28} rx={6} fill=\"#6FBCF0\" />\n\t\t\t<path\n\t\t\t\tfillRule=\"evenodd\"\n\t\t\t\tclipRule=\"evenodd\"\n\t\t\t\td=\"M7.942 20.527A6.875 6.875 0 0 0 13.957 24c2.51 0 4.759-1.298 6.015-3.473a6.875 6.875 0 0 0 0-6.945l-5.29-9.164a.837.837 0 0 0-1.45 0l-5.29 9.164a6.875 6.875 0 0 0 0 6.945Zm4.524-11.75 1.128-1.953a.418.418 0 0 1 .725 0l4.34 7.516a5.365 5.365 0 0 1 .449 4.442 4.675 4.675 0 0 0-.223-.73c-.599-1.512-1.954-2.68-4.029-3.47-1.426-.54-2.336-1.336-2.706-2.364-.476-1.326.021-2.77.316-3.44Zm-1.923 3.332L9.255 14.34a5.373 5.373 0 0 0 0 5.43 5.373 5.373 0 0 0 4.702 2.714 5.38 5.38 0 0 0 3.472-1.247c.125-.314.51-1.462.034-2.646-.44-1.093-1.5-1.965-3.15-2.594-1.864-.707-3.076-1.811-3.6-3.28a4.601 4.601 0 0 1-.17-.608Z\"\n\t\t\t\tfill=\"#fff\"\n\t\t\t/>\n\t\t</svg>\n\t);\n}\n", "import 'src/components/connect-modal/wallet-list/WalletList.css.ts.vanilla.css?source=LldhbGxldExpc3RfY29udGFpbmVyX18xdjJzNmN6MCB7CiAgZGlzcGxheTogZmxleDsKICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogIGdhcDogNHB4Owp9';\nexport var container = 'WalletList_container__1v2s6cz0';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { clsx } from 'clsx';\nimport type { ReactNode } from 'react';\n\nimport { Heading } from '../../ui/Heading.js';\nimport * as styles from './WalletListItem.css.js';\n\ntype WalletListItemProps = {\n\tname: string;\n\ticon: ReactNode;\n\tisSelected?: boolean;\n\tonClick: () => void;\n};\n\nexport function WalletListItem({ name, icon, onClick, isSelected = false }: WalletListItemProps) {\n\treturn (\n\t\t<li className={styles.container}>\n\t\t\t<button\n\t\t\t\tclassName={clsx(styles.walletItem, { [styles.selectedWalletItem]: isSelected })}\n\t\t\t\ttype=\"button\"\n\t\t\t\tonClick={onClick}\n\t\t\t>\n\t\t\t\t{icon && typeof icon === 'string' ? (\n\t\t\t\t\t<img className={styles.walletIcon} src={icon} alt={`${name} logo`} />\n\t\t\t\t) : (\n\t\t\t\t\ticon\n\t\t\t\t)}\n\t\t\t\t<Heading size=\"md\" truncate asChild>\n\t\t\t\t\t<div>{name}</div>\n\t\t\t\t</Heading>\n\t\t\t</button>\n\t\t</li>\n\t);\n}\n", "import 'src/components/connect-modal/wallet-list/WalletListItem.css.ts.vanilla.css?source=LldhbGxldExpc3RJdGVtX2NvbnRhaW5lcl9fMWRxcXRxczAgewogIGRpc3BsYXk6IGZsZXg7Cn0KLldhbGxldExpc3RJdGVtX3dhbGxldEl0ZW1fXzFkcXF0cXMxIHsKICBkaXNwbGF5OiBmbGV4OwogIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgZmxleC1ncm93OiAxOwogIHBhZGRpbmc6IDhweDsKICBnYXA6IDhweDsKICBib3JkZXItcmFkaXVzOiB2YXIoLS1kYXBwLWtpdC1yYWRpaS1sYXJnZSk7Cn0KLldhbGxldExpc3RJdGVtX3dhbGxldEl0ZW1fXzFkcXF0cXMxOmhvdmVyIHsKICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kYXBwLWtpdC1iYWNrZ3JvdW5kQ29sb3JzLXdhbGxldEl0ZW1Ib3Zlcik7Cn0KLldhbGxldExpc3RJdGVtX3NlbGVjdGVkV2FsbGV0SXRlbV9fMWRxcXRxczIgewogIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWRhcHAta2l0LWJhY2tncm91bmRDb2xvcnMtd2FsbGV0SXRlbVNlbGVjdGVkKTsKICBib3gtc2hhZG93OiAwcHggMnB4IDZweCByZ2JhKDAsIDAsIDAsIDAuMDUpOwp9Ci5XYWxsZXRMaXN0SXRlbV93YWxsZXRJY29uX18xZHFxdHFzMyB7CiAgd2lkdGg6IDI4cHg7CiAgaGVpZ2h0OiAyOHB4OwogIGZsZXgtc2hyaW5rOiAwOwogIG9iamVjdC1maXQ6IGNvdmVyOwogIGJvcmRlci1yYWRpdXM6IHZhcigtLWRhcHAta2l0LXJhZGlpLXNtYWxsKTsKfQ==';\nexport var container = 'WalletListItem_container__1dqqtqs0';\nexport var selectedWalletItem = 'WalletListItem_selectedWalletItem__1dqqtqs2';\nexport var walletIcon = 'WalletListItem_walletIcon__1dqqtqs3';\nexport var walletItem = 'WalletListItem_walletItem__1dqqtqs1';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithRequiredFeatures } from '@mysten/wallet-standard';\n\nimport { getWalletUniqueIdentifier } from '../../../utils/walletUtils.js';\nimport { SuiIcon } from '../../icons/SuiIcon.js';\nimport * as styles from './WalletList.css.js';\nimport { WalletListItem } from './WalletListItem.js';\n\ntype WalletListProps = {\n\tselectedWalletName?: string;\n\tonPlaceholderClick: () => void;\n\tonSelect: (wallet: WalletWithRequiredFeatures) => void;\n\twallets: WalletWithRequiredFeatures[];\n};\n\nexport function WalletList({\n\tselectedWalletName,\n\tonPlaceholderClick,\n\tonSelect,\n\twallets,\n}: WalletListProps) {\n\treturn (\n\t\t<ul className={styles.container}>\n\t\t\t{wallets.length > 0 ? (\n\t\t\t\twallets.map((wallet) => (\n\t\t\t\t\t<WalletListItem\n\t\t\t\t\t\tkey={getWalletUniqueIdentifier(wallet)}\n\t\t\t\t\t\tname={wallet.name}\n\t\t\t\t\t\ticon={wallet.icon}\n\t\t\t\t\t\tisSelected={getWalletUniqueIdentifier(wallet) === selectedWalletName}\n\t\t\t\t\t\tonClick={() => onSelect(wallet)}\n\t\t\t\t\t/>\n\t\t\t\t))\n\t\t\t) : (\n\t\t\t\t<WalletListItem\n\t\t\t\t\tname=\"Sui Wallet\"\n\t\t\t\t\ticon={<SuiIcon />}\n\t\t\t\t\tonClick={onPlaceholderClick}\n\t\t\t\t\tisSelected\n\t\t\t\t/>\n\t\t\t)}\n\t\t</ul>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletAccount } from '@mysten/wallet-standard';\n\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Retrieves the wallet account that is currently selected, if one exists.\n */\nexport function useCurrentAccount(): WalletAccount | null {\n\treturn useWalletStore((state) => state.currentAccount);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { formatAddress } from '@mysten/sui/utils';\nimport type { WalletAccount } from '@mysten/wallet-standard';\nimport * as DropdownMenu from '@radix-ui/react-dropdown-menu';\nimport clsx from 'clsx';\n\nimport { useResolveSuiNSName } from '../hooks/useResolveSuiNSNames.js';\nimport { useAccounts } from '../hooks/wallet/useAccounts.js';\nimport { useDisconnectWallet } from '../hooks/wallet/useDisconnectWallet.js';\nimport { useSwitchAccount } from '../hooks/wallet/useSwitchAccount.js';\nimport * as styles from './AccountDropdownMenu.css.js';\nimport { CheckIcon } from './icons/CheckIcon.js';\nimport { ChevronIcon } from './icons/ChevronIcon.js';\nimport { StyleMarker } from './styling/StyleMarker.js';\nimport { Button } from './ui/Button.js';\nimport { Text } from './ui/Text.js';\n\ntype AccountDropdownMenuProps = {\n\tcurrentAccount: WalletAccount;\n};\n\nexport function AccountDropdownMenu({ currentAccount }: AccountDropdownMenuProps) {\n\tconst { mutate: disconnectWallet } = useDisconnectWallet();\n\n\tconst { data: domain } = useResolveSuiNSName(\n\t\tcurrentAccount.label ? null : currentAccount.address,\n\t);\n\tconst accounts = useAccounts();\n\n\treturn (\n\t\t<DropdownMenu.Root modal={false}>\n\t\t\t<StyleMarker>\n\t\t\t\t<DropdownMenu.Trigger asChild>\n\t\t\t\t\t<Button size=\"lg\" className={styles.connectedAccount}>\n\t\t\t\t\t\t<Text mono weight=\"bold\">\n\t\t\t\t\t\t\t{currentAccount.label ?? domain ?? formatAddress(currentAccount.address)}\n\t\t\t\t\t\t</Text>\n\t\t\t\t\t\t<ChevronIcon />\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenu.Trigger>\n\t\t\t</StyleMarker>\n\t\t\t<DropdownMenu.Portal>\n\t\t\t\t<StyleMarker className={styles.menuContainer}>\n\t\t\t\t\t<DropdownMenu.Content className={styles.menuContent}>\n\t\t\t\t\t\t{accounts.map((account) => (\n\t\t\t\t\t\t\t<AccountDropdownMenuItem\n\t\t\t\t\t\t\t\tkey={account.address}\n\t\t\t\t\t\t\t\taccount={account}\n\t\t\t\t\t\t\t\tactive={currentAccount.address === account.address}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\t\t\t\t\t\t<DropdownMenu.Separator className={styles.separator} />\n\t\t\t\t\t\t<DropdownMenu.Item\n\t\t\t\t\t\t\tclassName={clsx(styles.menuItem)}\n\t\t\t\t\t\t\tonSelect={() => disconnectWallet()}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tDisconnect\n\t\t\t\t\t\t</DropdownMenu.Item>\n\t\t\t\t\t</DropdownMenu.Content>\n\t\t\t\t</StyleMarker>\n\t\t\t</DropdownMenu.Portal>\n\t\t</DropdownMenu.Root>\n\t);\n}\n\nexport function AccountDropdownMenuItem({\n\taccount,\n\tactive,\n}: {\n\taccount: WalletAccount;\n\tactive?: boolean;\n}) {\n\tconst { mutate: switchAccount } = useSwitchAccount();\n\tconst { data: domain } = useResolveSuiNSName(account.label ? null : account.address);\n\n\treturn (\n\t\t<DropdownMenu.Item\n\t\t\tclassName={clsx(styles.menuItem, styles.switchAccountMenuItem)}\n\t\t\tonSelect={() => switchAccount({ account })}\n\t\t>\n\t\t\t<Text mono>{account.label ?? domain ?? formatAddress(account.address)}</Text>\n\t\t\t{active ? <CheckIcon /> : null}\n\t\t</DropdownMenu.Item>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui/client';\nimport type {\n\tUndefinedInitialDataOptions,\n\tUseQueryOptions,\n\tUseQueryResult,\n} from '@tanstack/react-query';\nimport { queryOptions, useQuery, useSuspenseQuery } from '@tanstack/react-query';\nimport { useMemo } from 'react';\n\nimport type { PartialBy } from '../types/utilityTypes.js';\nimport { useSuiClientContext } from './useSuiClient.js';\n\nexport type SuiRpcMethodName = {\n\t[K in keyof SuiClient]: SuiClient[K] extends ((input: any) => Promise<any>) | (() => Promise<any>)\n\t\t? K\n\t\t: never;\n}[keyof SuiClient];\n\nexport type SuiRpcMethods = {\n\t[K in SuiRpcMethodName]: SuiClient[K] extends (input: infer P) => Promise<infer R>\n\t\t? {\n\t\t\t\tname: K;\n\t\t\t\tresult: R;\n\t\t\t\tparams: P;\n\t\t\t}\n\t\t: SuiClient[K] extends () => Promise<infer R>\n\t\t\t? {\n\t\t\t\t\tname: K;\n\t\t\t\t\tresult: R;\n\t\t\t\t\tparams: undefined | object;\n\t\t\t\t}\n\t\t\t: never;\n};\n\nexport type UseSuiClientQueryOptions<T extends keyof SuiRpcMethods, TData> = PartialBy<\n\tOmit<UseQueryOptions<SuiRpcMethods[T]['result'], Error, TData, unknown[]>, 'queryFn'>,\n\t'queryKey'\n>;\n\nexport type GetSuiClientQueryOptions<T extends keyof SuiRpcMethods> = {\n\tclient: SuiClient;\n\tnetwork: string;\n\tmethod: T;\n\toptions?: PartialBy<\n\t\tOmit<UndefinedInitialDataOptions<SuiRpcMethods[T]['result']>, 'queryFn'>,\n\t\t'queryKey'\n\t>;\n} & (undefined extends SuiRpcMethods[T]['params']\n\t? { params?: SuiRpcMethods[T]['params'] }\n\t: { params: SuiRpcMethods[T]['params'] });\n\nexport function getSuiClientQuery<T extends keyof SuiRpcMethods>({\n\tclient,\n\tnetwork,\n\tmethod,\n\tparams,\n\toptions,\n}: GetSuiClientQueryOptions<T>) {\n\treturn queryOptions<SuiRpcMethods[T]['result']>({\n\t\t...options,\n\t\tqueryKey: [network, method, params],\n\t\tqueryFn: async () => {\n\t\t\treturn await client[method](params as never);\n\t\t},\n\t});\n}\n\nexport function useSuiClientQuery<\n\tT extends keyof SuiRpcMethods,\n\tTData = SuiRpcMethods[T]['result'],\n>(\n\t...args: undefined extends SuiRpcMethods[T]['params']\n\t\t? [method: T, params?: SuiRpcMethods[T]['params'], options?: UseSuiClientQueryOptions<T, TData>]\n\t\t: [method: T, params: SuiRpcMethods[T]['params'], options?: UseSuiClientQueryOptions<T, TData>]\n): UseQueryResult<TData, Error> {\n\tconst [method, params, { queryKey = [], ...options } = {}] = args as [\n\t\tmethod: T,\n\t\tparams?: SuiRpcMethods[T]['params'],\n\t\toptions?: UseSuiClientQueryOptions<T, TData>,\n\t];\n\n\tconst suiContext = useSuiClientContext();\n\n\treturn useQuery({\n\t\t...options,\n\t\tqueryKey: [suiContext.network, method, params, ...queryKey],\n\t\tqueryFn: async () => {\n\t\t\treturn await suiContext.client[method](params as never);\n\t\t},\n\t});\n}\n\nexport function useSuiClientSuspenseQuery<\n\tT extends keyof SuiRpcMethods,\n\tTData = SuiRpcMethods[T]['result'],\n>(\n\t...args: undefined extends SuiRpcMethods[T]['params']\n\t\t? [method: T, params?: SuiRpcMethods[T]['params'], options?: UndefinedInitialDataOptions<TData>]\n\t\t: [method: T, params: SuiRpcMethods[T]['params'], options?: UndefinedInitialDataOptions<TData>]\n) {\n\tconst [method, params, options = {}] = args as [\n\t\tmethod: T,\n\t\tparams?: SuiRpcMethods[T]['params'],\n\t\toptions?: UndefinedInitialDataOptions<TData>,\n\t];\n\n\tconst suiContext = useSuiClientContext();\n\n\tconst query = useMemo(() => {\n\t\treturn getSuiClientQuery<T>({\n\t\t\tclient: suiContext.client,\n\t\t\tnetwork: suiContext.network,\n\t\t\tmethod,\n\t\t\tparams,\n\t\t\toptions,\n\t\t});\n\t}, [suiContext.client, suiContext.network, method, params, options]);\n\n\treturn useSuspenseQuery(query);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui/client';\nimport { useContext } from 'react';\n\nimport { SuiClientContext } from '../components/SuiClientProvider.js';\n\nexport function useSuiClientContext() {\n\tconst suiClient = useContext(SuiClientContext);\n\n\tif (!suiClient) {\n\t\tthrow new Error(\n\t\t\t'Could not find SuiClientContext. Ensure that you have set up the SuiClientProvider',\n\t\t);\n\t}\n\n\treturn suiClient;\n}\n\nexport function useSuiClient(): SuiClient {\n\treturn useSuiClientContext().client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getFullnodeUrl, isSuiClient, SuiClient } from '@mysten/sui/client';\nimport type { SuiClientOptions } from '@mysten/sui/client';\nimport { createContext, useMemo, useState } from 'react';\n\nimport type { NetworkConfig } from '../hooks/networkConfig.js';\n\ntype NetworkConfigs<T extends NetworkConfig | SuiClient = NetworkConfig | SuiClient> = Record<\n\tstring,\n\tT\n>;\n\nexport interface SuiClientProviderContext {\n\tclient: SuiClient;\n\tnetworks: NetworkConfigs;\n\tnetwork: string;\n\tconfig: NetworkConfig | null;\n\tselectNetwork: (network: string) => void;\n}\n\nexport const SuiClientContext = createContext<SuiClientProviderContext | null>(null);\n\nexport type SuiClientProviderProps<T extends NetworkConfigs> = {\n\tcreateClient?: (name: keyof T, config: T[keyof T]) => SuiClient;\n\tchildren: React.ReactNode;\n\tnetworks?: T;\n\tonNetworkChange?: (network: keyof T & string) => void;\n} & (\n\t| {\n\t\t\tdefaultNetwork?: keyof T & string;\n\t\t\tnetwork?: never;\n\t  }\n\t| {\n\t\t\tdefaultNetwork?: never;\n\t\t\tnetwork?: keyof T & string;\n\t  }\n);\n\nconst DEFAULT_NETWORKS = {\n\tlocalnet: { url: getFullnodeUrl('localnet') },\n};\n\nconst DEFAULT_CREATE_CLIENT = function createClient(\n\t_name: string,\n\tconfig: NetworkConfig | SuiClient,\n) {\n\tif (isSuiClient(config)) {\n\t\treturn config;\n\t}\n\n\treturn new SuiClient(config);\n};\n\nexport function SuiClientProvider<T extends NetworkConfigs>(props: SuiClientProviderProps<T>) {\n\tconst { onNetworkChange, network, children } = props;\n\tconst networks = (props.networks ?? DEFAULT_NETWORKS) as T;\n\tconst createClient =\n\t\t(props.createClient as typeof DEFAULT_CREATE_CLIENT) ?? DEFAULT_CREATE_CLIENT;\n\n\tconst [selectedNetwork, setSelectedNetwork] = useState<keyof T & string>(\n\t\tprops.network ?? props.defaultNetwork ?? (Object.keys(networks)[0] as keyof T & string),\n\t);\n\n\tconst currentNetwork = props.network ?? selectedNetwork;\n\n\tconst client = useMemo(() => {\n\t\treturn createClient(currentNetwork, networks[currentNetwork]);\n\t}, [createClient, currentNetwork, networks]);\n\n\tconst ctx = useMemo((): SuiClientProviderContext => {\n\t\treturn {\n\t\t\tclient,\n\t\t\tnetworks,\n\t\t\tnetwork: currentNetwork,\n\t\t\tconfig:\n\t\t\t\tnetworks[currentNetwork] instanceof SuiClient\n\t\t\t\t\t? null\n\t\t\t\t\t: (networks[currentNetwork] as SuiClientOptions),\n\t\t\tselectNetwork: (newNetwork) => {\n\t\t\t\tif (currentNetwork === newNetwork) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!network && newNetwork !== selectedNetwork) {\n\t\t\t\t\tsetSelectedNetwork(newNetwork);\n\t\t\t\t}\n\n\t\t\t\tonNetworkChange?.(newNetwork);\n\t\t\t},\n\t\t};\n\t}, [client, networks, selectedNetwork, currentNetwork, network, onNetworkChange]);\n\n\treturn <SuiClientContext.Provider value={ctx}>{children}</SuiClientContext.Provider>;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ResolvedNameServiceNames } from '@mysten/sui/client';\nimport type { UseQueryOptions, UseQueryResult } from '@tanstack/react-query';\n\nimport { useSuiClientQuery } from './useSuiClientQuery.js';\n\nexport function useResolveSuiNSName(\n\taddress?: string | null,\n\toptions?: Omit<\n\t\tUseQueryOptions<ResolvedNameServiceNames, Error, string | null, unknown[]>,\n\t\t'queryFn' | 'queryKey' | 'select'\n\t>,\n): UseQueryResult<string | null, Error> {\n\treturn useSuiClientQuery(\n\t\t'resolveNameServiceNames',\n\t\t{\n\t\t\taddress: address!,\n\t\t\tlimit: 1,\n\t\t},\n\t\t{\n\t\t\t...options,\n\t\t\trefetchOnWindowFocus: false,\n\t\t\tretry: false,\n\t\t\tselect: (data) => (data.data.length > 0 ? data.data[0] : null),\n\t\t\tenabled: !!address && options?.enabled !== false,\n\t\t},\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletAccount } from '@mysten/wallet-standard';\n\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Retrieves a list of connected accounts authorized by the dApp.\n */\nexport function useAccounts(): readonly WalletAccount[] {\n\treturn useWalletStore((state) => state.accounts);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport { WalletNotConnectedError } from '../../errors/walletErrors.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useWalletStore } from './useWalletStore.js';\n\ntype UseDisconnectWalletError = WalletNotConnectedError | Error;\n\ntype UseDisconnectWalletMutationOptions = Omit<\n\tUseMutationOptions<void, UseDisconnectWalletError, void, unknown>,\n\t'mutationFn'\n>;\n\n/**\n * Mutation hook for disconnecting from an active wallet connection, if currently connected.\n */\nexport function useDisconnectWallet({\n\tmutationKey,\n\t...mutationOptions\n}: UseDisconnectWalletMutationOptions = {}): UseMutationResult<\n\tvoid,\n\tUseDisconnectWalletError,\n\tvoid\n> {\n\tconst { currentWallet } = useCurrentWallet();\n\tconst setWalletDisconnected = useWalletStore((state) => state.setWalletDisconnected);\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.disconnectWallet(mutationKey),\n\t\tmutationFn: async () => {\n\t\t\tif (!currentWallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Wallets aren't required to implement the disconnect feature, so we'll\n\t\t\t\t// optionally call the disconnect feature if it exists and reset the UI\n\t\t\t\t// state on the frontend at a minimum.\n\t\t\t\tawait currentWallet.features['standard:disconnect']?.disconnect();\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('Failed to disconnect the application from the current wallet.', error);\n\t\t\t}\n\n\t\t\tsetWalletDisconnected();\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * An error that is instantiated when someone attempts to perform an action that requires an active wallet connection.\n */\nexport class WalletNotConnectedError extends Error {}\n\n/**\n * An error that is instantiated when someone attempts to perform an action that requires a selected wallet account.\n * This is more of an edge case stemming from the fact that wallets don't technically require you to authorize any\n * accounts when connecting a wallet.\n */\nexport class WalletNoAccountSelectedError extends Error {}\n\n/**\n * An error that is instantiated when someone attempts to perform an action that isn't supported by a wallet.\n */\nexport class WalletFeatureNotSupportedError extends Error {}\n\n/**\n * An error that is instantiated when a wallet account can't be found for a specific wallet.\n */\nexport class WalletAccountNotFoundError extends Error {}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Retrieves the wallet that is currently connected to the dApp, if one exists.\n */\nexport function useCurrentWallet() {\n\tconst currentWallet = useWalletStore((state) => state.currentWallet);\n\tconst connectionStatus = useWalletStore((state) => state.connectionStatus);\n\tconst supportedIntents = useWalletStore((state) => state.supportedIntents);\n\n\tswitch (connectionStatus) {\n\t\tcase 'connecting':\n\t\t\treturn {\n\t\t\t\tconnectionStatus,\n\t\t\t\tcurrentWallet: null,\n\t\t\t\tisDisconnected: false,\n\t\t\t\tisConnecting: true,\n\t\t\t\tisConnected: false,\n\t\t\t\tsupportedIntents: [],\n\t\t\t} as const;\n\t\tcase 'disconnected':\n\t\t\treturn {\n\t\t\t\tconnectionStatus,\n\t\t\t\tcurrentWallet: null,\n\t\t\t\tisDisconnected: true,\n\t\t\t\tisConnecting: false,\n\t\t\t\tisConnected: false,\n\t\t\t\tsupportedIntents: [],\n\t\t\t} as const;\n\t\tcase 'connected': {\n\t\t\treturn {\n\t\t\t\tconnectionStatus,\n\t\t\t\tcurrentWallet: currentWallet!,\n\t\t\t\tisDisconnected: false,\n\t\t\t\tisConnecting: false,\n\t\t\t\tisConnected: true,\n\t\t\t\tsupportedIntents,\n\t\t\t} as const;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletAccount } from '@mysten/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport { WalletAccountNotFoundError, WalletNotConnectedError } from '../../errors/walletErrors.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useWalletStore } from './useWalletStore.js';\n\ntype SwitchAccountArgs = {\n\taccount: WalletAccount;\n};\n\ntype SwitchAccountResult = void;\n\ntype UseSwitchAccountError = WalletNotConnectedError | WalletAccountNotFoundError | Error;\n\ntype UseSwitchAccountMutationOptions = Omit<\n\tUseMutationOptions<SwitchAccountResult, UseSwitchAccountError, SwitchAccountArgs, unknown>,\n\t'mutationFn'\n>;\n\n/**\n * Mutation hook for switching to a specific wallet account.\n */\nexport function useSwitchAccount({\n\tmutationKey,\n\t...mutationOptions\n}: UseSwitchAccountMutationOptions = {}): UseMutationResult<\n\tSwitchAccountResult,\n\tUseSwitchAccountError,\n\tSwitchAccountArgs\n> {\n\tconst { currentWallet } = useCurrentWallet();\n\tconst setAccountSwitched = useWalletStore((state) => state.setAccountSwitched);\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.switchAccount(mutationKey),\n\t\tmutationFn: async ({ account }) => {\n\t\t\tif (!currentWallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\tconst accountToSelect = currentWallet.accounts.find(\n\t\t\t\t(walletAccount) => walletAccount.address === account.address,\n\t\t\t);\n\t\t\tif (!accountToSelect) {\n\t\t\t\tthrow new WalletAccountNotFoundError(\n\t\t\t\t\t`No account with address ${account.address} is connected to ${currentWallet.name}.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsetAccountSwitched(accountToSelect);\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n", "import 'src/components/AccountDropdownMenu.css.ts.vanilla.css?source=#H4sIAAAAAAAAA6VTTW8TMRC951fMkR5cJaFIxT1BuXDoiSNC0dSe7g7xjo09bhIQ/x2tm22qtqFU+GLpzdeb5+fTD87FKvopx+TjRq5I6spFEXJKfh9crTzfLn+EOfyaAXSYLJyn7cXs9+z0ufKBpF5GUWShPNUuWu1Pw+Jpa+H9dF7sQof5y9bDc0kBdxZuAm0vZtBu4zmTU45iwcVQBxkjG/baW1icz1PLHHBreuKuVwvL+T2YOxajMVk4u4MSes/S7dd8uDLAdcyessnouRYLt5jfGOMxJbNmbTCbgLmjk5aNbt3lWMUbF0PMTwoOCZdjvBj/QISTv6rzWWmYpHnbpHnMuxbKplAgpxYkCo1grBpY6AA8ERQDd2JYaSgWHIlSfu3m/0r7q0dF03PXh/FZyH9ri7xetpR5wLz7WFWjHCdQNqyu30euHrE5e95f32tRvtkZd+dGCyWhI3NNuiGSo4IdY0AJM2q8/xnv2tTJlot08HTpM8vawvz/nfRlmjpK8wcGoA4K9QMAAA==';\nexport var connectedAccount = 'AccountDropdownMenu_connectedAccount__div2ql0';\nexport var menuContainer = 'AccountDropdownMenu_menuContainer__div2ql1';\nexport var menuContent = 'AccountDropdownMenu_menuContent__div2ql2';\nexport var menuItem = 'AccountDropdownMenu_menuItem__div2ql3';\nexport var separator = 'AccountDropdownMenu_separator__div2ql5';\nexport var switchAccountMenuItem = 'AccountDropdownMenu_switchAccountMenuItem__div2ql4';", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ComponentProps } from 'react';\n\nexport function CheckIcon(props: ComponentProps<'svg'>) {\n\treturn (\n\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" width={16} height={16} fill=\"none\" {...props}>\n\t\t\t<path\n\t\t\t\tfill=\"currentColor\"\n\t\t\t\td=\"m11.726 5.048-4.73 5.156-1.722-1.879a.72.72 0 0 0-.529-.23.722.722 0 0 0-.525.24.858.858 0 0 0-.22.573.86.86 0 0 0 .211.576l2.255 2.458c.14.153.332.24.53.24.2 0 .391-.087.532-.24l5.261-5.735A.86.86 0 0 0 13 5.63a.858.858 0 0 0-.22-.572.722.722 0 0 0-.525-.24.72.72 0 0 0-.529.23Z\"\n\t\t\t/>\n\t\t</svg>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ComponentProps } from 'react';\n\nexport function ChevronIcon(props: ComponentProps<'svg'>) {\n\treturn (\n\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" width={16} height={16} fill=\"none\" {...props}>\n\t\t\t<path\n\t\t\t\tstroke=\"#A0B6C3\"\n\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\tstrokeLinejoin=\"round\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\td=\"m4 6 4 4 4-4\"\n\t\t\t/>\n\t\t</svg>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithRequiredFeatures } from '@mysten/wallet-standard';\nimport type { ButtonHTMLAttributes, ReactNode } from 'react';\n\nimport { useCurrentAccount } from '../hooks/wallet/useCurrentAccount.js';\nimport { AccountDropdownMenu } from './AccountDropdownMenu.js';\nimport { ConnectModal } from './connect-modal/ConnectModal.js';\nimport { StyleMarker } from './styling/StyleMarker.js';\nimport { Button } from './ui/Button.js';\n\ntype ConnectButtonProps = {\n\tconnectText?: ReactNode;\n\t/** Filter the wallets shown in the connect modal */\n\twalletFilter?: (wallet: WalletWithRequiredFeatures) => boolean;\n} & ButtonHTMLAttributes<HTMLButtonElement>;\n\nexport function ConnectButton({\n\tconnectText = 'Connect Wallet',\n\twalletFilter,\n\t...buttonProps\n}: ConnectButtonProps) {\n\tconst currentAccount = useCurrentAccount();\n\treturn currentAccount ? (\n\t\t<AccountDropdownMenu currentAccount={currentAccount} />\n\t) : (\n\t\t<ConnectModal\n\t\t\twalletFilter={walletFilter}\n\t\t\ttrigger={\n\t\t\t\t<StyleMarker>\n\t\t\t\t\t<Button {...buttonProps}>{connectText}</Button>\n\t\t\t\t</StyleMarker>\n\t\t\t}\n\t\t/>\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithFeatures, WalletWithRequiredFeatures } from '@mysten/wallet-standard';\nimport type { ReactNode } from 'react';\nimport { useRef } from 'react';\nimport type { StateStorage } from 'zustand/middleware';\n\nimport {\n\tDEFAULT_PREFERRED_WALLETS,\n\tDEFAULT_STORAGE,\n\tDEFAULT_STORAGE_KEY,\n\tDEFAULT_WALLET_FILTER,\n} from '../constants/walletDefaults.js';\nimport { WalletContext } from '../contexts/walletContext.js';\nimport { useAutoConnectWallet } from '../hooks/wallet/useAutoConnectWallet.js';\nimport type { SlushWalletConfig } from '../hooks/wallet/useSlushWallet.js';\nimport { useSlushWallet } from '../hooks/wallet/useSlushWallet.js';\nimport { useUnsafeBurnerWallet } from '../hooks/wallet/useUnsafeBurnerWallet.js';\nimport { useWalletPropertiesChanged } from '../hooks/wallet/useWalletPropertiesChanged.js';\nimport { useWalletsChanged } from '../hooks/wallet/useWalletsChanged.js';\nimport { lightTheme } from '../themes/lightTheme.js';\nimport type { Theme } from '../themes/themeContract.js';\nimport { createInMemoryStore } from '../utils/stateStorage.js';\nimport { getRegisteredWallets } from '../utils/walletUtils.js';\nimport { createWalletStore } from '../walletStore.js';\nimport { InjectedThemeStyles } from './styling/InjectedThemeStyles.js';\n\nexport type WalletProviderProps = {\n\t/** A list of wallets that are sorted to the top of the wallet list, if they are available to connect to. By default, wallets are sorted by the order they are loaded in. */\n\tpreferredWallets?: string[];\n\n\t/** A filter function to select wallets that support features required for the dApp to function. This filters the list of wallets presented to users when selecting a wallet to connect from, ensuring that only wallets that meet the dApps requirements can connect. */\n\twalletFilter?: (wallet: WalletWithRequiredFeatures) => boolean;\n\n\t/** Enables the development-only unsafe burner wallet, which can be useful for testing. */\n\tenableUnsafeBurner?: boolean;\n\n\t/** Enables automatically reconnecting to the most recently used wallet account upon mounting. */\n\tautoConnect?: boolean;\n\n\t/** Enables the Slush wallet */\n\tslushWallet?: SlushWalletConfig;\n\n\t/** Configures how the most recently connected to wallet account is stored. Set to `null` to disable persisting state entirely. Defaults to using localStorage if it is available. */\n\tstorage?: StateStorage | null;\n\n\t/** The key to use to store the most recently connected wallet account. */\n\tstorageKey?: string;\n\n\t/** The theme to use for styling UI components. Defaults to using the light theme. */\n\ttheme?: Theme | null;\n\n\tchildren: ReactNode;\n};\n\nexport type { WalletWithFeatures };\n\nexport function WalletProvider({\n\tpreferredWallets = DEFAULT_PREFERRED_WALLETS,\n\twalletFilter = DEFAULT_WALLET_FILTER,\n\tstorage = DEFAULT_STORAGE,\n\tstorageKey = DEFAULT_STORAGE_KEY,\n\tenableUnsafeBurner = false,\n\tautoConnect = false,\n\tslushWallet,\n\ttheme = lightTheme,\n\tchildren,\n}: WalletProviderProps) {\n\tconst storeRef = useRef(\n\t\tcreateWalletStore({\n\t\t\tautoConnectEnabled: autoConnect,\n\t\t\twallets: getRegisteredWallets(preferredWallets, walletFilter),\n\t\t\tstorage: storage || createInMemoryStore(),\n\t\t\tstorageKey,\n\t\t}),\n\t);\n\n\treturn (\n\t\t<WalletContext.Provider value={storeRef.current}>\n\t\t\t<WalletConnectionManager\n\t\t\t\tpreferredWallets={preferredWallets}\n\t\t\t\twalletFilter={walletFilter}\n\t\t\t\tenableUnsafeBurner={enableUnsafeBurner}\n\t\t\t\tslushWallet={slushWallet}\n\t\t\t>\n\t\t\t\t{/* TODO: We ideally don't want to inject styles if people aren't using the UI components */}\n\t\t\t\t{theme ? <InjectedThemeStyles theme={theme} /> : null}\n\t\t\t\t{children}\n\t\t\t</WalletConnectionManager>\n\t\t</WalletContext.Provider>\n\t);\n}\n\ntype WalletConnectionManagerProps = Pick<\n\tWalletProviderProps,\n\t'preferredWallets' | 'walletFilter' | 'enableUnsafeBurner' | 'slushWallet' | 'children'\n>;\n\nfunction WalletConnectionManager({\n\tpreferredWallets = DEFAULT_PREFERRED_WALLETS,\n\twalletFilter = DEFAULT_WALLET_FILTER,\n\tenableUnsafeBurner = false,\n\tslushWallet,\n\tchildren,\n}: WalletConnectionManagerProps) {\n\tuseWalletsChanged(preferredWallets, walletFilter);\n\tuseWalletPropertiesChanged();\n\tuseSlushWallet(slushWallet);\n\tuseUnsafeBurnerWallet(enableUnsafeBurner);\n\tuseAutoConnectWallet();\n\n\treturn children;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useQuery } from '@tanstack/react-query';\nimport { useLayoutEffect, useState } from 'react';\n\nimport { getWalletUniqueIdentifier } from '../../utils/walletUtils.js';\nimport { useConnectWallet } from './useConnectWallet.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useWallets } from './useWallets.js';\nimport { useWalletStore } from './useWalletStore.js';\n\nexport function useAutoConnectWallet(): 'disabled' | 'idle' | 'attempted' {\n\tconst { mutateAsync: connectWallet } = useConnectWallet();\n\tconst autoConnectEnabled = useWalletStore((state) => state.autoConnectEnabled);\n\tconst lastConnectedWalletName = useWalletStore((state) => state.lastConnectedWalletName);\n\tconst lastConnectedAccountAddress = useWalletStore((state) => state.lastConnectedAccountAddress);\n\tconst wallets = useWallets();\n\tconst { isConnected } = useCurrentWallet();\n\n\tconst [clientOnly, setClientOnly] = useState(false);\n\tuseLayoutEffect(() => {\n\t\tsetClientOnly(true);\n\t}, []);\n\n\tconst { data, isError } = useQuery({\n\t\tqueryKey: [\n\t\t\t'@mysten/dapp-kit',\n\t\t\t'autoconnect',\n\t\t\t{\n\t\t\t\tisConnected,\n\t\t\t\tautoConnectEnabled,\n\t\t\t\tlastConnectedWalletName,\n\t\t\t\tlastConnectedAccountAddress,\n\t\t\t\twalletCount: wallets.length,\n\t\t\t},\n\t\t],\n\t\tqueryFn: async () => {\n\t\t\tif (!autoConnectEnabled) {\n\t\t\t\treturn 'disabled';\n\t\t\t}\n\n\t\t\tif (!lastConnectedWalletName || !lastConnectedAccountAddress || isConnected) {\n\t\t\t\treturn 'attempted';\n\t\t\t}\n\n\t\t\tconst wallet = wallets.find(\n\t\t\t\t(wallet) => getWalletUniqueIdentifier(wallet) === lastConnectedWalletName,\n\t\t\t);\n\t\t\tif (wallet) {\n\t\t\t\tawait connectWallet({\n\t\t\t\t\twallet,\n\t\t\t\t\taccountAddress: lastConnectedAccountAddress,\n\t\t\t\t\tsilent: true,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn 'attempted';\n\t\t},\n\t\tenabled: autoConnectEnabled,\n\t\tpersister: undefined,\n\t\tgcTime: 0,\n\t\tstaleTime: 0,\n\t\tnetworkMode: 'always',\n\t\tretry: false,\n\t\tretryOnMount: false,\n\t\trefetchInterval: false,\n\t\trefetchIntervalInBackground: false,\n\t\trefetchOnMount: false,\n\t\trefetchOnReconnect: false,\n\t\trefetchOnWindowFocus: false,\n\t});\n\n\tif (!autoConnectEnabled) {\n\t\treturn 'disabled';\n\t}\n\n\t// We always initialize with \"idle\" so that in SSR environments, we guarantee that the initial render states always agree:\n\tif (!clientOnly) {\n\t\treturn 'idle';\n\t}\n\n\tif (isConnected) {\n\t\treturn 'attempted';\n\t}\n\n\tif (!lastConnectedWalletName) {\n\t\treturn 'attempted';\n\t}\n\n\treturn isError ? 'attempted' : (data ?? 'idle');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { registerSlushWallet } from '@mysten/slush-wallet';\nimport { useLayoutEffect } from 'react';\n\nexport interface SlushWalletConfig {\n\tname: string;\n\torigin?: string;\n}\n\nexport function useSlushWallet(config?: SlushWalletConfig) {\n\tuseLayoutEffect(() => {\n\t\tif (!config?.name) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet cleanup: (() => void) | undefined;\n\t\tlet isMounted = true;\n\n\t\ttry {\n\t\t\tconst result = registerSlushWallet(config.name, {\n\t\t\t\torigin: config.origin,\n\t\t\t});\n\n\t\t\tif (isMounted && result) {\n\t\t\t\tcleanup = result.unregister;\n\t\t\t} else if (result) {\n\t\t\t\tresult.unregister();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to register Slush wallet:', error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tisMounted = false;\n\t\t\tif (cleanup) cleanup();\n\t\t};\n\t}, [config?.name, config?.origin]);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui/client';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\nimport { Transaction } from '@mysten/sui/transactions';\nimport { toBase64 } from '@mysten/sui/utils';\nimport type {\n\tStandardConnectFeature,\n\tStandardConnectMethod,\n\tStandardEventsFeature,\n\tStandardEventsOnMethod,\n\tSuiFeatures,\n\tSuiSignAndExecuteTransactionBlockMethod,\n\tSuiSignAndExecuteTransactionMethod,\n\tSuiSignPersonalMessageMethod,\n\tSuiSignTransactionBlockMethod,\n\tSuiSignTransactionMethod,\n\tWallet,\n} from '@mysten/wallet-standard';\nimport { getWallets, ReadonlyWalletAccount, SUI_CHAINS } from '@mysten/wallet-standard';\nimport { useEffect } from 'react';\n\nimport { useSuiClient } from '../useSuiClient.js';\n\nconst WALLET_NAME = 'Unsafe Burner Wallet';\n\nexport function useUnsafeBurnerWallet(enabled: boolean) {\n\tconst suiClient = useSuiClient();\n\n\tuseEffect(() => {\n\t\tif (!enabled) {\n\t\t\treturn;\n\t\t}\n\t\tconst unregister = registerUnsafeBurnerWallet(suiClient);\n\t\treturn unregister;\n\t}, [enabled, suiClient]);\n}\n\nfunction registerUnsafeBurnerWallet(suiClient: SuiClient) {\n\tconst walletsApi = getWallets();\n\tconst registeredWallets = walletsApi.get();\n\n\tif (registeredWallets.find((wallet) => wallet.name === WALLET_NAME)) {\n\t\tconsole.warn(\n\t\t\t'registerUnsafeBurnerWallet: Unsafe Burner Wallet already registered, skipping duplicate registration.',\n\t\t);\n\t\treturn;\n\t}\n\n\tconsole.warn(\n\t\t'Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.',\n\t);\n\n\tconst keypair = new Ed25519Keypair();\n\tconst account = new ReadonlyWalletAccount({\n\t\taddress: keypair.getPublicKey().toSuiAddress(),\n\t\tpublicKey: keypair.getPublicKey().toSuiBytes(),\n\t\tchains: ['sui:unknown'],\n\t\tfeatures: [\n\t\t\t'sui:signAndExecuteTransactionBlock',\n\t\t\t'sui:signTransactionBlock',\n\t\t\t'sui:signTransaction',\n\t\t\t'sui:signAndExecuteTransaction',\n\t\t],\n\t});\n\n\tclass UnsafeBurnerWallet implements Wallet {\n\t\tget version() {\n\t\t\treturn '1.0.0' as const;\n\t\t}\n\n\t\tget name() {\n\t\t\treturn WALLET_NAME;\n\t\t}\n\n\t\tget icon() {\n\t\t\treturn 'data:image/png;base64,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' as const;\n\t\t}\n\n\t\t// Return the Sui chains that your wallet supports.\n\t\tget chains() {\n\t\t\treturn SUI_CHAINS;\n\t\t}\n\n\t\tget accounts() {\n\t\t\treturn [account];\n\t\t}\n\n\t\tget features(): StandardConnectFeature & StandardEventsFeature & SuiFeatures {\n\t\t\treturn {\n\t\t\t\t'standard:connect': {\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t\tconnect: this.#connect,\n\t\t\t\t},\n\t\t\t\t'standard:events': {\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t\ton: this.#on,\n\t\t\t\t},\n\t\t\t\t'sui:signPersonalMessage': {\n\t\t\t\t\tversion: '1.1.0',\n\t\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t\t},\n\t\t\t\t'sui:signTransactionBlock': {\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t\tsignTransactionBlock: this.#signTransactionBlock,\n\t\t\t\t},\n\t\t\t\t'sui:signAndExecuteTransactionBlock': {\n\t\t\t\t\tversion: '1.0.0',\n\t\t\t\t\tsignAndExecuteTransactionBlock: this.#signAndExecuteTransactionBlock,\n\t\t\t\t},\n\t\t\t\t'sui:signTransaction': {\n\t\t\t\t\tversion: '2.0.0',\n\t\t\t\t\tsignTransaction: this.#signTransaction,\n\t\t\t\t},\n\t\t\t\t'sui:signAndExecuteTransaction': {\n\t\t\t\t\tversion: '2.0.0',\n\t\t\t\t\tsignAndExecuteTransaction: this.#signAndExecuteTransaction,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\t#on: StandardEventsOnMethod = () => {\n\t\t\treturn () => {};\n\t\t};\n\n\t\t#connect: StandardConnectMethod = async () => {\n\t\t\treturn { accounts: this.accounts };\n\t\t};\n\n\t\t#signPersonalMessage: SuiSignPersonalMessageMethod = async (messageInput) => {\n\t\t\tconst { bytes, signature } = await keypair.signPersonalMessage(messageInput.message);\n\t\t\treturn { bytes, signature };\n\t\t};\n\n\t\t#signTransactionBlock: SuiSignTransactionBlockMethod = async (transactionInput) => {\n\t\t\tconst { bytes, signature } = await transactionInput.transactionBlock.sign({\n\t\t\t\tclient: suiClient,\n\t\t\t\tsigner: keypair,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransactionBlockBytes: bytes,\n\t\t\t\tsignature: signature,\n\t\t\t};\n\t\t};\n\n\t\t#signTransaction: SuiSignTransactionMethod = async (transactionInput) => {\n\t\t\tconst { bytes, signature } = await Transaction.from(\n\t\t\t\tawait transactionInput.transaction.toJSON(),\n\t\t\t).sign({\n\t\t\t\tclient: suiClient,\n\t\t\t\tsigner: keypair,\n\t\t\t});\n\n\t\t\ttransactionInput.signal?.throwIfAborted();\n\n\t\t\treturn {\n\t\t\t\tbytes,\n\t\t\t\tsignature: signature,\n\t\t\t};\n\t\t};\n\n\t\t#signAndExecuteTransactionBlock: SuiSignAndExecuteTransactionBlockMethod = async (\n\t\t\ttransactionInput,\n\t\t) => {\n\t\t\tconst { bytes, signature } = await transactionInput.transactionBlock.sign({\n\t\t\t\tclient: suiClient,\n\t\t\t\tsigner: keypair,\n\t\t\t});\n\n\t\t\treturn suiClient.executeTransactionBlock({\n\t\t\t\tsignature,\n\t\t\t\ttransactionBlock: bytes,\n\t\t\t\toptions: transactionInput.options,\n\t\t\t});\n\t\t};\n\n\t\t#signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = async (transactionInput) => {\n\t\t\tconst { bytes, signature } = await Transaction.from(\n\t\t\t\tawait transactionInput.transaction.toJSON(),\n\t\t\t).sign({\n\t\t\t\tclient: suiClient,\n\t\t\t\tsigner: keypair,\n\t\t\t});\n\n\t\t\ttransactionInput.signal?.throwIfAborted();\n\n\t\t\tconst { rawEffects, digest } = await suiClient.executeTransactionBlock({\n\t\t\t\tsignature,\n\t\t\t\ttransactionBlock: bytes,\n\t\t\t\toptions: {\n\t\t\t\t\tshowRawEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tbytes,\n\t\t\t\tsignature,\n\t\t\t\tdigest,\n\t\t\t\teffects: toBase64(new Uint8Array(rawEffects!)),\n\t\t\t};\n\t\t};\n\t}\n\n\treturn walletsApi.register(new UnsafeBurnerWallet());\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useEffect } from 'react';\n\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Internal hook for easily handling various changes in properties for a wallet.\n */\nexport function useWalletPropertiesChanged() {\n\tconst { currentWallet } = useCurrentWallet();\n\tconst updateWalletAccounts = useWalletStore((state) => state.updateWalletAccounts);\n\n\tuseEffect(() => {\n\t\tconst unsubscribeFromEvents = currentWallet?.features['standard:events'].on(\n\t\t\t'change',\n\t\t\t({ accounts }) => {\n\t\t\t\t// TODO: We should handle features changing that might make the list of wallets\n\t\t\t\t// or even the current wallet incompatible with the dApp.\n\t\t\t\tif (accounts) {\n\t\t\t\t\tupdateWalletAccounts(accounts);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t\treturn unsubscribeFromEvents;\n\t}, [currentWallet?.features, updateWalletAccounts]);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalletWithRequiredFeatures } from '@mysten/wallet-standard';\nimport { getWallets } from '@mysten/wallet-standard';\nimport { useEffect } from 'react';\n\nimport { getRegisteredWallets } from '../../utils/walletUtils.js';\nimport { useWalletStore } from './useWalletStore.js';\n\n/**\n * Internal hook for easily handling the addition and removal of new wallets.\n */\nexport function useWalletsChanged(\n\tpreferredWallets: string[],\n\twalletFilter?: (wallet: WalletWithRequiredFeatures) => boolean,\n) {\n\tconst setWalletRegistered = useWalletStore((state) => state.setWalletRegistered);\n\tconst setWalletUnregistered = useWalletStore((state) => state.setWalletUnregistered);\n\n\tuseEffect(() => {\n\t\tconst walletsApi = getWallets();\n\t\tsetWalletRegistered(getRegisteredWallets(preferredWallets, walletFilter));\n\n\t\tconst unsubscribeFromRegister = walletsApi.on('register', () => {\n\t\t\tsetWalletRegistered(getRegisteredWallets(preferredWallets, walletFilter));\n\t\t});\n\n\t\tconst unsubscribeFromUnregister = walletsApi.on('unregister', (unregisteredWallet) => {\n\t\t\tsetWalletUnregistered(\n\t\t\t\tgetRegisteredWallets(preferredWallets, walletFilter),\n\t\t\t\tunregisteredWallet,\n\t\t\t);\n\t\t});\n\n\t\treturn () => {\n\t\t\tunsubscribeFromRegister();\n\t\t\tunsubscribeFromUnregister();\n\t\t};\n\t}, [preferredWallets, walletFilter, setWalletRegistered, setWalletUnregistered]);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ThemeVars } from './themeContract.js';\n\nexport const lightTheme: ThemeVars = {\n\tblurs: {\n\t\tmodalOverlay: 'blur(0)',\n\t},\n\tbackgroundColors: {\n\t\tprimaryButton: '#F6F7F9',\n\t\tprimaryButtonHover: '#F0F2F5',\n\t\toutlineButtonHover: '#F4F4F5',\n\t\tmodalOverlay: 'rgba(24 36 53 / 20%)',\n\t\tmodalPrimary: 'white',\n\t\tmodalSecondary: '#F7F8F8',\n\t\ticonButton: 'transparent',\n\t\ticonButtonHover: '#F0F1F2',\n\t\tdropdownMenu: '#FFFFFF',\n\t\tdropdownMenuSeparator: '#F3F6F8',\n\t\twalletItemSelected: 'white',\n\t\twalletItemHover: '#3C424226',\n\t},\n\tborderColors: {\n\t\toutlineButton: '#E4E4E7',\n\t},\n\tcolors: {\n\t\tprimaryButton: '#373737',\n\t\toutlineButton: '#373737',\n\t\ticonButton: '#000000',\n\t\tbody: '#182435',\n\t\tbodyMuted: '#767A81',\n\t\tbodyDanger: '#FF794B',\n\t},\n\tradii: {\n\t\tsmall: '6px',\n\t\tmedium: '8px',\n\t\tlarge: '12px',\n\t\txlarge: '16px',\n\t},\n\tshadows: {\n\t\tprimaryButton: '0px 4px 12px rgba(0, 0, 0, 0.1)',\n\t\twalletItemSelected: '0px 2px 6px rgba(0, 0, 0, 0.05)',\n\t},\n\tfontWeights: {\n\t\tnormal: '400',\n\t\tmedium: '500',\n\t\tbold: '600',\n\t},\n\tfontSizes: {\n\t\tsmall: '14px',\n\t\tmedium: '16px',\n\t\tlarge: '18px',\n\t\txlarge: '20px',\n\t},\n\ttypography: {\n\t\tfontFamily:\n\t\t\t'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"',\n\t\tfontStyle: 'normal',\n\t\tlineHeight: '1.3',\n\t\tletterSpacing: '1',\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Wallet, WalletAccount, WalletWithRequiredFeatures } from '@mysten/wallet-standard';\nimport { createStore } from 'zustand';\nimport type { StateStorage } from 'zustand/middleware';\nimport { createJSONStorage, persist } from 'zustand/middleware';\n\nimport { getWalletUniqueIdentifier } from './utils/walletUtils.js';\n\ntype WalletConnectionStatus = 'disconnected' | 'connecting' | 'connected';\n\nexport type WalletActions = {\n\tsetAccountSwitched: (selectedAccount: WalletAccount) => void;\n\tsetConnectionStatus: (connectionStatus: WalletConnectionStatus) => void;\n\tsetWalletConnected: (\n\t\twallet: WalletWithRequiredFeatures,\n\t\tconnectedAccounts: readonly WalletAccount[],\n\t\tselectedAccount: WalletAccount | null,\n\t\tsupportedIntents?: string[],\n\t) => void;\n\tupdateWalletAccounts: (accounts: readonly WalletAccount[]) => void;\n\tsetWalletDisconnected: () => void;\n\tsetWalletRegistered: (updatedWallets: WalletWithRequiredFeatures[]) => void;\n\tsetWalletUnregistered: (\n\t\tupdatedWallets: WalletWithRequiredFeatures[],\n\t\tunregisteredWallet: Wallet,\n\t) => void;\n};\n\nexport type WalletStore = ReturnType<typeof createWalletStore>;\n\nexport type StoreState = {\n\tautoConnectEnabled: boolean;\n\twallets: WalletWithRequiredFeatures[];\n\taccounts: readonly WalletAccount[];\n\tcurrentWallet: WalletWithRequiredFeatures | null;\n\tcurrentAccount: WalletAccount | null;\n\tlastConnectedAccountAddress: string | null;\n\tlastConnectedWalletName: string | null;\n\tconnectionStatus: WalletConnectionStatus;\n\tsupportedIntents: string[];\n} & WalletActions;\n\ntype WalletConfiguration = {\n\tautoConnectEnabled: boolean;\n\twallets: WalletWithRequiredFeatures[];\n\tstorage: StateStorage;\n\tstorageKey: string;\n};\n\nexport function createWalletStore({\n\twallets,\n\tstorage,\n\tstorageKey,\n\tautoConnectEnabled,\n}: WalletConfiguration) {\n\treturn createStore<StoreState>()(\n\t\tpersist(\n\t\t\t(set, get) => ({\n\t\t\t\tautoConnectEnabled,\n\t\t\t\twallets,\n\t\t\t\taccounts: [] as WalletAccount[],\n\t\t\t\tcurrentWallet: null,\n\t\t\t\tcurrentAccount: null,\n\t\t\t\tlastConnectedAccountAddress: null,\n\t\t\t\tlastConnectedWalletName: null,\n\t\t\t\tconnectionStatus: 'disconnected',\n\t\t\t\tsupportedIntents: [],\n\t\t\t\tsetConnectionStatus(connectionStatus) {\n\t\t\t\t\tset(() => ({\n\t\t\t\t\t\tconnectionStatus,\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tsetWalletConnected(wallet, connectedAccounts, selectedAccount, supportedIntents = []) {\n\t\t\t\t\tset(() => ({\n\t\t\t\t\t\taccounts: connectedAccounts,\n\t\t\t\t\t\tcurrentWallet: wallet,\n\t\t\t\t\t\tcurrentAccount: selectedAccount,\n\t\t\t\t\t\tlastConnectedWalletName: getWalletUniqueIdentifier(wallet),\n\t\t\t\t\t\tlastConnectedAccountAddress: selectedAccount?.address,\n\t\t\t\t\t\tconnectionStatus: 'connected',\n\t\t\t\t\t\tsupportedIntents,\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tsetWalletDisconnected() {\n\t\t\t\t\tset(() => ({\n\t\t\t\t\t\taccounts: [],\n\t\t\t\t\t\tcurrentWallet: null,\n\t\t\t\t\t\tcurrentAccount: null,\n\t\t\t\t\t\tlastConnectedWalletName: null,\n\t\t\t\t\t\tlastConnectedAccountAddress: null,\n\t\t\t\t\t\tconnectionStatus: 'disconnected',\n\t\t\t\t\t\tsupportedIntents: [],\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tsetAccountSwitched(selectedAccount) {\n\t\t\t\t\tset(() => ({\n\t\t\t\t\t\tcurrentAccount: selectedAccount,\n\t\t\t\t\t\tlastConnectedAccountAddress: selectedAccount.address,\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tsetWalletRegistered(updatedWallets) {\n\t\t\t\t\tset(() => ({ wallets: updatedWallets }));\n\t\t\t\t},\n\t\t\t\tsetWalletUnregistered(updatedWallets, unregisteredWallet) {\n\t\t\t\t\tif (unregisteredWallet === get().currentWallet) {\n\t\t\t\t\t\tset(() => ({\n\t\t\t\t\t\t\twallets: updatedWallets,\n\t\t\t\t\t\t\taccounts: [],\n\t\t\t\t\t\t\tcurrentWallet: null,\n\t\t\t\t\t\t\tcurrentAccount: null,\n\t\t\t\t\t\t\tlastConnectedWalletName: null,\n\t\t\t\t\t\t\tlastConnectedAccountAddress: null,\n\t\t\t\t\t\t\tconnectionStatus: 'disconnected',\n\t\t\t\t\t\t\tsupportedIntents: [],\n\t\t\t\t\t\t}));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset(() => ({ wallets: updatedWallets }));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tupdateWalletAccounts(accounts) {\n\t\t\t\t\tconst currentAccount = get().currentAccount;\n\n\t\t\t\t\tset(() => ({\n\t\t\t\t\t\taccounts,\n\t\t\t\t\t\tcurrentAccount:\n\t\t\t\t\t\t\t(currentAccount &&\n\t\t\t\t\t\t\t\taccounts.find(({ address }) => address === currentAccount.address)) ||\n\t\t\t\t\t\t\taccounts[0],\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t}),\n\t\t\t{\n\t\t\t\tname: storageKey,\n\t\t\t\tstorage: createJSONStorage(() => storage),\n\t\t\t\tpartialize: ({ lastConnectedWalletName, lastConnectedAccountAddress }) => ({\n\t\t\t\t\tlastConnectedWalletName,\n\t\t\t\t\tlastConnectedAccountAddress,\n\t\t\t\t}),\n\t\t\t},\n\t\t),\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assignInlineVars } from '@vanilla-extract/dynamic';\n\nimport { styleDataAttributeSelector } from '../../constants/styleDataAttribute.js';\nimport { themeVars } from '../../themes/themeContract.js';\nimport type { DynamicTheme, Theme, ThemeVars } from '../../themes/themeContract.js';\n\ntype InjectedThemeStylesProps = {\n\ttheme: Theme;\n};\n\nexport function InjectedThemeStyles({ theme }: InjectedThemeStylesProps) {\n\tconst themeStyles = Array.isArray(theme)\n\t\t? getDynamicThemeStyles(theme)\n\t\t: getStaticThemeStyles(theme);\n\n\treturn (\n\t\t<style\n\t\t\t// @ts-expect-error The precedence prop hasn't made it to the stable release of React, but we\n\t\t\t// don't want this to break in frameworks like Next which use the latest canary build.\n\t\t\tprecedence=\"default\"\n\t\t\thref=\"mysten-dapp-kit-theme\"\n\t\t\tdangerouslySetInnerHTML={{\n\t\t\t\t__html: themeStyles,\n\t\t\t}}\n\t\t/>\n\t);\n}\n\nfunction getDynamicThemeStyles(themes: DynamicTheme[]) {\n\treturn themes\n\t\t.map(({ mediaQuery, selector, variables }) => {\n\t\t\tconst themeStyles = getStaticThemeStyles(variables);\n\t\t\tconst themeStylesWithSelectorPrefix = selector ? `${selector} ${themeStyles}` : themeStyles;\n\n\t\t\treturn mediaQuery\n\t\t\t\t? `@media ${mediaQuery}{${themeStylesWithSelectorPrefix}}`\n\t\t\t\t: themeStylesWithSelectorPrefix;\n\t\t})\n\t\t.join(' ');\n}\n\nfunction getStaticThemeStyles(theme: ThemeVars) {\n\treturn `${styleDataAttributeSelector} {${cssStringFromTheme(theme)}}`;\n}\n\nfunction cssStringFromTheme(theme: ThemeVars) {\n\treturn Object.entries(assignInlineVars(themeVars, theme))\n\t\t.map(([key, value]) => `${key}:${value};`)\n\t\t.join('');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { createGlobalThemeContract } from '@vanilla-extract/css';\n\nconst themeContractValues = {\n\tblurs: {\n\t\tmodalOverlay: '',\n\t},\n\tbackgroundColors: {\n\t\tprimaryButton: '',\n\t\tprimaryButtonHover: '',\n\t\toutlineButtonHover: '',\n\t\twalletItemHover: '',\n\t\twalletItemSelected: '',\n\t\tmodalOverlay: '',\n\t\tmodalPrimary: '',\n\t\tmodalSecondary: '',\n\t\ticonButton: '',\n\t\ticonButtonHover: '',\n\t\tdropdownMenu: '',\n\t\tdropdownMenuSeparator: '',\n\t},\n\tborderColors: {\n\t\toutlineButton: '',\n\t},\n\tcolors: {\n\t\tprimaryButton: '',\n\t\toutlineButton: '',\n\t\tbody: '',\n\t\tbodyMuted: '',\n\t\tbodyDanger: '',\n\t\ticonButton: '',\n\t},\n\tradii: {\n\t\tsmall: '',\n\t\tmedium: '',\n\t\tlarge: '',\n\t\txlarge: '',\n\t},\n\tshadows: {\n\t\tprimaryButton: '',\n\t\twalletItemSelected: '',\n\t},\n\tfontWeights: {\n\t\tnormal: '',\n\t\tmedium: '',\n\t\tbold: '',\n\t},\n\tfontSizes: {\n\t\tsmall: '',\n\t\tmedium: '',\n\t\tlarge: '',\n\t\txlarge: '',\n\t},\n\ttypography: {\n\t\tfontFamily: '',\n\t\tfontStyle: '',\n\t\tlineHeight: '',\n\t\tletterSpacing: '',\n\t},\n};\n\nexport type ThemeVars = typeof themeContractValues;\n\n/**\n * A custom theme that is enabled when various conditions are\n */\nexport type DynamicTheme = {\n\t/**\n\t * An optional media query required for the given theme to be enabled. This is useful\n\t * when you want the theme of your application to automatically switch depending on\n\t * a media feature.\n\t *\n\t * @example '(prefers-color-scheme: dark)'\n\t */\n\tmediaQuery?: string;\n\n\t/**\n\t * An optional CSS selector required for the given theme to be enabled. This is useful\n\t * when you have a manual theme switcher on your application that sets a top-level\n\t * class name or data-attribute to control the current theme.\n\t *\n\t * @example '.data-dark'\n\t */\n\tselector?: string;\n\n\t/** The theme definitions that will be set when the selector and mediaQuery criteria are matched. */\n\tvariables: ThemeVars;\n};\n\nexport type Theme = ThemeVars | DynamicTheme[];\n\nexport const themeVars = createGlobalThemeContract(\n\tthemeContractValues,\n\t(_, path) => `dapp-kit-${path.join('-')}`,\n);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClientOptions } from '@mysten/sui/client';\n\nimport { useSuiClientContext } from './useSuiClient.js';\n\nexport type NetworkConfig<T extends object = object> = SuiClientOptions & {\n\tvariables?: T;\n};\n\nexport function createNetworkConfig<\n\tconst T extends Record<string, Config>,\n\tConfig extends NetworkConfig<Variables> = T[keyof T],\n\tVariables extends object = NonNullable<Config['variables']>,\n>(networkConfig: T) {\n\tfunction useNetworkConfig(): Config {\n\t\tconst { config } = useSuiClientContext();\n\n\t\tif (!config) {\n\t\t\tthrow new Error('No network config found');\n\t\t}\n\n\t\treturn config as T[keyof T];\n\t}\n\n\tfunction useNetworkVariables(): Variables {\n\t\tconst { variables } = useNetworkConfig();\n\n\t\treturn (variables ?? {}) as Variables;\n\t}\n\n\tfunction useNetworkVariable<K extends keyof Variables>(name: K): Variables[K] {\n\t\tconst variables = useNetworkVariables();\n\n\t\treturn variables[name];\n\t}\n\n\treturn {\n\t\tnetworkConfig,\n\t\tuseNetworkConfig,\n\t\tuseNetworkVariables,\n\t\tuseNetworkVariable,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui/client';\nimport type {\n\tInfiniteData,\n\tUseInfiniteQueryOptions,\n\tUseInfiniteQueryResult,\n} from '@tanstack/react-query';\nimport { useInfiniteQuery } from '@tanstack/react-query';\n\nimport type { PartialBy } from '../types/utilityTypes.js';\nimport { useSuiClientContext } from './useSuiClient.js';\n\ninterface PaginatedResult {\n\tdata?: unknown;\n\tnextCursor?: unknown;\n\thasNextPage: boolean;\n}\n\nexport type SuiRpcPaginatedMethodName = {\n\t[K in keyof SuiClient]: SuiClient[K] extends (input: any) => Promise<PaginatedResult> ? K : never;\n}[keyof SuiClient];\n\nexport type SuiRpcPaginatedMethods = {\n\t[K in SuiRpcPaginatedMethodName]: SuiClient[K] extends (\n\t\tinput: infer Params,\n\t) => Promise<\n\t\tinfer Result extends { hasNextPage?: boolean | null; nextCursor?: infer Cursor | null }\n\t>\n\t\t? {\n\t\t\t\tname: K;\n\t\t\t\tresult: Result;\n\t\t\t\tparams: Params;\n\t\t\t\tcursor: Cursor;\n\t\t\t}\n\t\t: never;\n};\n\nexport type UseSuiClientInfiniteQueryOptions<\n\tT extends keyof SuiRpcPaginatedMethods,\n\tTData,\n> = PartialBy<\n\tOmit<\n\t\tUseInfiniteQueryOptions<SuiRpcPaginatedMethods[T]['result'], Error, TData, unknown[]>,\n\t\t'queryFn' | 'initialPageParam' | 'getNextPageParam'\n\t>,\n\t'queryKey'\n>;\n\nexport function useSuiClientInfiniteQuery<\n\tT extends keyof SuiRpcPaginatedMethods,\n\tTData = InfiniteData<SuiRpcPaginatedMethods[T]['result']>,\n>(\n\tmethod: T,\n\tparams: SuiRpcPaginatedMethods[T]['params'],\n\t{\n\t\tqueryKey = [],\n\t\tenabled = !!params,\n\t\t...options\n\t}: UseSuiClientInfiniteQueryOptions<T, TData> = {},\n): UseInfiniteQueryResult<TData, Error> {\n\tconst suiContext = useSuiClientContext();\n\n\treturn useInfiniteQuery({\n\t\t...options,\n\t\tinitialPageParam: null,\n\t\tqueryKey: [suiContext.network, method, params, ...queryKey],\n\t\tenabled,\n\t\tqueryFn: ({ pageParam }) =>\n\t\t\tsuiContext.client[method]({\n\t\t\t\t...(params ?? {}),\n\t\t\t\tcursor: pageParam,\n\t\t\t} as never),\n\t\tgetNextPageParam: (lastPage) => (lastPage.hasNextPage ? (lastPage.nextCursor ?? null) : null),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { useSuiClientContext } from './useSuiClient.js';\nimport type { SuiRpcMethods } from './useSuiClientQuery.js';\n\nexport type UseSuiClientMutationOptions<T extends keyof SuiRpcMethods> = Omit<\n\tUseMutationOptions<SuiRpcMethods[T]['result'], Error, SuiRpcMethods[T]['params'], unknown[]>,\n\t'mutationFn'\n>;\n\nexport function useSuiClientMutation<T extends keyof SuiRpcMethods>(\n\tmethod: T,\n\toptions: UseSuiClientMutationOptions<T> = {},\n): UseMutationResult<SuiRpcMethods[T]['result'], Error, SuiRpcMethods[T]['params'], unknown[]> {\n\tconst suiContext = useSuiClientContext();\n\n\treturn useMutation({\n\t\t...options,\n\t\tmutationFn: async (params) => {\n\t\t\treturn await suiContext.client[method](params as never);\n\t\t},\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { UseQueryResult } from '@tanstack/react-query';\nimport { useQueries } from '@tanstack/react-query';\n\nimport { useSuiClientContext } from './useSuiClient.js';\nimport type { SuiRpcMethods, UseSuiClientQueryOptions } from './useSuiClientQuery.js';\n\ntype SuiClientQueryOptions = SuiRpcMethods[keyof SuiRpcMethods] extends infer Method\n\t? Method extends {\n\t\t\tname: infer M extends keyof SuiRpcMethods;\n\t\t\tparams?: infer P;\n\t\t}\n\t\t? undefined extends P\n\t\t\t? {\n\t\t\t\t\tmethod: M;\n\t\t\t\t\tparams?: P;\n\t\t\t\t\toptions?: UseSuiClientQueryOptions<M, unknown>;\n\t\t\t\t}\n\t\t\t: {\n\t\t\t\t\tmethod: M;\n\t\t\t\t\tparams: P;\n\t\t\t\t\toptions?: UseSuiClientQueryOptions<M, unknown>;\n\t\t\t\t}\n\t\t: never\n\t: never;\n\nexport type UseSuiClientQueriesResults<Args extends readonly SuiClientQueryOptions[]> = {\n\t-readonly [K in keyof Args]: Args[K] extends {\n\t\tmethod: infer M extends keyof SuiRpcMethods;\n\t\treadonly options?:\n\t\t\t| {\n\t\t\t\t\tselect?: (...args: any[]) => infer R;\n\t\t\t  }\n\t\t\t| object;\n\t}\n\t\t? UseQueryResult<unknown extends R ? SuiRpcMethods[M]['result'] : R>\n\t\t: never;\n};\n\nexport function useSuiClientQueries<\n\tconst Queries extends readonly SuiClientQueryOptions[],\n\tResults = UseSuiClientQueriesResults<Queries>,\n>({\n\tqueries,\n\tcombine,\n}: {\n\tqueries: Queries;\n\tcombine?: (results: UseSuiClientQueriesResults<Queries>) => Results;\n}): Results {\n\tconst suiContext = useSuiClientContext();\n\n\treturn useQueries({\n\t\tcombine: combine as never,\n\t\tqueries: queries.map((query) => {\n\t\t\tconst { method, params, options: { queryKey = [], ...restOptions } = {} } = query;\n\n\t\t\treturn {\n\t\t\t\t...restOptions,\n\t\t\t\tqueryKey: [suiContext.network, method, params, ...queryKey],\n\t\t\t\tqueryFn: async () => {\n\t\t\t\t\treturn await suiContext.client[method](params as never);\n\t\t\t\t},\n\t\t\t};\n\t\t}) as [],\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction } from '@mysten/sui/transactions';\nimport { toBase64 } from '@mysten/sui/utils';\nimport type {\n\tSuiSignAndExecuteTransactionInput,\n\tSuiSignAndExecuteTransactionOutput,\n} from '@mysten/wallet-standard';\nimport { signTransaction } from '@mysten/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport {\n\tWalletFeatureNotSupportedError,\n\tWalletNoAccountSelectedError,\n\tWalletNotConnectedError,\n} from '../../errors/walletErrors.js';\nimport type { PartialBy } from '../../types/utilityTypes.js';\nimport { useSuiClientContext } from '../useSuiClient.js';\nimport { useCurrentAccount } from './useCurrentAccount.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useReportTransactionEffects } from './useReportTransactionEffects.js';\n\ntype UseSignAndExecuteTransactionArgs = PartialBy<\n\tOmit<SuiSignAndExecuteTransactionInput, 'transaction'>,\n\t'account' | 'chain'\n> & {\n\ttransaction: Transaction | string;\n};\n\ntype UseSignAndExecuteTransactionResult = SuiSignAndExecuteTransactionOutput;\n\ntype UseSignAndExecuteTransactionError =\n\t| WalletFeatureNotSupportedError\n\t| WalletNoAccountSelectedError\n\t| WalletNotConnectedError\n\t| Error;\n\ntype ExecuteTransactionResult =\n\t| {\n\t\t\tdigest: string;\n\t\t\trawEffects?: number[];\n\t  }\n\t| {\n\t\t\teffects?: {\n\t\t\t\tbcs?: string;\n\t\t\t};\n\t  };\n\ntype UseSignAndExecuteTransactionMutationOptions<Result extends ExecuteTransactionResult> = Omit<\n\tUseMutationOptions<\n\t\tResult,\n\t\tUseSignAndExecuteTransactionError,\n\t\tUseSignAndExecuteTransactionArgs,\n\t\tunknown\n\t>,\n\t'mutationFn'\n> & {\n\texecute?: ({ bytes, signature }: { bytes: string; signature: string }) => Promise<Result>;\n};\n\n/**\n * Mutation hook for prompting the user to sign and execute a transaction.\n */\nexport function useSignAndExecuteTransaction<\n\tResult extends ExecuteTransactionResult = UseSignAndExecuteTransactionResult,\n>({\n\tmutationKey,\n\texecute,\n\t...mutationOptions\n}: UseSignAndExecuteTransactionMutationOptions<Result> = {}): UseMutationResult<\n\tResult,\n\tUseSignAndExecuteTransactionError,\n\tUseSignAndExecuteTransactionArgs\n> {\n\tconst { currentWallet, supportedIntents } = useCurrentWallet();\n\tconst currentAccount = useCurrentAccount();\n\tconst { client, network } = useSuiClientContext();\n\tconst { mutate: reportTransactionEffects } = useReportTransactionEffects();\n\n\tconst executeTransaction: ({\n\t\tbytes,\n\t\tsignature,\n\t}: {\n\t\tbytes: string;\n\t\tsignature: string;\n\t}) => Promise<ExecuteTransactionResult> =\n\t\texecute ??\n\t\t(async ({ bytes, signature }) => {\n\t\t\tconst { digest, rawEffects } = await client.executeTransactionBlock({\n\t\t\t\ttransactionBlock: bytes,\n\t\t\t\tsignature,\n\t\t\t\toptions: {\n\t\t\t\t\tshowRawEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tdigest,\n\t\t\t\trawEffects,\n\t\t\t\teffects: toBase64(new Uint8Array(rawEffects!)),\n\t\t\t\tbytes,\n\t\t\t\tsignature,\n\t\t\t};\n\t\t});\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.signAndExecuteTransaction(mutationKey),\n\t\tmutationFn: async ({ transaction, ...signTransactionArgs }): Promise<Result> => {\n\t\t\tif (!currentWallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\tconst signerAccount = signTransactionArgs.account ?? currentAccount;\n\t\t\tif (!signerAccount) {\n\t\t\t\tthrow new WalletNoAccountSelectedError(\n\t\t\t\t\t'No wallet account is selected to sign the transaction with.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!currentWallet.features['sui:signTransaction'] &&\n\t\t\t\t!currentWallet.features['sui:signTransactionBlock']\n\t\t\t) {\n\t\t\t\tthrow new WalletFeatureNotSupportedError(\n\t\t\t\t\t\"This wallet doesn't support the `signTransaction` feature.\",\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst chain = signTransactionArgs.chain ?? `sui:${network}`;\n\t\t\tconst { signature, bytes } = await signTransaction(currentWallet, {\n\t\t\t\t...signTransactionArgs,\n\t\t\t\ttransaction: {\n\t\t\t\t\tasync toJSON() {\n\t\t\t\t\t\treturn typeof transaction === 'string'\n\t\t\t\t\t\t\t? transaction\n\t\t\t\t\t\t\t: await transaction.toJSON({\n\t\t\t\t\t\t\t\t\tsupportedIntents,\n\t\t\t\t\t\t\t\t\tclient,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taccount: signerAccount,\n\t\t\t\tchain,\n\t\t\t});\n\n\t\t\tconst result = await executeTransaction({ bytes, signature });\n\n\t\t\tlet effects: string;\n\n\t\t\tif ('effects' in result && result.effects?.bcs) {\n\t\t\t\teffects = result.effects.bcs;\n\t\t\t} else if ('rawEffects' in result) {\n\t\t\t\teffects = toBase64(new Uint8Array(result.rawEffects!));\n\t\t\t} else {\n\t\t\t\tthrow new Error('Could not parse effects from transaction result.');\n\t\t\t}\n\n\t\t\treportTransactionEffects({ effects, account: signerAccount, chain });\n\n\t\t\treturn result as Result;\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/sui/utils';\nimport type { SuiReportTransactionEffectsInput } from '@mysten/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport type { WalletFeatureNotSupportedError } from '../../errors/walletErrors.js';\nimport {\n\tWalletNoAccountSelectedError,\n\tWalletNotConnectedError,\n} from '../../errors/walletErrors.js';\nimport type { PartialBy } from '../../types/utilityTypes.js';\nimport { useCurrentAccount } from './useCurrentAccount.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\n\ntype UseReportTransactionEffectsArgs = Omit<\n\tPartialBy<SuiReportTransactionEffectsInput, 'account' | 'chain'>,\n\t'effects'\n> & {\n\teffects: string | number[];\n};\n\ntype UseReportTransactionEffectsError =\n\t| WalletFeatureNotSupportedError\n\t| WalletNoAccountSelectedError\n\t| WalletNotConnectedError\n\t| Error;\n\ntype UseReportTransactionEffectsMutationOptions = Omit<\n\tUseMutationOptions<\n\t\tvoid,\n\t\tUseReportTransactionEffectsError,\n\t\tUseReportTransactionEffectsArgs,\n\t\tunknown\n\t>,\n\t'mutationFn'\n>;\n\n/**\n * Mutation hook for prompting the user to sign a message.\n */\nexport function useReportTransactionEffects({\n\tmutationKey,\n\t...mutationOptions\n}: UseReportTransactionEffectsMutationOptions = {}): UseMutationResult<\n\tvoid,\n\tUseReportTransactionEffectsError,\n\tUseReportTransactionEffectsArgs\n> {\n\tconst { currentWallet } = useCurrentWallet();\n\tconst currentAccount = useCurrentAccount();\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.reportTransactionEffects(mutationKey),\n\t\tmutationFn: async ({ effects, chain = currentWallet?.chains[0], account = currentAccount }) => {\n\t\t\tif (!currentWallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\tif (!account) {\n\t\t\t\tthrow new WalletNoAccountSelectedError(\n\t\t\t\t\t'No wallet account is selected to report transaction effects for',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst reportTransactionEffectsFeature =\n\t\t\t\tcurrentWallet.features['sui:reportTransactionEffects'];\n\n\t\t\tif (reportTransactionEffectsFeature) {\n\t\t\t\treturn await reportTransactionEffectsFeature.reportTransactionEffects({\n\t\t\t\t\teffects: Array.isArray(effects) ? toBase64(new Uint8Array(effects)) : effects,\n\t\t\t\t\taccount,\n\t\t\t\t\tchain: chain ?? currentWallet?.chains[0],\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tSuiSignPersonalMessageInput,\n\tSuiSignPersonalMessageOutput,\n} from '@mysten/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport {\n\tWalletFeatureNotSupportedError,\n\tWalletNoAccountSelectedError,\n\tWalletNotConnectedError,\n} from '../..//errors/walletErrors.js';\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport type { PartialBy } from '../../types/utilityTypes.js';\nimport { useSuiClientContext } from '../useSuiClient.js';\nimport { useCurrentAccount } from './useCurrentAccount.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\n\ntype UseSignPersonalMessageArgs = PartialBy<SuiSignPersonalMessageInput, 'account' | 'chain'>;\n\ntype UseSignPersonalMessageResult = SuiSignPersonalMessageOutput;\n\ntype UseSignPersonalMessageError =\n\t| WalletFeatureNotSupportedError\n\t| WalletNoAccountSelectedError\n\t| WalletNotConnectedError\n\t| Error;\n\ntype UseSignPersonalMessageMutationOptions = Omit<\n\tUseMutationOptions<\n\t\tUseSignPersonalMessageResult,\n\t\tUseSignPersonalMessageError,\n\t\tUseSignPersonalMessageArgs,\n\t\tunknown\n\t>,\n\t'mutationFn'\n>;\n\n/**\n * Mutation hook for prompting the user to sign a message.\n */\nexport function useSignPersonalMessage({\n\tmutationKey,\n\t...mutationOptions\n}: UseSignPersonalMessageMutationOptions = {}): UseMutationResult<\n\tUseSignPersonalMessageResult,\n\tUseSignPersonalMessageError,\n\tUseSignPersonalMessageArgs\n> {\n\tconst { currentWallet } = useCurrentWallet();\n\tconst currentAccount = useCurrentAccount();\n\tconst { network } = useSuiClientContext();\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.signPersonalMessage(mutationKey),\n\t\tmutationFn: async (signPersonalMessageArgs) => {\n\t\t\tif (!currentWallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\tconst signerAccount = signPersonalMessageArgs.account ?? currentAccount;\n\t\t\tif (!signerAccount) {\n\t\t\t\tthrow new WalletNoAccountSelectedError(\n\t\t\t\t\t'No wallet account is selected to sign the personal message with.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst signPersonalMessageFeature = currentWallet.features['sui:signPersonalMessage'];\n\t\t\tif (signPersonalMessageFeature) {\n\t\t\t\treturn await signPersonalMessageFeature.signPersonalMessage({\n\t\t\t\t\t...signPersonalMessageArgs,\n\t\t\t\t\taccount: signerAccount,\n\t\t\t\t\tchain: signPersonalMessageArgs.chain ?? `sui:${network}`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// TODO: Remove this once we officially discontinue sui:signMessage in the wallet standard\n\t\t\tconst signMessageFeature = currentWallet.features['sui:signMessage'];\n\t\t\tif (signMessageFeature) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"This wallet doesn't support the `signPersonalMessage` feature... falling back to `signMessage`.\",\n\t\t\t\t);\n\n\t\t\t\tconst { messageBytes, signature } = await signMessageFeature.signMessage({\n\t\t\t\t\t...signPersonalMessageArgs,\n\t\t\t\t\taccount: signerAccount,\n\t\t\t\t});\n\t\t\t\treturn { bytes: messageBytes, signature };\n\t\t\t}\n\n\t\t\tthrow new WalletFeatureNotSupportedError(\n\t\t\t\t\"This wallet doesn't support the `signPersonalMessage` feature.\",\n\t\t\t);\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction } from '@mysten/sui/transactions';\nimport { signTransaction } from '@mysten/wallet-standard';\nimport type { SignedTransaction, SuiSignTransactionInput } from '@mysten/wallet-standard';\nimport type { UseMutationOptions, UseMutationResult } from '@tanstack/react-query';\nimport { useMutation } from '@tanstack/react-query';\n\nimport { walletMutationKeys } from '../../constants/walletMutationKeys.js';\nimport {\n\tWalletFeatureNotSupportedError,\n\tWalletNoAccountSelectedError,\n\tWalletNotConnectedError,\n} from '../../errors/walletErrors.js';\nimport type { PartialBy } from '../../types/utilityTypes.js';\nimport { useSuiClientContext } from '../useSuiClient.js';\nimport { useCurrentAccount } from './useCurrentAccount.js';\nimport { useCurrentWallet } from './useCurrentWallet.js';\nimport { useReportTransactionEffects } from './useReportTransactionEffects.js';\n\ntype UseSignTransactionArgs = PartialBy<\n\tOmit<SuiSignTransactionInput, 'transaction'>,\n\t'account' | 'chain'\n> & {\n\ttransaction: Transaction | string;\n};\n\ninterface UseSignTransactionResult extends SignedTransaction {\n\treportTransactionEffects: (effects: string) => void;\n}\n\ntype UseSignTransactionError =\n\t| WalletFeatureNotSupportedError\n\t| WalletNoAccountSelectedError\n\t| WalletNotConnectedError\n\t| Error;\n\ntype UseSignTransactionMutationOptions = Omit<\n\tUseMutationOptions<\n\t\tUseSignTransactionResult,\n\t\tUseSignTransactionError,\n\t\tUseSignTransactionArgs,\n\t\tunknown\n\t>,\n\t'mutationFn'\n>;\n\n/**\n * Mutation hook for prompting the user to sign a transaction.\n */\nexport function useSignTransaction({\n\tmutationKey,\n\t...mutationOptions\n}: UseSignTransactionMutationOptions = {}): UseMutationResult<\n\tUseSignTransactionResult,\n\tUseSignTransactionError,\n\tUseSignTransactionArgs\n> {\n\tconst { currentWallet } = useCurrentWallet();\n\tconst currentAccount = useCurrentAccount();\n\tconst { client, network } = useSuiClientContext();\n\n\tconst { mutate: reportTransactionEffects } = useReportTransactionEffects();\n\n\treturn useMutation({\n\t\tmutationKey: walletMutationKeys.signTransaction(mutationKey),\n\t\tmutationFn: async ({ transaction, ...signTransactionArgs }) => {\n\t\t\tif (!currentWallet) {\n\t\t\t\tthrow new WalletNotConnectedError('No wallet is connected.');\n\t\t\t}\n\n\t\t\tconst signerAccount = signTransactionArgs.account ?? currentAccount;\n\t\t\tif (!signerAccount) {\n\t\t\t\tthrow new WalletNoAccountSelectedError(\n\t\t\t\t\t'No wallet account is selected to sign the transaction with.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!currentWallet.features['sui:signTransaction'] &&\n\t\t\t\t!currentWallet.features['sui:signTransactionBlock']\n\t\t\t) {\n\t\t\t\tthrow new WalletFeatureNotSupportedError(\n\t\t\t\t\t\"This wallet doesn't support the `signTransaction` feature.\",\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst chain = signTransactionArgs.chain ?? `sui:${network}`;\n\t\t\tconst { bytes, signature } = await signTransaction(currentWallet, {\n\t\t\t\t...signTransactionArgs,\n\t\t\t\ttransaction: {\n\t\t\t\t\ttoJSON: async () => {\n\t\t\t\t\t\treturn typeof transaction === 'string'\n\t\t\t\t\t\t\t? transaction\n\t\t\t\t\t\t\t: await transaction.toJSON({\n\t\t\t\t\t\t\t\t\tsupportedIntents: [],\n\t\t\t\t\t\t\t\t\tclient,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\taccount: signerAccount,\n\t\t\t\tchain,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tbytes,\n\t\t\t\tsignature,\n\t\t\t\treportTransactionEffects: (effects) => {\n\t\t\t\t\treportTransactionEffects({\n\t\t\t\t\t\teffects,\n\t\t\t\t\t\taccount: signerAccount,\n\t\t\t\t\t\tchain,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\t...mutationOptions,\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tconst arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/utils';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytesVector`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nimport { isValidNamedPackage } from './move-registry.js';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst isMvrPackage = isValidNamedPackage(address);\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: isMvrPackage ? address : normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n\tConsensusAddressOwner: bcs.struct('ConsensusAddressOwner', {\n\t\towner: Address,\n\t\tstartVersion: bcs.u64(),\n\t}),\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n\tPasskey: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n\tPasskey: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.vector(bcs.u8()),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.vector(bcs.u8()),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, Owner, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionEffects,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n};\nexport {\n\tpureBcsSchemaFromTypeName,\n\ttype ShapeFromPureTypeName,\n\ttype PureTypeName,\n} from './pure.js';\n\nexport { suiBcs as bcs };\n", "/**\n * To add a new error, follow the instructions at\n * https://github.com/wallet-standard/wallet-standard/tree/master/packages/core/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors  e.g. under the same package  can be a good way to namespace them. E.g. All codec-related errors start with `WALLET_STANDARD_ERROR__ACCOUNT__`.\n *   - Use consistent names  e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\n\n// Registry-related errors.\n// Reserve error codes in the range [3834000-3834999].\nexport const WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND = 3834000 as const;\nexport const WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND = 3834001 as const;\n\n// User-related errors.\n// Reserve error codes in the range [4001000-4001999].\nexport const WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED = 4001000 as const;\n\n// Feature-related errors.\n// Reserve error codes in the range [6160000-6160999].\nexport const WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED = 6160000 as const;\nexport const WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED = 6160001 as const;\nexport const WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED = 6160002 as const;\n\n/**\n * A union of every Wallet Standard error code\n *\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like\n * `@wallet-standard/errors` is not safe, for a variety of reasons covered here:\n * https://stackoverflow.com/a/28818850\n */\nexport type WalletStandardErrorCode =\n    | typeof WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED\n    | typeof WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED\n    | typeof WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED\n    | typeof WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND\n    | typeof WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND\n    | typeof WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED;\n", "import type { WalletStandardErrorCode } from './codes.js';\nimport {\n    WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED,\n    WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED,\n    WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED,\n    WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND,\n    WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND,\n    WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED,\n} from './codes.js';\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/wallet-standard/wallet-standard/tree/master/packages/core/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nexport const WalletStandardErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `WalletStandardErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in WalletStandardErrorCode]: string;\n}> = {\n    [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED]:\n        'The wallet account $address does not support the chain `$chain`',\n    [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED]:\n        'The wallet account $address does not support the `$featureName` feature',\n    [WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED]:\n        \"The wallet '$walletName' does not support the `$featureName` feature\",\n    [WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND]:\n        \"No account with address $address could be found in the '$walletName' wallet\",\n    [WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND]:\n        'No underlying Wallet Standard wallet could be found for this handle. This can happen if ' +\n        'the wallet associated with the handle has been unregistered.',\n    [WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED]: 'The user rejected the request',\n};\n", "import type { WalletStandardErrorCode } from './codes.js';\nimport { encodeContextObject } from './context.js';\nimport { WalletStandardErrorMessages } from './messages.js';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends WalletStandardErrorCode>(\n    code: TErrorCode,\n    context: object = {}\n): string {\n    const messageFormatString = WalletStandardErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(\n                variableName in context ? `${context[variableName as keyof typeof context]}` : `$${variableName}`\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends WalletStandardErrorCode>(\n    code: TErrorCode,\n    context: object = {}\n): string {\n    if (process.env.NODE_ENV !== 'production') {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Wallet Standard error #${code}; Decode this error by running \\`npx @wallet-standard/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n", "import type { ReadonlyUint8Array, WalletAccount } from '@wallet-standard/base';\n\n/**\n * Base implementation of a {@link \"@wallet-standard/base\".WalletAccount} to be used or extended by a\n * {@link \"@wallet-standard/base\".Wallet}.\n *\n * `WalletAccount` properties must be read-only. This class enforces this by making all properties\n * [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and\n * read-only, using getters for access, returning copies instead of references, and calling\n * [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n * on the instance.\n *\n * @group Account\n */\nexport class ReadonlyWalletAccount implements WalletAccount {\n    readonly #address: WalletAccount['address'];\n    readonly #publicKey: WalletAccount['publicKey'];\n    readonly #chains: WalletAccount['chains'];\n    readonly #features: WalletAccount['features'];\n    readonly #label: WalletAccount['label'];\n    readonly #icon: WalletAccount['icon'];\n\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.address | WalletAccount::address} */\n    get address() {\n        return this.#address;\n    }\n\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.publicKey | WalletAccount::publicKey} */\n    get publicKey() {\n        return this.#publicKey.slice();\n    }\n\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.chains | WalletAccount::chains} */\n    get chains() {\n        return this.#chains.slice();\n    }\n\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.features | WalletAccount::features} */\n    get features() {\n        return this.#features.slice();\n    }\n\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.label | WalletAccount::label} */\n    get label() {\n        return this.#label;\n    }\n\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.icon | WalletAccount::icon} */\n    get icon() {\n        return this.#icon;\n    }\n\n    /**\n     * Create and freeze a read-only account.\n     *\n     * @param account Account to copy properties from.\n     */\n    constructor(account: WalletAccount) {\n        if (new.target === ReadonlyWalletAccount) {\n            Object.freeze(this);\n        }\n\n        this.#address = account.address;\n        this.#publicKey = account.publicKey.slice();\n        this.#chains = account.chains.slice();\n        this.#features = account.features.slice();\n        this.#label = account.label;\n        this.#icon = account.icon;\n    }\n}\n\n/**\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Util\n */\nexport function arraysEqual<T>(a: Indexed<T>, b: Indexed<T>): boolean {\n    if (a === b) return true;\n\n    const length = a.length;\n    if (length !== b.length) return false;\n\n    for (let i = 0; i < length; i++) {\n        if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n}\n\n/**\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Util\n */\nexport function bytesEqual(a: ReadonlyUint8Array, b: ReadonlyUint8Array): boolean {\n    return arraysEqual(a, b);\n}\n\n/**\n * Efficiently concatenate byte arrays without modifying them.\n *\n * @param first  A byte array.\n * @param others Additional byte arrays.\n *\n * @return New byte array containing the concatenation of all the byte arrays.\n *\n * @group Util\n */\nexport function concatBytes(first: ReadonlyUint8Array, ...others: ReadonlyUint8Array[]): Uint8Array {\n    const length = others.reduce((length, bytes) => length + bytes.length, first.length);\n    const bytes = new Uint8Array(length);\n\n    bytes.set(first, 0);\n    for (const other of others) {\n        bytes.set(other, bytes.length);\n    }\n\n    return bytes;\n}\n\n/**\n * Create a new object with a subset of fields from a source object.\n *\n * @param source Object to pick fields from.\n * @param keys   Names of fields to pick.\n *\n * @return New object with only the picked fields.\n *\n * @group Util\n */\nexport function pick<T, K extends keyof T>(source: T, ...keys: K[]): Pick<T, K> {\n    const picked = {} as Pick<T, K>;\n    for (const key of keys) {\n        picked[key] = source[key];\n    }\n    return picked;\n}\n\n/**\n * Call a callback function, catch an error if it throws, and log the error without rethrowing.\n *\n * @param callback Function to call.\n *\n * @group Util\n */\nexport function guard(callback: () => void) {\n    try {\n        callback();\n    } catch (error) {\n        console.error(error);\n    }\n}\n\n/**\n * @internal\n *\n * Type with a numeric `length` and numerically indexed elements of a generic type `T`.\n *\n * For example, `Array<T>` and `Uint8Array`.\n *\n * @group Internal\n */\nexport interface Indexed<T> {\n    length: number;\n    [index: number]: T;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tconst arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/utils';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytesVector`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst SUI_NS_NAME_REGEX =\n\t/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\n\nexport function isValidSuiNSName(name: string): boolean {\n\tif (name.length > MAX_SUI_NS_NAME_LENGTH) {\n\t\treturn false;\n\t}\n\n\tif (name.includes('@')) {\n\t\treturn SUI_NS_NAME_REGEX.test(name);\n\t}\n\n\treturn SUI_NS_DOMAIN_REGEX.test(name);\n}\n\nexport function normalizeSuiNSName(name: string, format: 'at' | 'dot' = 'at'): string {\n\tconst lowerCase = name.toLowerCase();\n\tlet parts;\n\n\tif (lowerCase.includes('@')) {\n\t\tif (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tconst [labels, domain] = lowerCase.split('@');\n\t\tparts = [...(labels ? labels.split('.') : []), domain];\n\t} else {\n\t\tif (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tparts = lowerCase.split('.').slice(0, -1);\n\t}\n\n\tif (format === 'dot') {\n\t\treturn `${parts.join('.')}.sui`;\n\t}\n\n\treturn `${parts.slice(0, -1).join('.')}@${parts[parts.length - 1]}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidSuiNSName } from './suins.js';\n\n/** The pattern to find an optionally versioned name */\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\n/** The pattern for a valid version number */\nconst VERSION_REGEX = /^\\d+$/;\n/** The maximum size for an app */\nconst MAX_APP_SIZE = 64;\n/** The separator for the name */\nconst NAME_SEPARATOR = '/';\n\nexport const isValidNamedPackage = (name: string): boolean => {\n\tconst parts = name.split(NAME_SEPARATOR);\n\t// The name has to have 2 parts (without-version), or 3 parts (with version).\n\tif (parts.length < 2 || parts.length > 3) return false;\n\n\tconst [org, app, version] = parts; // split by {org} {app} {optional version}\n\n\t// If the version exists, it must be a number.\n\tif (version !== undefined && !VERSION_REGEX.test(version)) return false;\n\t// Check if the org is a valid SuiNS name.\n\tif (!isValidSuiNSName(org)) return false;\n\n\t// Check if the app is a valid name.\n\treturn NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\n\n/**\n * Checks if a type contains valid named packages.\n * This DOES NOT check if the type is a valid Move type.\n */\nexport const isValidNamedType = (type: string): boolean => {\n\t// split our type by all possible type delimeters.\n\tconst splitType = type.split(/::|<|>|,/);\n\tfor (const t of splitType) {\n\t\tif (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n\t}\n\t// TODO: Add `isValidStructTag` check once it's introduced.\n\treturn true;\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nimport { isValidNamedPackage } from './move-registry.js';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst isMvrPackage = isValidNamedPackage(address);\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: isMvrPackage ? address : normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n\tConsensusAddressOwner: bcs.struct('ConsensusAddressOwner', {\n\t\towner: Address,\n\t\tstartVersion: bcs.u64(),\n\t}),\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n\tPasskey: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n\tPasskey: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.vector(bcs.u8()),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.vector(bcs.u8()),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, Owner, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { BcsType } from '@mysten/bcs';\n\nimport { Address } from './bcs.js';\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\ninterface PureShapeByType {\n\tu8: number;\n\tu16: number;\n\tu32: number;\n\tu64: bigint | string | number;\n\tu128: bigint | string | number;\n\tu256: bigint | string | number;\n\tbool: boolean;\n\tstring: string;\n\tid: string | Uint8Array;\n\taddress: string | Uint8Array;\n}\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\nexport type ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? PureShapeByType[T]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = T & {\n\terror: `Invalid Pure type name: ${T}`;\n};\n\nexport function pureBcsSchemaFromTypeName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn Address as never;\n\t}\n\n\tconst generic = name.match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionEffects,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n};\nexport {\n\tpureBcsSchemaFromTypeName,\n\ttype ShapeFromPureTypeName,\n\ttype PureTypeName,\n} from './pure.js';\n\nexport { suiBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n\tconst struct =\n\t\ttypeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n\treturn (\n\t\t!!struct &&\n\t\tnormalizeSuiAddress(struct.package) === normalizeSuiAddress('0x2') &&\n\t\tstruct.module === 'tx_context' &&\n\t\tstruct.type === 'TxContext'\n\t);\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\tif (typeSignature.vector === 'u8') {\n\t\t\treturn bcs.vector(bcs.U8).transform({\n\t\t\t\tinput: (val: string | Uint8Array) =>\n\t\t\t\t\ttypeof val === 'string' ? new TextEncoder().encode(val) : val,\n\t\t\t\toutput: (val) => val,\n\t\t\t});\n\t\t}\n\t\tconst type = getPureBcsSchema(typeSignature.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t}\n\n\tif ('datatype' in typeSignature) {\n\t\tconst pkg = normalizeSuiAddress(typeSignature.datatype.package);\n\n\t\tif (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n\t\t\t) {\n\t\t\t\tconst type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) &&\n\t\t\ttypeSignature.datatype.module === OBJECT_MODULE_NAME &&\n\t\t\ttypeSignature.datatype.type === ID_STRUCT_NAME\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignature {\n\tif (typeof type === 'object' && 'Reference' in type) {\n\t\treturn {\n\t\t\tref: '&',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n\t\t};\n\t}\n\tif (typeof type === 'object' && 'MutableReference' in type) {\n\t\treturn {\n\t\t\tref: '&mut',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n\t\t};\n\t}\n\n\treturn {\n\t\tref: null,\n\t\tbody: normalizedTypeToMoveTypeSignatureBody(type),\n\t};\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n\t}\n\n\tif ('Struct' in type) {\n\t\treturn {\n\t\t\tdatatype: {\n\t\t\t\tpackage: type.Struct.address,\n\t\t\t\tmodule: type.Struct.module,\n\t\t\t\ttype: type.Struct.name,\n\t\t\t\ttypeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody),\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\treturn { typeParameter: type.TypeParameter };\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n\ttypeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\treturn bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n\t}\n\n\tthrow new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n\treturn {\n\t\t$kind: 'Pure',\n\t\tPure: {\n\t\t\tbytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n\t\t},\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'ImmOrOwnedObject',\n\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({\n\t\tobjectId,\n\t\tmutable,\n\t\tinitialSharedVersion,\n\t}: {\n\t\tobjectId: string;\n\t\tmutable: boolean;\n\t\tinitialSharedVersion: number | string;\n\t}): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'SharedObject',\n\t\t\t\tSharedObject: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'Receiving',\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcheck,\n\tinteger,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\nimport type { Simplify } from '@mysten/utils';\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n\tEnumInputShape<\n\t\tSimplify<{\n\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t}>\n\t>,\n\tEnumOutputShape<\n\t\tSimplify<{\n\t\t\t[K in keyof T]: InferOutput<T[K]>;\n\t\t}>\n\t>\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn pipe(\n\t\tunion(unionOptions),\n\t\ttransform((value) => ({\n\t\t\t...value,\n\t\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t\t})),\n\t) as EnumSchema<T>;\n}\n\nexport const SuiAddress = pipe(\n\tstring(),\n\ttransform((value) => normalizeSuiAddress(value)),\n\tcheck(isValidSuiAddress),\n);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n\tunion([string(), pipe(number(), integer())]),\n\n\tcheck((val) => {\n\t\ttry {\n\t\t\tBigInt(val);\n\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, 'Invalid u64'),\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRef>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const Argument = pipe(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n\t\tobject({ Result: pipe(number(), integer()) }),\n\t\tobject({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n\t]),\n\ttransform((value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof Argument>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\nexport type GasData = InferOutput<typeof GasData>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTag>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: GenericSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(lazy(() => OpenMoveTypeSignatureBody)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignature>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\nexport type CallArg = InferOutput<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n});\nexport type TransactionData = InferOutput<typeof TransactionData>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { AsyncTransactionThunk, Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof Argument>\n\t| ((tx: Transaction) => InferInput<typeof Argument>)\n\t| AsyncTransactionThunk;\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof Argument>[],\n\t\taddress: InferInput<typeof Argument>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(Argument, o)),\n\t\t\t\taddress: parse(Argument, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof Argument>,\n\t\tamounts: InferInput<typeof Argument>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(Argument, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof Argument>,\n\t\tsources: InferInput<typeof Argument>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(Argument, destination),\n\t\t\t\tsources: sources.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof Argument>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(Argument, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof Argument>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value) ? value.map((o) => parse(Argument, o)) : parse(Argument, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tbigint,\n\tboolean,\n\tcheck,\n\tinteger,\n\tis,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tparse,\n\tpipe,\n\tstring,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n\tdigest: string(),\n\tobjectId: string(),\n\tversion: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n\tImmOrOwned: ObjectRef,\n\tShared: object({\n\t\tobjectId: ObjectID,\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: literal('pure'),\n\t}),\n]);\n\nconst TransactionExpiration = union([\n\tobject({ Epoch: pipe(number(), integer()) }),\n\tobject({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n\tunion([number(), string(), bigint()]),\n\tcheck((val) => {\n\t\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\t\ttry {\n\t\t\tBigInt(val as string);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n\tobject({ bool: nullable(literal(true)) }),\n\tobject({ u8: nullable(literal(true)) }),\n\tobject({ u64: nullable(literal(true)) }),\n\tobject({ u128: nullable(literal(true)) }),\n\tobject({ address: nullable(literal(true)) }),\n\tobject({ signer: nullable(literal(true)) }),\n\tobject({ vector: lazy(() => TypeTag) }),\n\tobject({ struct: lazy(() => StructTag) }),\n\tobject({ u16: nullable(literal(true)) }),\n\tobject({ u32: nullable(literal(true)) }),\n\tobject({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\ttypeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(ObjectRef)),\n\towner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n\tTransactionInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: pipe(number(), integer()) }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: pipe(number(), integer()),\n\t\tresultIndex: pipe(number(), integer()),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: pipe(\n\t\tstring(),\n\t\tcheck((target) => target.split('::').length === 3),\n\t) as GenericSchema<`${string}::${string}::${string}`>,\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\ttype: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n\tobjects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: nullish(TransactionExpiration),\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionInput),\n\ttransactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n\ttransactionData: TransactionData,\n): SerializedTransactionDataV1 {\n\tconst inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n\t\t(input, index) => {\n\t\t\tif (input.Object) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tObject: input.Object.ImmOrOwnedObject\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tImmOrOwned: input.Object.ImmOrOwnedObject,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: input.Object.Receiving\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\t\tdigest: input.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\t\tversion: input.Object.Receiving.version,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tShared: {\n\t\t\t\t\t\t\t\t\t\t\tmutable: input.Object.SharedObject.mutable,\n\t\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.SharedObject.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'object',\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (input.Pure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tPure: Array.from(fromBase64(input.Pure.bytes)),\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedPure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedPure.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedObject) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedObject.objectId,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t},\n\t);\n\n\treturn {\n\t\tversion: 1,\n\t\tsender: transactionData.sender ?? undefined,\n\t\texpiration:\n\t\t\ttransactionData.expiration?.$kind === 'Epoch'\n\t\t\t\t? { Epoch: Number(transactionData.expiration.Epoch) }\n\t\t\t\t: transactionData.expiration\n\t\t\t\t\t? { None: true }\n\t\t\t\t\t: null,\n\t\tgasConfig: {\n\t\t\towner: transactionData.gasData.owner ?? undefined,\n\t\t\tbudget: transactionData.gasData.budget ?? undefined,\n\t\t\tprice: transactionData.gasData.price ?? undefined,\n\t\t\tpayment: transactionData.gasData.payment ?? undefined,\n\t\t},\n\t\tinputs,\n\t\ttransactions: transactionData.commands.map((command): InferOutput<typeof TransactionType> => {\n\t\t\tif (command.MakeMoveVec) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\t\ttype:\n\t\t\t\t\t\tcommand.MakeMoveVec.type === null\n\t\t\t\t\t\t\t? { None: true }\n\t\t\t\t\t\t\t: { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n\t\t\t\t\tobjects: command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MergeCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MergeCoins',\n\t\t\t\t\tdestination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n\t\t\t\t\tsources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MoveCall) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MoveCall',\n\t\t\t\t\ttarget: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n\t\t\t\t\ttypeArguments: command.MoveCall.typeArguments,\n\t\t\t\t\targuments: command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.Publish) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Publish',\n\t\t\t\t\tmodules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Publish.dependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.SplitCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'SplitCoins',\n\t\t\t\t\tcoin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n\t\t\t\t\tamounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.TransferObjects) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'TransferObjects',\n\t\t\t\t\tobjects: command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t\taddress: convertTransactionArgument(command.TransferObjects.address, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.Upgrade) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Upgrade',\n\t\t\t\t\tmodules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Upgrade.dependencies,\n\t\t\t\t\tpackageId: command.Upgrade.package,\n\t\t\t\t\tticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(command)}`);\n\t\t}),\n\t};\n}\n\nfunction convertTransactionArgument(\n\targ: Argument,\n\tinputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n\tif (arg.$kind === 'GasCoin') {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\tif (arg.$kind === 'Result') {\n\t\treturn { kind: 'Result', index: arg.Result };\n\t}\n\tif (arg.$kind === 'NestedResult') {\n\t\treturn { kind: 'NestedResult', index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n\t}\n\tif (arg.$kind === 'Input') {\n\t\treturn inputs[arg.Input];\n\t}\n\n\tthrow new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n\treturn parse(TransactionData, {\n\t\tversion: 2,\n\t\tsender: data.sender ?? null,\n\t\texpiration: data.expiration\n\t\t\t? 'Epoch' in data.expiration\n\t\t\t\t? { Epoch: data.expiration.Epoch }\n\t\t\t\t: { None: true }\n\t\t\t: null,\n\t\tgasData: {\n\t\t\towner: data.gasConfig.owner ?? null,\n\t\t\tbudget: data.gasConfig.budget?.toString() ?? null,\n\t\t\tprice: data.gasConfig.price?.toString() ?? null,\n\t\t\tpayment:\n\t\t\t\tdata.gasConfig.payment?.map((ref) => ({\n\t\t\t\t\tdigest: ref.digest,\n\t\t\t\t\tobjectId: ref.objectId,\n\t\t\t\t\tversion: ref.version.toString(),\n\t\t\t\t})) ?? null,\n\t\t},\n\t\tinputs: data.inputs.map((input) => {\n\t\t\tif (input.kind === 'Input') {\n\t\t\t\tif (is(NormalizedCallArg, input.value)) {\n\t\t\t\t\tconst value = parse(NormalizedCallArg, input.value);\n\n\t\t\t\t\tif (value.Object) {\n\t\t\t\t\t\tif (value.Object.ImmOrOwned) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.ImmOrOwned.objectId,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.ImmOrOwned.version),\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.ImmOrOwned.digest,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Shared) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tSharedObject: {\n\t\t\t\t\t\t\t\t\t\tmutable: value.Object.Shared.mutable ?? null,\n\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: value.Object.Shared.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Shared.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Receiving) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.Receiving.version),\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error('Invalid object input');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: toBase64(new Uint8Array(value.Pure)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'object') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: input.value as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tUnresolvedPure: {\n\t\t\t\t\t\tvalue: input.value,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t}),\n\t\tcommands: data.transactions.map((transaction) => {\n\t\t\tswitch (transaction.kind) {\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMakeMoveVec: {\n\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t'Some' in transaction.type\n\t\t\t\t\t\t\t\t\t? TypeTagSerializer.tagToString(transaction.type.Some)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\telements: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\tcase 'MergeCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMergeCoins: {\n\t\t\t\t\t\t\tdestination: parseV1TransactionArgument(transaction.destination),\n\t\t\t\t\t\t\tsources: transaction.sources.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'MoveCall': {\n\t\t\t\t\tconst [pkg, mod, fn] = transaction.target.split('::');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMoveCall: {\n\t\t\t\t\t\t\tpackage: pkg,\n\t\t\t\t\t\t\tmodule: mod,\n\t\t\t\t\t\t\tfunction: fn,\n\t\t\t\t\t\t\ttypeArguments: transaction.typeArguments,\n\t\t\t\t\t\t\targuments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Publish': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPublish: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'SplitCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tSplitCoins: {\n\t\t\t\t\t\t\tcoin: parseV1TransactionArgument(transaction.coin),\n\t\t\t\t\t\t\tamounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'TransferObjects': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tTransferObjects: {\n\t\t\t\t\t\t\tobjects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t\taddress: parseV1TransactionArgument(transaction.address),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Upgrade': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUpgrade: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t\tpackage: transaction.packageId,\n\t\t\t\t\t\t\tticket: parseV1TransactionArgument(transaction.ticket),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(transaction)}`);\n\t\t}),\n\t} satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n\targ: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n\tswitch (arg.kind) {\n\t\tcase 'GasCoin': {\n\t\t\treturn { GasCoin: true };\n\t\t}\n\t\tcase 'Result':\n\t\t\treturn { Result: arg.index };\n\t\tcase 'NestedResult': {\n\t\t\treturn { NestedResult: [arg.index, arg.resultIndex] };\n\t\t}\n\t\tcase 'Input': {\n\t\t\treturn { Input: arg.index };\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, SuiAddress } from './internal.js';\nimport type { Simplify } from '@mysten/utils';\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n\treturn union(\n\t\tObject.entries(options).map(([key, value]) => object({ [key]: value })),\n\t) as GenericSchema<\n\t\tEnumInputShape<\n\t\t\tSimplify<{\n\t\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t\t}>\n\t\t>\n\t>;\n}\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n\tGasCoin: literal(true),\n\tInput: pipe(number(), integer()),\n\tResult: pipe(number(), integer()),\n\tNestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n});\n\nconst $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\n\nconst TransactionExpiration = enumUnion({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2 = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n\tdigest: optional(nullable(string())),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../../utils/index.js';\nimport { ObjectRef } from '../../transactions/data/internal.js';\nimport type { CallArg, Command, OpenMoveTypeSignature } from '../../transactions/data/internal.js';\nimport { Inputs } from '../../transactions/Inputs.js';\nimport {\n\tgetPureBcsSchema,\n\tisTxContext,\n\tnormalizedTypeToMoveTypeSignature,\n} from '../../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { SuiClient } from '../../client/index.js';\nimport type { BuildTransactionOptions } from '../../transactions/index.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport function suiClientResolveTransactionPlugin(client: SuiClient) {\n\treturn async function resolveTransactionData(\n\t\ttransactionData: TransactionDataBuilder,\n\t\toptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) {\n\t\tawait normalizeInputs(transactionData, client);\n\t\tawait resolveObjectReferences(transactionData, client);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait setGasPrice(transactionData, client);\n\t\t\tawait setGasBudget(transactionData, client);\n\t\t\tawait setGasPayment(transactionData, client);\n\t\t}\n\n\t\treturn await next();\n\t};\n}\n\nasync function setGasPrice(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await client.dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await client.getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));\n\t}\n}\n\nasync function resolveObjectReferences(transactionData: TransactionDataBuilder, client: SuiClient) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tclient.multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? 'Shared' in owner\n\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t: 'ConsensusAddressOwner' in owner\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.start_version\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) => input?.UnresolvedPure || input?.UnresolvedObject,\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\n\nimport type { ClientWithCoreApi } from '../experimental/index.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\nimport type { BcsType } from '@mysten/bcs';\nimport { Inputs } from './Inputs.js';\nimport { bcs } from '../bcs/index.js';\nimport { suiClientResolveTransactionPlugin } from '../experimental/transports/json-rpc-resolver.js';\nimport type { SuiClient } from '../client/index.js';\n\nexport interface BuildTransactionOptions {\n\tclient?: ClientWithCoreApi;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport function needsTransactionResolution(\n\tdata: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n): boolean {\n\tif (\n\t\tdata.inputs.some((input) => {\n\t\t\treturn input.UnresolvedObject || input.UnresolvedPure;\n\t\t})\n\t) {\n\t\treturn true;\n\t}\n\n\tif (!options.onlyTransactionKind) {\n\t\tif (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function resolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tnormalizeRawArguments(transactionData);\n\tif (!needsTransactionResolution(transactionData, options)) {\n\t\tawait validate(transactionData);\n\t\treturn next();\n\t}\n\n\tconst client = getClient(options);\n\tconst plugin =\n\t\tclient.core?.resolveTransactionPlugin() ??\n\t\tsuiClientResolveTransactionPlugin(client as SuiClient);\n\n\treturn plugin(transactionData, options, async () => {\n\t\tawait validate(transactionData);\n\t\tawait next();\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction normalizeRawArguments(transactionData: TransactionDataBuilder) {\n\tfor (const command of transactionData.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n\tfunction object(value: TransactionObjectInput) {\n\t\treturn makeObject(value);\n\t}\n\n\tobject.system = () => object('0x5');\n\tobject.clock = () => object('0x6');\n\tobject.random = () => object('0x8');\n\tobject.denyList = () => object('0x403');\n\tobject.option =\n\t\t({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.moveCall({\n\t\t\t\ttypeArguments: [type],\n\t\t\t\ttarget: `0x1::option::${value === null ? 'none' : 'some'}`,\n\t\t\t\targuments: value === null ? [] : [tx.object(value)],\n\t\t\t});\n\n\treturn object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<T extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<T> : T,\n\t\tvalue: ShapeFromPureTypeName<T>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(index: number, replacement: Command | Command[], resultIndex = index) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\t\tthis.commands.splice(index, 1, ...replacement);\n\n\t\tif (sizeDiff !== 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result === index) {\n\t\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] === index) {\n\t\t\t\t\t\t\targ.NestedResult[0] = resultIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionData, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { is } from 'valibot';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg } from './data/internal.js';\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\n\tif (arg.Object) {\n\t\tif (arg.Object.ImmOrOwnedObject) {\n\t\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\n\t\tif (arg.Object.Receiving) {\n\t\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t\t}\n\n\t\treturn normalizeSuiAddress(arg.Object.SharedObject.objectId);\n\t}\n\n\tif (arg.UnresolvedObject) {\n\t\treturn normalizeSuiAddress(arg.UnresolvedObject.objectId);\n\t}\n\n\treturn undefined;\n}\n\nexport function isArgument(value: unknown): value is Argument {\n\treturn is(Argument, value);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface ClientCacheOptions {\n\tprefix?: string[];\n\tcache?: Map<string, unknown>;\n}\n\nexport class ClientCache {\n\t#prefix: string[];\n\t#cache: Map<string, unknown>;\n\n\tconstructor({ prefix, cache }: ClientCacheOptions = {}) {\n\t\tthis.#prefix = prefix ?? [];\n\t\tthis.#cache = cache ?? new Map();\n\t}\n\n\tread<T>(key: [string, ...string[]], load: () => T | Promise<T>): T | Promise<T> {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\tif (typeof result === 'object' && result !== null && 'then' in result) {\n\t\t\treturn Promise.resolve(result)\n\t\t\t\t.then((v) => {\n\t\t\t\t\tthis.#cache.set(cacheKey, v);\n\t\t\t\t\treturn v as T;\n\t\t\t\t})\n\t\t\t\t.catch((err) => {\n\t\t\t\t\tthis.#cache.delete(cacheKey);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t}\n\n\t\treturn result as T;\n\t}\n\n\treadSync<T>(key: [string, ...string[]], load: () => T): T {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\treturn result as T;\n\t}\n\n\tclear(prefix?: string[]) {\n\t\tconst prefixKey = [...this.#prefix, ...(prefix ?? [])].join(':');\n\t\tif (!prefixKey) {\n\t\t\tthis.#cache.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const key of this.#cache.keys()) {\n\t\t\tif (key.startsWith(prefixKey)) {\n\t\t\t\tthis.#cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tscope(prefix: string | string[]) {\n\t\treturn new ClientCache({\n\t\t\tprefix: [...this.#prefix, ...(Array.isArray(prefix) ? prefix : [prefix])],\n\t\t\tcache: this.#cache,\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '1.36.1';\nexport const TARGETED_RPC_VERSION = '1.53.0';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { Experimental_SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements Experimental_SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: Experimental_SuiClientTypes.MvrResolvePackageOptions): Promise<Experimental_SuiClientTypes.MvrResolvePackageResponse> {\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: Experimental_SuiClientTypes.MvrResolveTypeOptions): Promise<Experimental_SuiClientTypes.MvrResolveTypeResponse> {\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: Experimental_SuiClientTypes.MvrResolveOptions): Promise<Experimental_SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: Experimental_SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '../../experimental/cache.js';\nimport { MvrClient } from '../../experimental/mvr.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\nimport { findNamesInTransaction, replaceNames } from '../../experimental/mvr.js';\nimport type { NamedPackagesOverrides } from '../../experimental/mvr.js';\n\nexport type NamedPackagesPluginOptions = {\n\t/**\n\t * The URL of the MVR API to use for resolving names.\n\t */\n\turl: string;\n\t/**\n\t * The number of names to resolve in each batch request.\n\t * Needs to be calculated based on the GraphQL query limits.\n\t */\n\tpageSize?: number;\n\t/**\n\t * Local overrides for the resolution plugin. Pass this to pre-populate\n\t * the cache with known packages / types (especially useful for local or CI testing).\n\t *\n\t * The type cache expects ONLY first-level types to ensure the cache is more composable.\n\t *\n\t * \tExpected format example:\n\t *  {\n\t * \t\tpackages: {\n\t * \t\t\t'@framework/std': '0x1234',\n\t * \t\t},\n\t * \t\ttypes: {\n\t * \t\t\t'@framework/std::string::String': '0x1234::string::String',\n\t * \t\t},\n\t * \t}\n\t *\n\t */\n\toverrides?: NamedPackagesOverrides;\n};\n\n// The original versions of the mvr plugin cached lookups by mutating overrides.\n// We don't want to mutate the options, but we can link our cache to the provided overrides object\n// This preserves the caching across transactions while removing the mutation side effects\nconst cacheMap = new WeakMap<object, ClientCache>();\n\n/**\n * @experimental This plugin is in experimental phase and there might be breaking changes in the future\n *\n * Adds named resolution so that you can use .move names in your transactions.\n * e.g. `@org/app::type::Type` will be resolved to `0x1234::type::Type`.\n * This plugin will resolve all names & types in the transaction block.\n *\n * To install this plugin globally in your app, use:\n * ```\n * Transaction.registerGlobalSerializationPlugin(\"namedPackagesPlugin\", namedPackagesPlugin({ suiGraphQLClient }));\n * ```\n *\n * You can also define `overrides` to pre-populate name resolutions locally (removes the GraphQL request).\n */\nexport const namedPackagesPlugin = (options?: NamedPackagesPluginOptions) => {\n\tlet mvrClient: MvrClient | undefined;\n\n\tif (options) {\n\t\tconst overrides = options.overrides ?? {\n\t\t\tpackages: {},\n\t\t\ttypes: {},\n\t\t};\n\n\t\tif (!cacheMap.has(overrides)) {\n\t\t\tcacheMap.set(overrides, new ClientCache());\n\t\t}\n\n\t\tmvrClient = new MvrClient({\n\t\t\tcache: cacheMap.get(overrides)!,\n\t\t\turl: options.url,\n\t\t\tpageSize: options.pageSize,\n\t\t\toverrides: overrides,\n\t\t});\n\t}\n\n\treturn async (\n\t\ttransactionData: TransactionDataBuilder,\n\t\tbuildOptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) => {\n\t\tconst names = findNamesInTransaction(transactionData);\n\n\t\tif (names.types.length === 0 && names.packages.length === 0) {\n\t\t\treturn next();\n\t\t}\n\n\t\tconst resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n\t\t\ttypes: names.types,\n\t\t\tpackages: names.packages,\n\t\t});\n\n\t\treplaceNames(transactionData, resolved);\n\n\t\tawait next();\n\t};\n};\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SuiClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n\t| ((tx: Transaction) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch (e) {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | Transaction) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = new TransactionDataBuilder(transaction.getData());\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(Argument, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(Argument, resolved);\n\t\t}\n\n\t\treturn parse(Argument, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#data.commands.some((cmd) => cmd.$Intent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\tconst createNext = (i: number) => {\n\t\t\tif (i >= plugins.length) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t\tconst plugin = plugins[i];\n\n\t\t\treturn async () => {\n\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\tlet calledNext = false;\n\t\t\t\tlet nextResolved = false;\n\n\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\tawait next();\n\n\t\t\t\t\tnextResolved = true;\n\t\t\t\t});\n\n\t\t\t\tif (!calledNext) {\n\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t}\n\n\t\t\t\tif (!nextResolved) {\n\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tawait createNext(0)();\n\n\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\tthis.#commandSection = this.#data.commands.slice();\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature } from './data/internal.js';\nimport type { TransactionPlugin } from './resolve.js';\n\nexport interface ObjectCacheEntry {\n\tobjectId: string;\n\tversion: string;\n\tdigest: string;\n\towner: string | null;\n\tinitialSharedVersion: string | null;\n}\n\nexport interface MoveFunctionCacheEntry {\n\tpackage: string;\n\tmodule: string;\n\tfunction: string;\n\tparameters: OpenMoveTypeSignature[];\n}\n\nexport interface CacheEntryTypes {\n\tOwnedObject: ObjectCacheEntry;\n\tSharedOrImmutableObject: ObjectCacheEntry;\n\tMoveFunction: MoveFunctionCacheEntry;\n\tCustom: unknown;\n}\nexport abstract class AsyncCache {\n\tprotected abstract get<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t): Promise<CacheEntryTypes[T] | null>;\n\tprotected abstract set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t): Promise<void>;\n\tprotected abstract delete<T extends keyof CacheEntryTypes>(type: T, key: string): Promise<void>;\n\tabstract clear<T extends keyof CacheEntryTypes>(type?: T): Promise<void>;\n\n\tasync getObject(id: string) {\n\t\tconst [owned, shared] = await Promise.all([\n\t\t\tthis.get('OwnedObject', id),\n\t\t\tthis.get('SharedOrImmutableObject', id),\n\t\t]);\n\n\t\treturn owned ?? shared ?? null;\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn Promise.all([...ids.map((id) => this.getObject(id))]);\n\t}\n\n\tasync addObject(object: ObjectCacheEntry) {\n\t\tif (object.owner) {\n\t\t\tawait this.set('OwnedObject', object.objectId, object);\n\t\t} else {\n\t\t\tawait this.set('SharedOrImmutableObject', object.objectId, object);\n\t\t}\n\n\t\treturn object;\n\t}\n\n\tasync addObjects(objects: ObjectCacheEntry[]) {\n\t\tawait Promise.all(objects.map(async (object) => this.addObject(object)));\n\t}\n\n\tasync deleteObject(id: string) {\n\t\tawait Promise.all([this.delete('OwnedObject', id), this.delete('SharedOrImmutableObject', id)]);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\tawait Promise.all(ids.map((id) => this.deleteObject(id)));\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\treturn this.get('MoveFunction', functionName);\n\t}\n\n\tasync addMoveFunctionDefinition(functionEntry: MoveFunctionCacheEntry) {\n\t\tconst pkg = normalizeSuiAddress(functionEntry.package);\n\t\tconst functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n\t\tconst entry = {\n\t\t\t...functionEntry,\n\t\t\tpackage: pkg,\n\t\t};\n\n\t\tawait this.set('MoveFunction', functionName, entry);\n\n\t\treturn entry;\n\t}\n\n\tasync deleteMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\tawait this.delete('MoveFunction', functionName);\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.get('Custom', key) as Promise<T | null>;\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.set('Custom', key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.delete('Custom', key);\n\t}\n}\n\nexport class InMemoryCache extends AsyncCache {\n\t#caches = {\n\t\tOwnedObject: new Map<string, ObjectCacheEntry>(),\n\t\tSharedOrImmutableObject: new Map<string, ObjectCacheEntry>(),\n\t\tMoveFunction: new Map<string, MoveFunctionCacheEntry>(),\n\t\tCustom: new Map<string, unknown>(),\n\t};\n\n\tprotected async get<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\treturn (this.#caches[type].get(key) as CacheEntryTypes[T]) ?? null;\n\t}\n\n\tprotected async set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t) {\n\t\t(this.#caches[type] as Map<string, typeof value>).set(key, value as never);\n\t}\n\n\tprotected async delete<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\tthis.#caches[type].delete(key);\n\t}\n\n\tasync clear<T extends keyof CacheEntryTypes>(type?: T) {\n\t\tif (type) {\n\t\t\tthis.#caches[type].clear();\n\t\t} else {\n\t\t\tfor (const cache of Object.values(this.#caches)) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface ObjectCacheOptions {\n\tcache?: AsyncCache;\n\tonEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n}\n\nexport class ObjectCache {\n\t#cache: AsyncCache;\n\t#onEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n\n\tconstructor({ cache = new InMemoryCache(), onEffects }: ObjectCacheOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#onEffects = onEffects;\n\t}\n\n\tasPlugin(): TransactionPlugin {\n\t\treturn async (transactionData, _options, next) => {\n\t\t\tconst unresolvedObjects = transactionData.inputs\n\t\t\t\t.filter((input) => input.UnresolvedObject)\n\t\t\t\t.map((input) => input.UnresolvedObject!.objectId);\n\n\t\t\tconst cached = (await this.#cache.getObjects(unresolvedObjects)).filter(\n\t\t\t\t(obj) => obj !== null,\n\t\t\t);\n\n\t\t\tconst byId = new Map(cached.map((obj) => [obj!.objectId, obj]));\n\n\t\t\tfor (const input of transactionData.inputs) {\n\t\t\t\tif (!input.UnresolvedObject) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst cached = byId.get(input.UnresolvedObject.objectId);\n\n\t\t\t\tif (!cached) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cached.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion = cached.initialSharedVersion;\n\t\t\t\t} else {\n\t\t\t\t\tif (cached.version && !input.UnresolvedObject.version) {\n\t\t\t\t\t\tinput.UnresolvedObject.version = cached.version;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cached.digest && !input.UnresolvedObject.digest) {\n\t\t\t\t\t\tinput.UnresolvedObject.digest = cached.digest;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall) {\n\t\t\t\t\t\tconst def = await this.getMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (def) {\n\t\t\t\t\t\t\tcommands.MoveCall._argumentTypes = def.parameters;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tawait next();\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall?._argumentTypes) {\n\t\t\t\t\t\tawait this.#cache.addMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t\tparameters: commands.MoveCall._argumentTypes,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\tasync clear() {\n\t\tawait this.#cache.clear();\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\treturn this.#cache.getMoveFunctionDefinition(ref);\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn this.#cache.getObjects(ids);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\treturn this.#cache.deleteObjects(ids);\n\t}\n\n\tasync clearOwnedObjects() {\n\t\tawait this.#cache.clear('OwnedObject');\n\t}\n\n\tasync clearCustom() {\n\t\tawait this.#cache.clear('Custom');\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.#cache.getCustom<T>(key);\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.#cache.setCustom(key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.#cache.deleteCustom(key);\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tif (!effects.V2) {\n\t\t\tthrow new Error(`Unsupported transaction effects version ${effects.$kind}`);\n\t\t}\n\n\t\tconst { lamportVersion, changedObjects } = effects.V2;\n\n\t\tconst deletedIds: string[] = [];\n\t\tconst addedObjects: ObjectCacheEntry[] = [];\n\n\t\tchangedObjects.forEach(([id, change]) => {\n\t\t\tif (change.outputState.NotExist) {\n\t\t\t\tdeletedIds.push(id);\n\t\t\t} else if (change.outputState.ObjectWrite) {\n\t\t\t\tconst [digest, owner] = change.outputState.ObjectWrite;\n\n\t\t\t\taddedObjects.push({\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion: lamportVersion,\n\t\t\t\t\towner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n\t\t\t\t\tinitialSharedVersion: owner.Shared?.initialSharedVersion ?? null,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all([\n\t\t\tthis.#cache.addObjects(addedObjects),\n\t\t\tthis.#cache.deleteObjects(deletedIds),\n\t\t\tthis.#onEffects?.(effects),\n\t\t]);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../../bcs/index.js';\nimport type { ExecuteTransactionBlockParams, SuiClient } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { ObjectCache } from '../ObjectCache.js';\nimport type { Transaction } from '../Transaction.js';\nimport { isTransaction } from '../Transaction.js';\n\nexport class CachingTransactionExecutor {\n\t#client: SuiClient;\n\t#lastDigest: string | null = null;\n\tcache: ObjectCache;\n\n\tconstructor({\n\t\tclient,\n\t\t...options\n\t}: ObjectCacheOptions & {\n\t\tclient: SuiClient;\n\t}) {\n\t\tthis.#client = client;\n\t\tthis.cache = new ObjectCache(options);\n\t}\n\n\t/**\n\t * Clears all Owned objects\n\t * Immutable objects, Shared objects, and Move function definitions will be preserved\n\t */\n\tasync reset() {\n\t\tawait Promise.all([\n\t\t\tthis.cache.clearOwnedObjects(),\n\t\t\tthis.cache.clearCustom(),\n\t\t\tthis.waitForLastTransaction(),\n\t\t]);\n\t}\n\n\tasync buildTransaction({\n\t\ttransaction,\n\t\t...options\n\t}: { transaction: Transaction } & BuildTransactionOptions) {\n\t\ttransaction.addBuildPlugin(this.cache.asPlugin());\n\t\treturn transaction.build({\n\t\t\tclient: this.#client,\n\t\t\t...options,\n\t\t});\n\t}\n\n\tasync executeTransaction({\n\t\ttransaction,\n\t\toptions,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction | Uint8Array;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock'>) {\n\t\tconst bytes = isTransaction(transaction)\n\t\t\t? await this.buildTransaction({ transaction })\n\t\t\t: transaction;\n\n\t\tconst results = await this.#client.executeTransactionBlock({\n\t\t\t...input,\n\t\t\ttransactionBlock: bytes,\n\t\t\toptions: {\n\t\t\t\t...options,\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tif (results.rawEffects) {\n\t\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n\t\t\tawait this.applyEffects(effects);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tasync signAndExecuteTransaction({\n\t\toptions,\n\t\ttransaction,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction;\n\n\t\tsigner: Signer;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock' | 'signature'>) {\n\t\ttransaction.setSenderIfNotSet(input.signer.toSuiAddress());\n\t\tconst bytes = await this.buildTransaction({ transaction });\n\t\tconst { signature } = await input.signer.signTransaction(bytes);\n\t\tconst results = await this.executeTransaction({\n\t\t\ttransaction: bytes,\n\t\t\tsignature,\n\t\t\toptions,\n\t\t});\n\n\t\treturn results;\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tthis.#lastDigest = effects.V2?.transactionDigest ?? null;\n\t\tawait this.cache.applyEffects(effects);\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tif (this.#lastDigest) {\n\t\t\tawait this.#client.waitForTransaction({ digest: this.#lastDigest });\n\t\t\tthis.#lastDigest = null;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class SerialQueue {\n\t#queue: Array<() => void> = [];\n\n\tasync runTask<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.#queue.push(() => {\n\t\t\t\ttask()\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tthis.#queue.shift();\n\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\tthis.#queue[0]();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve, reject);\n\t\t\t});\n\n\t\t\tif (this.#queue.length === 1) {\n\t\t\t\tthis.#queue[0]();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class ParallelQueue {\n\t#queue: Array<() => void> = [];\n\tactiveTasks = 0;\n\tmaxTasks: number;\n\n\tconstructor(maxTasks: number) {\n\t\tthis.maxTasks = maxTasks;\n\t}\n\n\trunTask<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\tif (this.activeTasks < this.maxTasks) {\n\t\t\t\tthis.activeTasks++;\n\n\t\t\t\ttask()\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\tthis.#queue.shift()!();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.activeTasks--;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve, reject);\n\t\t\t} else {\n\t\t\t\tthis.#queue.push(() => {\n\t\t\t\t\ttask()\n\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\t\tthis.#queue.shift()!();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.activeTasks--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(resolve, reject);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\n\nimport type { bcs } from '../../bcs/index.js';\nimport type { SuiClient, SuiTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { isTransaction, Transaction } from '../Transaction.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { SerialQueue } from './queue.js';\n\nexport class SerialTransactionExecutor {\n\t#queue = new SerialQueue();\n\t#signer: Signer;\n\t#cache: CachingTransactionExecutor;\n\t#defaultGasBudget: bigint;\n\n\tconstructor({\n\t\tsigner,\n\t\tdefaultGasBudget = 50_000_000n,\n\t\t...options\n\t}: Omit<ObjectCacheOptions, 'address'> & {\n\t\tclient: SuiClient;\n\t\tsigner: Signer;\n\t\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `50_000_000n` */\n\t\tdefaultGasBudget?: bigint;\n\t}) {\n\t\tthis.#signer = signer;\n\t\tthis.#defaultGasBudget = defaultGasBudget;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t\tonEffects: (effects) => this.#cacheGasCoin(effects),\n\t\t});\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\treturn this.#cache.applyEffects(effects);\n\t}\n\n\t#cacheGasCoin = async (effects: typeof bcs.TransactionEffects.$inferType) => {\n\t\tif (!effects.V2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasCoin = getGasCoinFromEffects(effects).ref;\n\t\tif (gasCoin) {\n\t\t\tthis.#cache.cache.setCustom('gasCoin', gasCoin);\n\t\t} else {\n\t\t\tthis.#cache.cache.deleteCustom('gasCoin');\n\t\t}\n\t};\n\n\tasync buildTransaction(transaction: Transaction) {\n\t\treturn this.#queue.runTask(() => this.#buildTransaction(transaction));\n\t}\n\n\t#buildTransaction = async (transaction: Transaction) => {\n\t\tconst gasCoin = await this.#cache.cache.getCustom<{\n\t\t\tobjectId: string;\n\t\t\tversion: string;\n\t\t\tdigest: string;\n\t\t}>('gasCoin');\n\n\t\tconst copy = Transaction.from(transaction);\n\t\tif (gasCoin) {\n\t\t\tcopy.setGasPayment([gasCoin]);\n\t\t}\n\n\t\tcopy.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\t\tcopy.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\treturn this.#cache.buildTransaction({ transaction: copy });\n\t};\n\n\tresetCache() {\n\t\treturn this.#cache.reset();\n\t}\n\n\twaitForLastTransaction() {\n\t\treturn this.#cache.waitForLastTransaction();\n\t}\n\n\texecuteTransaction(\n\t\ttransaction: Transaction | Uint8Array,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\treturn this.#queue.runTask(async () => {\n\t\t\tconst bytes = isTransaction(transaction)\n\t\t\t\t? await this.#buildTransaction(transaction)\n\t\t\t\t: transaction;\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\t\t\tconst results = await this.#cache\n\t\t\t\t.executeTransaction({\n\t\t\t\t\tsignature: [signature, ...additionalSignatures],\n\t\t\t\t\ttransaction: bytes,\n\t\t\t\t\toptions,\n\t\t\t\t})\n\t\t\t\t.catch(async (error) => {\n\t\t\t\t\tawait this.resetCache();\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t});\n\t}\n}\n\nexport function getGasCoinFromEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\tif (!effects.V2) {\n\t\tthrow new Error('Unexpected effects version');\n\t}\n\n\tconst gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex!];\n\n\tif (!gasObjectChange) {\n\t\tthrow new Error('Gas object not found in effects');\n\t}\n\n\tconst [objectId, { outputState }] = gasObjectChange;\n\n\tif (!outputState.ObjectWrite) {\n\t\tthrow new Error('Unexpected gas object state');\n\t}\n\n\tconst [digest, owner] = outputState.ObjectWrite;\n\n\treturn {\n\t\tref: {\n\t\t\tobjectId,\n\t\t\tdigest,\n\t\t\tversion: effects.V2.lamportVersion,\n\t\t},\n\t\towner: owner.AddressOwner || owner.ObjectOwner!,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport { promiseWithResolvers } from '@mysten/utils';\nimport { bcs } from '../../bcs/index.js';\nimport type { SuiObjectRef } from '../../bcs/types.js';\nimport type {\n\tSuiClient,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n\tcoinBatchSize: 20,\n\tinitialCoinBalance: 200_000_000n,\n\tminimumCoinBalance: 50_000_000n,\n\tmaxPoolSize: 50,\n\tepochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n\tclient: SuiClient;\n\tsigner: Signer;\n\t/** The number of coins to create in a batch when refilling the gas pool */\n\tcoinBatchSize?: number;\n\t/** The initial balance of each coin created for the gas pool */\n\tinitialCoinBalance?: bigint;\n\t/** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n\tminimumCoinBalance?: bigint;\n\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n\tdefaultGasBudget?: bigint;\n\t/**\n\t * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n\t * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n\t * gas price is up-to-date for the next epoch.\n\t * */\n\tepochBoundaryWindow?: number;\n\t/** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n\tmaxPoolSize?: number;\n\t/** An initial list of coins used to fund the gas pool, uses all owned SUI coins by default */\n\tsourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n\tid: string;\n\tversion: string;\n\tdigest: string;\n\tbalance: bigint;\n}\nexport class ParallelTransactionExecutor {\n\t#signer: Signer;\n\t#client: SuiClient;\n\t#coinBatchSize: number;\n\t#initialCoinBalance: bigint;\n\t#minimumCoinBalance: bigint;\n\t#epochBoundaryWindow: number;\n\t#defaultGasBudget: bigint;\n\t#maxPoolSize: number;\n\t#sourceCoins: Map<string, SuiObjectRef | null> | null;\n\t#coinPool: CoinWithBalance[] = [];\n\t#cache: CachingTransactionExecutor;\n\t#objectIdQueues = new Map<string, (() => void)[]>();\n\t#buildQueue = new SerialQueue();\n\t#executeQueue: ParallelQueue;\n\t#lastDigest: string | null = null;\n\t#cacheLock: Promise<void> | null = null;\n\t#pendingTransactions = 0;\n\t#gasPrice: null | {\n\t\tprice: bigint;\n\t\texpiration: number;\n\t} = null;\n\n\tconstructor(options: ParallelTransactionExecutorOptions) {\n\t\tthis.#signer = options.signer;\n\t\tthis.#client = options.client;\n\t\tthis.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n\t\tthis.#initialCoinBalance =\n\t\t\toptions.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n\t\tthis.#minimumCoinBalance =\n\t\t\toptions.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n\t\tthis.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n\t\tthis.#epochBoundaryWindow =\n\t\t\toptions.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n\t\tthis.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t});\n\t\tthis.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n\t\tthis.#sourceCoins = options.sourceCoins\n\t\t\t? new Map(options.sourceCoins.map((id) => [id, null]))\n\t\t\t: null;\n\t}\n\n\tresetCache() {\n\t\tthis.#gasPrice = null;\n\t\treturn this.#updateCache(() => this.#cache.reset());\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tawait this.#updateCache(() => this.#waitForLastDigest());\n\t}\n\n\tasync executeTransaction(\n\t\ttransaction: Transaction,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\tconst { promise, resolve, reject } = promiseWithResolvers<{\n\t\t\tdigest: string;\n\t\t\teffects: string;\n\t\t\tdata: SuiTransactionBlockResponse;\n\t\t}>();\n\t\tconst usedObjects = await this.#getUsedObjects(transaction);\n\n\t\tconst execute = () => {\n\t\t\tthis.#executeQueue.runTask(() => {\n\t\t\t\tconst promise = this.#execute(transaction, usedObjects, options, additionalSignatures);\n\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t});\n\t\t};\n\n\t\tconst conflicts = new Set<string>();\n\n\t\tusedObjects.forEach((objectId) => {\n\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\tif (queue) {\n\t\t\t\tconflicts.add(objectId);\n\t\t\t\tthis.#objectIdQueues.get(objectId)!.push(() => {\n\t\t\t\t\tconflicts.delete(objectId);\n\t\t\t\t\tif (conflicts.size === 0) {\n\t\t\t\t\t\texecute();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.#objectIdQueues.set(objectId, []);\n\t\t\t}\n\t\t});\n\n\t\tif (conflicts.size === 0) {\n\t\t\texecute();\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tasync #getUsedObjects(transaction: Transaction) {\n\t\tconst usedObjects = new Set<string>();\n\t\tlet serialized = false;\n\n\t\ttransaction.addSerializationPlugin(async (blockData, _options, next) => {\n\t\t\tawait next();\n\n\t\t\tif (serialized) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tserialized = true;\n\n\t\t\tblockData.inputs.forEach((input) => {\n\t\t\t\tif (input.Object?.ImmOrOwnedObject?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t\t\t} else if (input.Object?.Receiving?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.Receiving.objectId);\n\t\t\t\t} else if (\n\t\t\t\t\tinput.UnresolvedObject?.objectId &&\n\t\t\t\t\t!input.UnresolvedObject.initialSharedVersion\n\t\t\t\t) {\n\t\t\t\t\tusedObjects.add(input.UnresolvedObject.objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tawait transaction.prepareForSerialization({ client: this.#client });\n\n\t\treturn usedObjects;\n\t}\n\n\tasync #execute(\n\t\ttransaction: Transaction,\n\t\tusedObjects: Set<string>,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\tlet gasCoin!: CoinWithBalance;\n\t\ttry {\n\t\t\ttransaction.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\t\tawait this.#buildQueue.runTask(async () => {\n\t\t\t\tconst data = transaction.getData();\n\n\t\t\t\tif (!data.gasData.price) {\n\t\t\t\t\ttransaction.setGasPrice(await this.#getGasPrice());\n\t\t\t\t}\n\n\t\t\t\ttransaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n\t\t\t\tawait this.#updateCache();\n\t\t\t\tgasCoin = await this.#getGasCoin();\n\t\t\t\tthis.#pendingTransactions++;\n\t\t\t\ttransaction.setGasPayment([\n\t\t\t\t\t{\n\t\t\t\t\t\tobjectId: gasCoin.id,\n\t\t\t\t\t\tversion: gasCoin.version,\n\t\t\t\t\t\tdigest: gasCoin.digest,\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\t// Resolve cached references\n\t\t\t\tawait this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n\t\t\t});\n\n\t\t\tconst bytes = await transaction.build({ client: this.#client });\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\n\t\t\tconst results = await this.#cache.executeTransaction({\n\t\t\t\ttransaction: bytes,\n\t\t\t\tsignature: [signature, ...additionalSignatures],\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tshowEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\tconst effects = bcs.TransactionEffects.parse(effectsBytes);\n\n\t\t\tconst gasResult = getGasCoinFromEffects(effects);\n\t\t\tconst gasUsed = effects.V2?.gasUsed;\n\n\t\t\tif (gasCoin && gasUsed && gasResult.owner === this.#signer.toSuiAddress()) {\n\t\t\t\tconst totalUsed =\n\t\t\t\t\tBigInt(gasUsed.computationCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) -\n\t\t\t\t\tBigInt(gasUsed.storageRebate);\n\n\t\t\t\tlet usesGasCoin = false;\n\t\t\t\tnew TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n\t\t\t\t\tif (arg.$kind === 'GasCoin') {\n\t\t\t\t\t\tusesGasCoin = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arg;\n\t\t\t\t});\n\n\t\t\t\tif (!usesGasCoin && gasCoin.balance >= this.#minimumCoinBalance) {\n\t\t\t\t\tthis.#coinPool.push({\n\t\t\t\t\t\tid: gasResult.ref.objectId,\n\t\t\t\t\t\tversion: gasResult.ref.version,\n\t\t\t\t\t\tdigest: gasResult.ref.digest,\n\t\t\t\t\t\tbalance: gasCoin.balance - totalUsed,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t\t}\n\t\t\t\t\tthis.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.#lastDigest = results.digest;\n\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (gasCoin) {\n\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t}\n\n\t\t\t\tthis.#sourceCoins.set(gasCoin.id, null);\n\t\t\t}\n\n\t\t\tawait this.#updateCache(async () => {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\tthis.#cache.cache.deleteObjects([...usedObjects]),\n\t\t\t\t\tthis.#waitForLastDigest(),\n\t\t\t\t]);\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tusedObjects.forEach((objectId) => {\n\t\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\t\tif (queue && queue.length > 0) {\n\t\t\t\t\tqueue.shift()!();\n\t\t\t\t} else if (queue) {\n\t\t\t\t\tthis.#objectIdQueues.delete(objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.#pendingTransactions--;\n\t\t}\n\t}\n\n\t/** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n\tasync #updateCache(fn?: () => Promise<void>) {\n\t\tif (this.#cacheLock) {\n\t\t\tawait this.#cacheLock;\n\t\t}\n\n\t\tthis.#cacheLock =\n\t\t\tfn?.().then(\n\t\t\t\t() => {\n\t\t\t\t\tthis.#cacheLock = null;\n\t\t\t\t},\n\t\t\t\t() => {},\n\t\t\t) ?? null;\n\t}\n\n\tasync #waitForLastDigest() {\n\t\tconst digest = this.#lastDigest;\n\t\tif (digest) {\n\t\t\tthis.#lastDigest = null;\n\t\t\tawait this.#client.waitForTransaction({ digest });\n\t\t}\n\t}\n\n\tasync #getGasCoin() {\n\t\tif (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n\t\t\tawait this.#refillCoinPool();\n\t\t}\n\n\t\tif (this.#coinPool.length === 0) {\n\t\t\tthrow new Error('No coins available');\n\t\t}\n\n\t\tconst coin = this.#coinPool.shift()!;\n\t\treturn coin;\n\t}\n\n\tasync #getGasPrice(): Promise<bigint> {\n\t\tconst remaining = this.#gasPrice\n\t\t\t? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n\t\t\t: 0;\n\n\t\tif (remaining > 0) {\n\t\t\treturn this.#gasPrice!.price;\n\t\t}\n\n\t\tif (this.#gasPrice) {\n\t\t\tconst timeToNextEpoch = Math.max(\n\t\t\t\tthis.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n\t\t\t\t1_000,\n\t\t\t);\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n\t\t}\n\n\t\tconst state = await this.#client.getLatestSuiSystemState();\n\n\t\tthis.#gasPrice = {\n\t\t\tprice: BigInt(state.referenceGasPrice),\n\t\t\texpiration:\n\t\t\t\tNumber.parseInt(state.epochStartTimestampMs, 10) +\n\t\t\t\tNumber.parseInt(state.epochDurationMs, 10),\n\t\t};\n\n\t\treturn this.#getGasPrice();\n\t}\n\n\tasync #refillCoinPool() {\n\t\tconst batchSize = Math.min(\n\t\t\tthis.#coinBatchSize,\n\t\t\tthis.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n\t\t);\n\n\t\tif (batchSize === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst txb = new Transaction();\n\t\tconst address = this.#signer.toSuiAddress();\n\t\ttxb.setSender(address);\n\n\t\tif (this.#sourceCoins) {\n\t\t\tconst refs = [];\n\t\t\tconst ids = [];\n\t\t\tfor (const [id, ref] of this.#sourceCoins) {\n\t\t\t\tif (ref) {\n\t\t\t\t\trefs.push(ref);\n\t\t\t\t} else {\n\t\t\t\t\tids.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ids.length > 0) {\n\t\t\t\tconst coins = await this.#client.multiGetObjects({\n\t\t\t\t\tids,\n\t\t\t\t});\n\t\t\t\trefs.push(\n\t\t\t\t\t...coins\n\t\t\t\t\t\t.filter((coin): coin is typeof coin & { data: object } => coin.data !== null)\n\t\t\t\t\t\t.map(({ data }) => ({\n\t\t\t\t\t\t\tobjectId: data.objectId,\n\t\t\t\t\t\t\tversion: data.version,\n\t\t\t\t\t\t\tdigest: data.digest,\n\t\t\t\t\t\t})),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttxb.setGasPayment(refs);\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n\t\tconst results = txb.splitCoins(txb.gas, amounts);\n\t\tconst coinResults = [];\n\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\tcoinResults.push(results[i]);\n\t\t}\n\t\ttxb.transferObjects(coinResults, address);\n\n\t\tawait this.waitForLastTransaction();\n\n\t\tconst result = await this.#client.signAndExecuteTransaction({\n\t\t\ttransaction: txb,\n\t\t\tsigner: this.#signer,\n\t\t\toptions: {\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n\t\teffects.V2?.changedObjects.forEach(([id, { outputState }], i) => {\n\t\t\tif (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.#coinPool.push({\n\t\t\t\tid,\n\t\t\t\tversion: effects.V2!.lamportVersion,\n\t\t\t\tdigest: outputState.ObjectWrite[0],\n\t\t\t\tbalance: BigInt(this.#initialCoinBalance),\n\t\t\t});\n\t\t});\n\n\t\tif (!this.#sourceCoins) {\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst gasObject = getGasCoinFromEffects(effects).ref;\n\t\tthis.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n\t\tawait this.#client.waitForTransaction({ digest: result.digest });\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, SuiClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/sui-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport { getClient } from '../resolve.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { Transaction, TransactionResult } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst SUI_TYPE = normalizeStructTag('0x2::sui::SUI');\n\nexport function coinWithBalance({\n\ttype = SUI_TYPE,\n\tbalance,\n\tuseGasCoin = true,\n}: {\n\tbalance: bigint | number;\n\ttype?: string;\n\tuseGasCoin?: boolean;\n}): (tx: Transaction) => TransactionResult {\n\tlet coinResult: TransactionResult | null = null;\n\n\treturn (tx: Transaction) => {\n\t\tif (coinResult) {\n\t\t\treturn coinResult;\n\t\t}\n\n\t\ttx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n\t\tconst coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n\t\tcoinResult = tx.add(\n\t\t\tCommands.Intent({\n\t\t\t\tname: COIN_WITH_BALANCE,\n\t\t\t\tinputs: {},\n\t\t\t\tdata: {\n\t\t\t\t\ttype: coinType === SUI_TYPE && useGasCoin ? 'gas' : coinType,\n\t\t\t\t\tbalance: BigInt(balance),\n\t\t\t\t} satisfies InferInput<typeof CoinWithBalanceData>,\n\t\t\t}),\n\t\t);\n\n\t\treturn coinResult;\n\t};\n}\n\nconst CoinWithBalanceData = object({\n\ttype: string(),\n\tbalance: bigint(),\n});\n\nasync function resolveCoinBalance(\n\ttransactionData: TransactionDataBuilder,\n\tbuildOptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tconst coinTypes = new Set<string>();\n\tconst totalByType = new Map<string, bigint>();\n\n\tif (!transactionData.sender) {\n\t\tthrow new Error('Sender must be set to resolve CoinWithBalance');\n\t}\n\n\tfor (const command of transactionData.commands) {\n\t\tif (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n\t\t\tconst { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n\t\t\tif (type !== 'gas' && balance > 0n) {\n\t\t\t\tcoinTypes.add(type);\n\t\t\t}\n\n\t\t\ttotalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n\t\t}\n\t}\n\tconst usedIds = new Set<string>();\n\n\tfor (const input of transactionData.inputs) {\n\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\tusedIds.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\t\tif (input.UnresolvedObject?.objectId) {\n\t\t\tusedIds.add(input.UnresolvedObject.objectId);\n\t\t}\n\t}\n\n\tconst coinsByType = new Map<string, CoinStruct[]>();\n\tconst client = getSuiClient(buildOptions);\n\tawait Promise.all(\n\t\t[...coinTypes].map(async (coinType) => {\n\t\t\tcoinsByType.set(\n\t\t\t\tcoinType,\n\t\t\t\tawait getCoinsOfType({\n\t\t\t\t\tcoinType,\n\t\t\t\t\tbalance: totalByType.get(coinType)!,\n\t\t\t\t\tclient,\n\t\t\t\t\towner: transactionData.sender!,\n\t\t\t\t\tusedIds,\n\t\t\t\t}),\n\t\t\t);\n\t\t}),\n\t);\n\n\tconst mergedCoins = new Map<string, Argument>();\n\n\tmergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n\tfor (const [index, transaction] of transactionData.commands.entries()) {\n\t\tif (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { type, balance } = transaction.$Intent.data as {\n\t\t\ttype: string;\n\t\t\tbalance: bigint;\n\t\t};\n\n\t\tif (balance === 0n && type !== 'gas') {\n\t\t\ttransactionData.replaceCommand(\n\t\t\t\tindex,\n\t\t\t\tCommands.MoveCall({ target: '0x2::coin::zero', typeArguments: [type] }),\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst commands = [];\n\n\t\tif (!mergedCoins.has(type)) {\n\t\t\tconst [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n\t\t\t\ttransactionData.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\tInputs.ObjectRef({\n\t\t\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\t\tversion: coin.version,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tif (rest.length > 0) {\n\t\t\t\tcommands.push(Commands.MergeCoins(first, rest));\n\t\t\t}\n\n\t\t\tmergedCoins.set(type, first);\n\t\t}\n\n\t\tcommands.push(\n\t\t\tCommands.SplitCoins(mergedCoins.get(type)!, [\n\t\t\t\ttransactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n\t\t\t]),\n\t\t);\n\n\t\ttransactionData.replaceCommand(index, commands);\n\n\t\ttransactionData.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Result' && arg.Result === index) {\n\t\t\t\treturn {\n\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\tNestedResult: [index + commands.length - 1, 0],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treturn next();\n}\n\nasync function getCoinsOfType({\n\tcoinType,\n\tbalance,\n\tclient,\n\towner,\n\tusedIds,\n}: {\n\tcoinType: string;\n\tbalance: bigint;\n\tclient: SuiClient;\n\towner: string;\n\tusedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n\tlet remainingBalance = balance;\n\tconst coins: CoinStruct[] = [];\n\n\treturn loadMoreCoins();\n\n\tasync function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n\t\tconst { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n\n\t\tconst sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n\t\tfor (const coin of sortedCoins) {\n\t\t\tif (usedIds.has(coin.coinObjectId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst coinBalance = BigInt(coin.balance);\n\n\t\t\tcoins.push(coin);\n\t\t\tremainingBalance -= coinBalance;\n\n\t\t\tif (remainingBalance <= 0) {\n\t\t\t\treturn coins;\n\t\t\t}\n\t\t}\n\n\t\tif (hasNextPage) {\n\t\t\treturn loadMoreCoins(nextCursor);\n\t\t}\n\n\t\tthrow new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n\t}\n}\n\nexport function getSuiClient(options: BuildTransactionOptions): SuiClient {\n\tconst client = getClient(options) as SuiClient;\n\tif (!client.jsonRpc) {\n\t\tthrow new Error(`CoinWithBalance intent currently only works with SuiClient`);\n\t}\n\n\treturn client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\nimport type { Inputs } from './Inputs.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport type { Transaction, TransactionObjectArgument } from './Transaction.js';\n\nexport const Arguments = {\n\tpure: createPure<(tx: Transaction) => Argument>((value) => (tx) => tx.pure(value)) as ReturnType<\n\t\ttypeof createPure<(tx: Transaction) => Argument>\n\t>,\n\tobject: createObjectMethods<TransactionObjectArgument>((value) => (tx) => tx.object(value)),\n\tsharedObjectRef:\n\t\t(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.sharedObjectRef(...args),\n\tobjectRef:\n\t\t(...args: Parameters<(typeof Inputs)['ObjectRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.objectRef(...args),\n\treceivingRef:\n\t\t(...args: Parameters<(typeof Inputs)['ReceivingRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.receivingRef(...args),\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IdentifierString } from '@wallet-standard/core';\n\n/** Sui Devnet */\nexport const SUI_DEVNET_CHAIN = 'sui:devnet';\n\n/** Sui Testnet */\nexport const SUI_TESTNET_CHAIN = 'sui:testnet';\n\n/** Sui Localnet */\nexport const SUI_LOCALNET_CHAIN = 'sui:localnet';\n\n/** Sui Mainnet */\nexport const SUI_MAINNET_CHAIN = 'sui:mainnet';\n\nexport const SUI_CHAINS = [\n\tSUI_DEVNET_CHAIN,\n\tSUI_TESTNET_CHAIN,\n\tSUI_LOCALNET_CHAIN,\n\tSUI_MAINNET_CHAIN,\n] as const;\n\nexport type SuiChain = (typeof SUI_CHAINS)[number];\n\n/**\n * Utility that returns whether or not a chain identifier is a valid Sui chain.\n * @param chain a chain identifier in the form of `${string}:{$string}`\n */\nexport function isSuiChain(chain: IdentifierString): chain is SuiChain {\n\treturn SUI_CHAINS.includes(chain as SuiChain);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport * as v from 'valibot';\n\nexport type JsonData = string | number | boolean | null | { [key: string]: JsonData } | JsonData[];\n\nconst JsonSchema: v.GenericSchema<JsonData> = v.lazy(() =>\n\tv.union([\n\t\tv.string(),\n\t\tv.number(),\n\t\tv.boolean(),\n\t\tv.null(),\n\t\tv.record(v.string(), JsonSchema),\n\t\tv.array(JsonSchema),\n\t]),\n);\n\nexport const RequestData = v.variant('type', [\n\tv.object({\n\t\ttype: v.literal('connect'),\n\t}),\n\tv.object({\n\t\ttype: v.literal('sign-transaction'),\n\t\ttransaction: v.string('`transaction` is required'),\n\t\taddress: v.string('`address` is required'),\n\t\tchain: v.string('`chain` is required'),\n\t\tsession: v.string('`session` is required'),\n\t}),\n\tv.object({\n\t\ttype: v.literal('sign-and-execute-transaction'),\n\t\ttransaction: v.string('`transaction` is required'),\n\t\taddress: v.string('`address` is required'),\n\t\tchain: v.string('`chain` is required'),\n\t\tsession: v.string('`session` is required'),\n\t}),\n\tv.object({\n\t\ttype: v.literal('sign-personal-message'),\n\t\tchain: v.string('`chain` is required'),\n\t\tmessage: v.string('`message` is required'),\n\t\taddress: v.string('`address` is required'),\n\t\tsession: v.string('`session` is required'),\n\t}),\n]);\nexport type RequestDataType = v.InferOutput<typeof RequestData>;\n\nexport const Request = v.object({\n\tversion: v.literal('1'),\n\trequestId: v.pipe(v.string('`requestId` is required'), v.uuid()),\n\tappUrl: v.pipe(v.string(), v.url('`appUrl` must be a valid URL')),\n\tappName: v.string('`appName` is required'),\n\tpayload: RequestData,\n\tmetadata: v.optional(v.record(v.string(), JsonSchema)),\n\textraRequestOptions: v.optional(v.record(v.string(), JsonSchema)),\n});\nexport type RequestType = v.InferOutput<typeof Request>;\n", "import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n", "export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\n", "export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n", "export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n", "function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default (input) => {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n};\n", "export const unprotected = Symbol();\n", "const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n", "import { JOSEError, JWKSNoMatchingKey, JWKSTimeout } from '../util/errors.js';\nimport { createLocalJWKSet } from './local.js';\nimport isObject from '../lib/is_object.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'jose';\n    const VERSION = 'v6.0.12';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nexport const customFetch = Symbol();\nasync function fetchJwks(url, headers, signal, fetchImpl = fetch) {\n    const response = await fetchImpl(url, {\n        method: 'GET',\n        signal,\n        redirect: 'manual',\n        headers,\n    }).catch((err) => {\n        if (err.name === 'TimeoutError') {\n            throw new JWKSTimeout();\n        }\n        throw err;\n    });\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n}\nexport const jwksCache = Symbol();\nfunction isFreshJwksCache(input, cacheMaxAge) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || Date.now() - input.uat >= cacheMaxAge) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isObject)) {\n        return false;\n    }\n    return true;\n}\nclass RemoteJWKSet {\n    #url;\n    #timeoutDuration;\n    #cooldownDuration;\n    #cacheMaxAge;\n    #jwksTimestamp;\n    #pendingFetch;\n    #headers;\n    #customFetch;\n    #local;\n    #cache;\n    constructor(url, options) {\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this.#url = new URL(url.href);\n        this.#timeoutDuration =\n            typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;\n        this.#cooldownDuration =\n            typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;\n        this.#cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;\n        this.#headers = new Headers(options?.headers);\n        if (USER_AGENT && !this.#headers.has('User-Agent')) {\n            this.#headers.set('User-Agent', USER_AGENT);\n        }\n        if (!this.#headers.has('accept')) {\n            this.#headers.set('accept', 'application/json');\n            this.#headers.append('accept', 'application/jwk-set+json');\n        }\n        this.#customFetch = options?.[customFetch];\n        if (options?.[jwksCache] !== undefined) {\n            this.#cache = options?.[jwksCache];\n            if (isFreshJwksCache(options?.[jwksCache], this.#cacheMaxAge)) {\n                this.#jwksTimestamp = this.#cache.uat;\n                this.#local = createLocalJWKSet(this.#cache.jwks);\n            }\n        }\n    }\n    pendingFetch() {\n        return !!this.#pendingFetch;\n    }\n    coolingDown() {\n        return typeof this.#jwksTimestamp === 'number'\n            ? Date.now() < this.#jwksTimestamp + this.#cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this.#jwksTimestamp === 'number'\n            ? Date.now() < this.#jwksTimestamp + this.#cacheMaxAge\n            : false;\n    }\n    jwks() {\n        return this.#local?.jwks();\n    }\n    async getKey(protectedHeader, token) {\n        if (!this.#local || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await this.#local(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return this.#local(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this.#pendingFetch && isCloudflareWorkers()) {\n            this.#pendingFetch = undefined;\n        }\n        this.#pendingFetch ||= fetchJwks(this.#url.href, this.#headers, AbortSignal.timeout(this.#timeoutDuration), this.#customFetch)\n            .then((json) => {\n            this.#local = createLocalJWKSet(json);\n            if (this.#cache) {\n                this.#cache.uat = Date.now();\n                this.#cache.jwks = json;\n            }\n            this.#jwksTimestamp = Date.now();\n            this.#pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this.#pendingFetch = undefined;\n            throw err;\n        });\n        await this.#pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(remoteJWKSet, {\n        coolingDown: {\n            get: () => set.coolingDown(),\n            enumerable: true,\n            configurable: false,\n        },\n        fresh: {\n            get: () => set.fresh(),\n            enumerable: true,\n            configurable: false,\n        },\n        reload: {\n            value: () => set.reload(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n        reloading: {\n            get: () => set.pendingFetch(),\n            enumerable: true,\n            configurable: false,\n        },\n        jwks: {\n            value: () => set.jwks(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return remoteJWKSet;\n}\n", "import { decode as b64u } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = b64u(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport * as v from 'valibot';\nimport { SignJWT, decodeJwt, jwtVerify } from 'jose';\n\nconst AccountSchema = v.object({\n\taddress: v.string(),\n\tpublicKey: v.string(),\n});\n\nconst JwtSessionSchema = v.object({\n\texp: v.number(), // Expiration Time\n\tiat: v.number(), // Issued At\n\tiss: v.string(), // Issuer\n\taud: v.string(), // Audience (the dapp origin)\n\tpayload: v.object({\n\t\taccounts: v.array(AccountSchema),\n\t}),\n});\n\ntype JwtSessionPayload = v.InferOutput<typeof JwtSessionSchema>;\n\nexport async function createJwtSession(\n\tpayload: JwtSessionPayload['payload'],\n\toptions: {\n\t\tsecretKey: Parameters<SignJWT['sign']>[0];\n\t\texpirationTime: Parameters<SignJWT['setExpirationTime']>[0];\n\t\tissuer: Parameters<SignJWT['setIssuer']>[0];\n\t\taudience: Parameters<SignJWT['setAudience']>[0];\n\t},\n) {\n\tconst token = await new SignJWT({ payload })\n\t\t.setProtectedHeader({ alg: 'HS256' })\n\t\t.setExpirationTime(options.expirationTime)\n\t\t.setIssuedAt()\n\t\t.setIssuer(options.issuer)\n\t\t.setAudience(options.audience)\n\t\t.sign(options.secretKey);\n\n\treturn token;\n}\n\nexport function decodeJwtSession(jwt: string) {\n\tconst decodedJwt = decodeJwt(jwt);\n\n\treturn v.parse(JwtSessionSchema, decodedJwt);\n}\n\nexport async function verifyJwtSession(jwt: string, secretKey: CryptoKey | Uint8Array) {\n\tconst verified = await jwtVerify(jwt, secretKey, { algorithms: ['HS256'] });\n\n\treturn v.parse(JwtSessionSchema, verified.payload);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\nimport type { RequestType } from './requests.js';\nimport { Request } from './requests.js';\nimport type { ResponsePayloadType, ResponseType } from './responses.js';\nimport { verifyJwtSession } from '../jwt-session/index.js';\n\nexport class WalletPostMessageChannel {\n\t#request: RequestType;\n\t#isSendCalled: boolean = false;\n\n\tconstructor(request: RequestType) {\n\t\tif (typeof window === 'undefined' || !window.opener) {\n\t\t\tthrow new Error(\n\t\t\t\t'This functionality requires a window opened through `window.open`. `window.opener` is not available.',\n\t\t\t);\n\t\t}\n\n\t\tthis.#request = request;\n\t}\n\n\tstatic fromPayload(payload: RequestType) {\n\t\tconst request = parse(Request, payload);\n\n\t\treturn new WalletPostMessageChannel(request);\n\t}\n\n\tstatic fromUrlHash(hash: string = window.location.hash.slice(1)) {\n\t\tconst decoded = atob(decodeURIComponent(hash));\n\t\tconst request = parse(Request, JSON.parse(decoded));\n\n\t\treturn new WalletPostMessageChannel(request);\n\t}\n\n\tgetRequestData() {\n\t\treturn this.#request;\n\t}\n\n\tasync verifyJwtSession(secretKey: Parameters<typeof verifyJwtSession>[1]) {\n\t\tif (!('session' in this.#request.payload)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst session = await verifyJwtSession(this.#request.payload.session, secretKey);\n\n\t\tif (session.aud !== new URL(this.#request.appUrl).origin) {\n\t\t\tthrow new Error('App and session origin mismatch');\n\t\t}\n\n\t\tconst requestAddress = this.#request.payload.address;\n\t\tconst addressInSession = session.payload.accounts.find(\n\t\t\t(account) => account.address === requestAddress,\n\t\t);\n\n\t\tif (!addressInSession) {\n\t\t\tthrow new Error('Requested account not found in session');\n\t\t}\n\n\t\treturn session;\n\t}\n\n\tsendMessage(payload: ResponsePayloadType) {\n\t\tif (this.#isSendCalled) {\n\t\t\tthrow new Error('sendMessage() can only be called once');\n\t\t}\n\n\t\tthis.#isSendCalled = true;\n\n\t\twindow.opener.postMessage(\n\t\t\t{\n\t\t\t\tid: this.#request.requestId,\n\t\t\t\tsource: 'web-wallet-channel',\n\t\t\t\tpayload,\n\t\t\t\tversion: this.#request.version,\n\t\t\t} satisfies ResponseType,\n\t\t\tthis.#request.appUrl,\n\t\t);\n\t}\n\n\tclose(payload?: ResponsePayloadType) {\n\t\tif (payload) {\n\t\t\tthis.sendMessage(payload);\n\t\t}\n\t\twindow.close();\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport * as v from 'valibot';\n\nexport const ResponseData = v.variant('type', [\n\tv.object({\n\t\ttype: v.literal('connect'),\n\t\tsession: v.string('`session` is required'),\n\t}),\n\tv.object({\n\t\ttype: v.literal('sign-transaction'),\n\t\tbytes: v.string(),\n\t\tsignature: v.string(),\n\t}),\n\tv.object({\n\t\ttype: v.literal('sign-and-execute-transaction'),\n\t\tbytes: v.string(),\n\t\tsignature: v.string(),\n\t\tdigest: v.string(),\n\t\teffects: v.string(),\n\t}),\n\tv.object({\n\t\ttype: v.literal('sign-personal-message'),\n\t\tbytes: v.string(),\n\t\tsignature: v.string(),\n\t}),\n]);\nexport type ResponseDataType = v.InferOutput<typeof ResponseData>;\n\nexport const ResponsePayload = v.variant('type', [\n\tv.object({\n\t\ttype: v.literal('reject'),\n\t\treason: v.optional(v.string('`reason` must be a string')),\n\t}),\n\tv.object({\n\t\ttype: v.literal('resolve'),\n\t\tdata: ResponseData,\n\t}),\n]);\nexport type ResponsePayloadType = v.InferOutput<typeof ResponsePayload>;\n\nexport const Response = v.object({\n\tid: v.pipe(v.string(), v.uuid()),\n\tsource: v.literal('web-wallet-channel'),\n\tpayload: ResponsePayload,\n\tversion: v.literal('1'),\n});\nexport type ResponseType = v.InferOutput<typeof Response>;\n\nexport type ResponseTypes = {\n\t[P in ResponseDataType as P['type']]: P;\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function getClientMetadata() {\n\treturn {\n\t\tversion: '1',\n\t\toriginUrl: window.location.href,\n\t\tuserAgent: navigator.userAgent,\n\t\tscreenResolution: `${window.screen.width}x${window.screen.height}`,\n\t\tlanguage: navigator.language,\n\t\tplatform: navigator.platform,\n\t\ttimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n\t\ttimestamp: Date.now(),\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { safeParse } from 'valibot';\nimport type { JsonData, RequestDataType, RequestType } from './requests.js';\nimport type { ResponseTypes } from './responses.js';\nimport { Response } from './responses.js';\nimport { promiseWithResolvers } from '@mysten/utils';\nimport { getClientMetadata } from './utils.js';\n\ntype DappPostMessageChannelOptions = {\n\tappName: string;\n\thostOrigin: string;\n\thostPathname?: string;\n\textraRequestOptions?: Record<string, JsonData>;\n};\n\nexport class DappPostMessageChannel {\n\t#popup: Window;\n\t#version = '1' as const;\n\t#id: string;\n\t#hostOrigin: string;\n\t#hostPathname: string;\n\t#appName: string;\n\t#extraRequestOptions?: Record<string, JsonData>;\n\t#promise: Promise<unknown>;\n\t#resolve: (data: unknown) => void;\n\t#reject: (error: Error) => void;\n\t#interval: ReturnType<typeof setInterval> | null = null;\n\t#isSendCalled: boolean = false;\n\n\tconstructor({\n\t\tappName,\n\t\thostOrigin,\n\t\thostPathname = 'dapp-request',\n\t\textraRequestOptions,\n\t}: DappPostMessageChannelOptions) {\n\t\tconst popup = window.open('about:blank', '_blank');\n\n\t\tif (!popup) {\n\t\t\tthrow new Error('Failed to open new window');\n\t\t}\n\n\t\tthis.#id = crypto.randomUUID();\n\t\tthis.#popup = popup;\n\t\tthis.#hostOrigin = hostOrigin;\n\t\tthis.#hostPathname = hostPathname;\n\t\tthis.#appName = appName;\n\n\t\tconst { promise, resolve, reject } = promiseWithResolvers();\n\n\t\tthis.#promise = promise;\n\t\tthis.#resolve = resolve;\n\t\tthis.#reject = reject;\n\t\tthis.#extraRequestOptions = extraRequestOptions;\n\t\tthis.#interval = setInterval(() => {\n\t\t\ttry {\n\t\t\t\tif (this.#popup.closed) {\n\t\t\t\t\tthis.#cleanup();\n\t\t\t\t\treject(new Error('User closed the wallet window'));\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// This can error during the login flow, but that's fine.\n\t\t\t}\n\t\t}, 1000);\n\t}\n\n\tsend<T extends RequestDataType['type']>({\n\t\ttype,\n\t\t...data\n\t}: {\n\t\ttype: T;\n\t} & Extract<RequestDataType, { type: T }>): Promise<ResponseTypes[T]> {\n\t\tif (this.#popup.closed) {\n\t\t\tthrow new Error('User closed the wallet window');\n\t\t}\n\n\t\tif (this.#isSendCalled) {\n\t\t\tthrow new Error('send() can only be called once');\n\t\t}\n\n\t\tthis.#isSendCalled = true;\n\n\t\twindow.addEventListener('message', this.#listener);\n\n\t\tconst requestData = {\n\t\t\tversion: this.#version,\n\t\t\trequestId: this.#id,\n\t\t\tappUrl: window.location.href.split('#')[0],\n\t\t\tappName: this.#appName,\n\t\t\tpayload: {\n\t\t\t\ttype,\n\t\t\t\t...data,\n\t\t\t} as RequestDataType,\n\t\t\tmetadata: getClientMetadata(),\n\t\t\textraRequestOptions: this.#extraRequestOptions,\n\t\t} satisfies RequestType;\n\t\tconst encodedRequestData = encodeURIComponent(btoa(JSON.stringify(requestData)));\n\n\t\tthis.#popup.location.assign(`${this.#hostOrigin}/${this.#hostPathname}#${encodedRequestData}`);\n\n\t\treturn this.#promise as Promise<ResponseTypes[T]>;\n\t}\n\n\tclose() {\n\t\tthis.#cleanup();\n\t\tthis.#popup.close();\n\t}\n\n\t#listener = (event: MessageEvent) => {\n\t\tif (event.origin !== this.#hostOrigin) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { success, output } = safeParse(Response, event.data);\n\n\t\tif (!success || output.id !== this.#id) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#cleanup();\n\n\t\tif (output.payload.type === 'reject') {\n\t\t\tthis.#reject(new Error('User rejected the request'));\n\t\t} else if (output.payload.type === 'resolve') {\n\t\t\tthis.#resolve(output.payload.data);\n\t\t}\n\t};\n\n\t#cleanup() {\n\t\tif (this.#interval) {\n\t\t\tclearInterval(this.#interval);\n\t\t\tthis.#interval = null;\n\t\t}\n\t\twindow.removeEventListener('message', this.#listener);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/sui/utils';\nimport type {\n\tStandardConnectFeature,\n\tStandardConnectMethod,\n\tStandardDisconnectFeature,\n\tStandardDisconnectMethod,\n\tStandardEventsFeature,\n\tStandardEventsListeners,\n\tStandardEventsOnMethod,\n\tSuiChain,\n\tSuiSignAndExecuteTransactionFeature,\n\tSuiSignAndExecuteTransactionMethod,\n\tSuiSignPersonalMessageFeature,\n\tSuiSignPersonalMessageMethod,\n\tSuiSignTransactionBlockFeature,\n\tSuiSignTransactionBlockMethod,\n\tSuiSignTransactionFeature,\n\tSuiSignTransactionMethod,\n\tWallet,\n\tWalletIcon,\n} from '@mysten/wallet-standard';\nimport { getWallets, ReadonlyWalletAccount, SUI_CHAINS } from '@mysten/wallet-standard';\nimport type { Emitter } from 'mitt';\nimport mitt from 'mitt';\nimport type { InferOutput } from 'valibot';\nimport { boolean, object, parse, string } from 'valibot';\nimport { DappPostMessageChannel, decodeJwtSession } from '@mysten/window-wallet-core';\n\nconst DEFAULT_SLUSH_ORIGIN = 'https://my.slush.app';\n\ntype WalletEventsMap = {\n\t[E in keyof StandardEventsListeners]: Parameters<StandardEventsListeners[E]>[0];\n};\n\nconst SLUSH_SESSION_KEY = 'slush:session';\n\nexport const SLUSH_WALLET_NAME = 'Slush' as const;\n\nconst SUI_WALLET_EXTENSION_ID = 'com.mystenlabs.suiwallet' as const;\nconst METADATA_API_URL = 'https://api.slush.app/api/wallet/metadata';\n\nconst FALLBACK_METADATA = {\n\tid: 'com.mystenlabs.suiwallet.web',\n\twalletName: 'Slush',\n\tdescription: 'Trade and earn on Sui.',\n\ticon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIHZpZXdCb3g9IjAgMCA1MCA1MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjUwIiBoZWlnaHQ9IjUwIiBmaWxsPSIjNENBMkZGIi8+CjxwYXRoIGQ9Ik0xMi4zNDczIDM0LjcyNTRDMTMuNTU1MyAzOS4yMzM2IDE4LjA2NzMgNDMuMzE0OCAyNy40MDI1IDQwLjgxMzRDMzYuMzA5NyAzOC40MjY3IDQxLjg5MjEgMzEuMDk5MyA0MC40NDQ2IDI1LjY5NzJDMzkuOTQ0NyAyMy44MzE3IDM4LjQzOTEgMjIuNTY4OSAzNi4xMTc4IDIyLjc3NDRMMTUuMzYxNSAyNC41MDM4QzE0LjA1NDQgMjQuNjA0MSAxMy40NTUgMjQuMzg5OCAxMy4xMDkyIDIzLjU2NjFDMTIuNzczOCAyMi43ODEyIDEyLjk2NDkgMjEuOTM4NSAxNC41NDM3IDIxLjE0MDZMMzAuMzM5NiAxMy4wMzQyQzMxLjU1MDMgMTIuNDE4MiAzMi4zNTY3IDEyLjE2MDUgMzMuMDkzNiAxMi40MjEzQzMzLjU1NTUgMTIuNTg5MSAzMy44NTk2IDEzLjI1NzQgMzMuNTgwMyAxNC4wODJMMzIuNTU2MSAxNy4xMDU2QzMxLjI5OTIgMjAuODE2NCAzMy45ODk5IDIxLjY3ODQgMzUuNTA2OCAyMS4yNzE5QzM3LjgwMTcgMjAuNjU3IDM4LjM0MTYgMTguNDcxMiAzNy42MDIzIDE1LjcxMTlDMzUuNzI3OCA4LjcxNjI5IDI4LjMwNTkgNy42MjI1NCAyMS41NzY4IDkuNDI1NTlDMTQuNzMxMSAxMS4yNTk5IDguNzk2ODEgMTYuODA3MiAxMC42MDg4IDIzLjU2OTZDMTEuMDM1OCAyNS4xNjMgMTIuNTAyNSAyNi40MzYyIDE0LjIwMTQgMjYuMzk3NUwxNi43OTUgMjYuMzkxMkMxNy4zMjg0IDI2LjM3ODggMTcuMTM2MyAyNi40MjI3IDE4LjE2NTMgMjYuMzM3NEMxOS4xOTQ0IDI2LjI1MjIgMjEuOTQyNSAyNS45MTQgMjEuOTQyNSAyNS45MTRMMzUuNDI3NSAyNC4zODhMMzUuNzc1IDI0LjMzNzVDMzYuNTYzNyAyNC4yMDMgMzcuMTU5NyAyNC40MDc5IDM3LjY2MzYgMjUuMjc2QzM4LjQxNzcgMjYuNTc1IDM3LjI2NzIgMjcuNTU0NiAzNS44ODk5IDI4LjcyNzJDMzUuODUzIDI4Ljc1ODYgMzUuODE2IDI4Ljc5MDEgMzUuNzc4OSAyOC44MjE4TDIzLjkyNSAzOS4wMzc3QzIxLjg5MzMgNDAuNzkwMSAyMC40NjYgNDAuMTMxMSAxOS45NjYyIDM4LjI2NTZMMTguMTk1OCAzMS42NTg3QzE3Ljc1ODUgMzAuMDI2NCAxNi4xNjQ2IDI4Ljc0NTYgMTQuMjk3NiAyOS4yNDU5QzExLjk2MzggMjkuODcxMiAxMS43NzQ2IDMyLjU4NzggMTIuMzQ3MyAzNC43MjU0WiIgZmlsbD0iIzA2MEQxNCIvPgo8L3N2Zz4K',\n\tenabled: true,\n};\n\nconst WalletMetadataSchema = object({\n\tid: string('Wallet ID is required'),\n\twalletName: string('Wallet name is required'),\n\ticon: string('Icon must be a valid wallet icon format'),\n\tenabled: boolean('Enabled is required'),\n});\n\nfunction setSessionToStorage(session: string) {\n\tlocalStorage.setItem(SLUSH_SESSION_KEY, session);\n}\n\nfunction getSessionFromStorage() {\n\tconst session = localStorage.getItem(SLUSH_SESSION_KEY);\n\n\tif (!session) {\n\t\tthrow new Error('No session found');\n\t}\n\n\treturn session;\n}\n\nconst walletAccountFeatures = [\n\t'sui:signTransaction',\n\t'sui:signAndExecuteTransaction',\n\t'sui:signPersonalMessage',\n\t'sui:signTransactionBlock',\n\t'sui:signAndExecuteTransactionBlock',\n] as const;\n\nfunction getAccountsFromSession(session: string) {\n\tconst { payload } = decodeJwtSession(session);\n\treturn payload.accounts.map((account) => {\n\t\treturn new ReadonlyWalletAccount({\n\t\t\taddress: account.address,\n\t\t\tchains: SUI_CHAINS,\n\t\t\tfeatures: walletAccountFeatures,\n\t\t\tpublicKey: fromBase64(account.publicKey),\n\t\t});\n\t});\n}\n\ntype WalletMetadata = InferOutput<typeof WalletMetadataSchema>;\nexport class SlushWallet implements Wallet {\n\t#id: string;\n\t#events: Emitter<WalletEventsMap>;\n\t#accounts: ReadonlyWalletAccount[];\n\t#origin: string;\n\t#walletName: string;\n\t#icon: WalletIcon;\n\t#name: string;\n\n\tget name() {\n\t\treturn this.#walletName;\n\t}\n\n\tget id() {\n\t\treturn this.#id;\n\t}\n\n\tget icon() {\n\t\treturn this.#icon;\n\t}\n\n\tget version() {\n\t\treturn '1.0.0' as const;\n\t}\n\n\tget chains() {\n\t\treturn SUI_CHAINS;\n\t}\n\n\tget accounts() {\n\t\treturn this.#accounts;\n\t}\n\n\tget features(): StandardConnectFeature &\n\t\tStandardDisconnectFeature &\n\t\tStandardEventsFeature &\n\t\tSuiSignTransactionBlockFeature &\n\t\tSuiSignTransactionFeature &\n\t\tSuiSignPersonalMessageFeature &\n\t\tSuiSignAndExecuteTransactionFeature {\n\t\treturn {\n\t\t\t'standard:connect': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tconnect: this.#connect,\n\t\t\t},\n\t\t\t'standard:disconnect': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tdisconnect: this.#disconnect,\n\t\t\t},\n\t\t\t'standard:events': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\ton: this.#on,\n\t\t\t},\n\t\t\t'sui:signTransactionBlock': {\n\t\t\t\tversion: '1.0.0',\n\t\t\t\tsignTransactionBlock: this.#signTransactionBlock,\n\t\t\t},\n\t\t\t'sui:signTransaction': {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignTransaction: this.#signTransaction,\n\t\t\t},\n\t\t\t'sui:signPersonalMessage': {\n\t\t\t\tversion: '1.1.0',\n\t\t\t\tsignPersonalMessage: this.#signPersonalMessage,\n\t\t\t},\n\t\t\t'sui:signAndExecuteTransaction': {\n\t\t\t\tversion: '2.0.0',\n\t\t\t\tsignAndExecuteTransaction: this.#signAndExecuteTransaction,\n\t\t\t},\n\t\t};\n\t}\n\n\tconstructor({\n\t\tname,\n\t\torigin,\n\t\tmetadata,\n\t}: {\n\t\tname: string;\n\t\torigin?: string;\n\t\tchain?: SuiChain;\n\t\tmetadata: WalletMetadata;\n\t}) {\n\t\tthis.#id = metadata.id;\n\t\tthis.#accounts = this.#getPreviouslyAuthorizedAccounts();\n\t\tthis.#events = mitt();\n\t\tthis.#origin = origin || DEFAULT_SLUSH_ORIGIN;\n\t\tthis.#name = name;\n\t\tthis.#walletName = metadata.walletName;\n\t\tthis.#icon = metadata.icon as WalletIcon;\n\t}\n\n\t#signTransactionBlock: SuiSignTransactionBlockMethod = async ({\n\t\ttransactionBlock,\n\t\taccount,\n\t\tchain,\n\t}) => {\n\t\tconst data = await transactionBlock.toJSON();\n\n\t\tconst popup = this.#getNewPopupChannel();\n\n\t\tconst response = await popup.send({\n\t\t\ttype: 'sign-transaction',\n\t\t\ttransaction: data,\n\t\t\taddress: account.address,\n\t\t\tchain,\n\t\t\tsession: getSessionFromStorage(),\n\t\t});\n\n\t\treturn {\n\t\t\ttransactionBlockBytes: response.bytes,\n\t\t\tsignature: response.signature,\n\t\t};\n\t};\n\n\t#signTransaction: SuiSignTransactionMethod = async ({ transaction, account, chain }) => {\n\t\tconst popup = this.#getNewPopupChannel();\n\n\t\tconst tx = await transaction.toJSON();\n\n\t\tconst response = await popup.send({\n\t\t\ttype: 'sign-transaction',\n\t\t\ttransaction: tx,\n\t\t\taddress: account.address,\n\t\t\tchain,\n\t\t\tsession: getSessionFromStorage(),\n\t\t});\n\n\t\treturn {\n\t\t\tbytes: response.bytes,\n\t\t\tsignature: response.signature,\n\t\t};\n\t};\n\n\t#signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = async ({\n\t\ttransaction,\n\t\taccount,\n\t\tchain,\n\t}) => {\n\t\tconst popup = this.#getNewPopupChannel();\n\n\t\tconst data = await transaction.toJSON();\n\n\t\tconst response = await popup.send({\n\t\t\ttype: 'sign-and-execute-transaction',\n\t\t\ttransaction: data,\n\t\t\taddress: account.address,\n\t\t\tchain,\n\t\t\tsession: getSessionFromStorage(),\n\t\t});\n\t\treturn {\n\t\t\tbytes: response.bytes,\n\t\t\tsignature: response.signature,\n\t\t\tdigest: response.digest,\n\t\t\teffects: response.effects,\n\t\t};\n\t};\n\n\t#signPersonalMessage: SuiSignPersonalMessageMethod = async ({ message, account, chain }) => {\n\t\tconst popup = this.#getNewPopupChannel();\n\n\t\tconst response = await popup.send({\n\t\t\ttype: 'sign-personal-message',\n\t\t\tmessage: toBase64(message),\n\t\t\taddress: account.address,\n\t\t\tchain: chain ?? account.chains[0],\n\t\t\tsession: getSessionFromStorage(),\n\t\t});\n\n\t\treturn {\n\t\t\tbytes: response.bytes,\n\t\t\tsignature: response.signature,\n\t\t};\n\t};\n\n\t#on: StandardEventsOnMethod = (event, listener) => {\n\t\tthis.#events.on(event, listener);\n\t\treturn () => this.#events.off(event, listener);\n\t};\n\n\t#setAccounts(accounts: ReadonlyWalletAccount[]) {\n\t\tthis.#accounts = accounts;\n\t\tthis.#events.emit('change', { accounts: this.accounts });\n\t}\n\n\t#connect: StandardConnectMethod = async (input) => {\n\t\tif (input?.silent) {\n\t\t\treturn { accounts: this.accounts };\n\t\t}\n\n\t\tconst popup = this.#getNewPopupChannel();\n\t\tconst response = await popup.send({\n\t\t\ttype: 'connect',\n\t\t});\n\n\t\tsetSessionToStorage(response.session);\n\t\tthis.#setAccounts(getAccountsFromSession(response.session));\n\n\t\treturn { accounts: this.accounts };\n\t};\n\n\t#getPreviouslyAuthorizedAccounts() {\n\t\ttry {\n\t\t\treturn getAccountsFromSession(getSessionFromStorage());\n\t\t} catch (error) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t#disconnect: StandardDisconnectMethod = async () => {\n\t\tlocalStorage.removeItem(SLUSH_SESSION_KEY);\n\t\tthis.#setAccounts([]);\n\t};\n\n\t#getNewPopupChannel() {\n\t\treturn new DappPostMessageChannel({\n\t\t\tappName: this.#name,\n\t\t\thostOrigin: this.#origin,\n\t\t});\n\t}\n\n\tupdateMetadata(metadata: WalletMetadata) {\n\t\tthis.#id = metadata.id;\n\t\tthis.#walletName = metadata.walletName;\n\t\tthis.#icon = metadata.icon as WalletIcon;\n\t}\n}\n\nasync function fetchMetadata(metadataApiUrl: string): Promise<WalletMetadata> {\n\tconst response = await fetch(metadataApiUrl);\n\tif (!response.ok) {\n\t\tthrow new Error('Failed to fetch wallet metadata');\n\t}\n\tconst data = await response.json();\n\treturn parse(WalletMetadataSchema, data);\n}\n\nexport function registerSlushWallet(\n\tname: string,\n\t{\n\t\torigin,\n\t\tmetadataApiUrl = METADATA_API_URL,\n\t}: {\n\t\torigin?: string;\n\t\tmetadataApiUrl?: string;\n\t} = {},\n) {\n\tconst wallets = getWallets();\n\n\tlet unregister: (() => void) | null = null;\n\n\t// listen for wallet registration\n\twallets.on('register', (wallet) => {\n\t\tif (wallet.id === SUI_WALLET_EXTENSION_ID) {\n\t\t\tunregister?.();\n\t\t}\n\t});\n\n\tconst extension = wallets.get().find((wallet) => wallet.id === SUI_WALLET_EXTENSION_ID);\n\tif (extension) {\n\t\treturn;\n\t}\n\n\tconst slushWalletInstance = new SlushWallet({\n\t\tname,\n\t\torigin,\n\t\tmetadata: FALLBACK_METADATA,\n\t});\n\tunregister = wallets.register(slushWalletInstance);\n\n\tfetchMetadata(metadataApiUrl)\n\t\t.then((metadata) => {\n\t\t\tif (!metadata.enabled) {\n\t\t\t\tconsole.log('Slush wallet is not currently enabled.');\n\t\t\t\tunregister?.();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tslushWalletInstance.updateMetadata(metadata);\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Error fetching metadata', error);\n\t\t});\n\n\treturn {\n\t\twallet: slushWalletInstance,\n\t\tunregister,\n\t};\n}\n", "export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "import type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n  StaleTimeFunction,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<TQueryKey extends QueryKey = QueryKey> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TContext>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime:\n    | undefined\n    | StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): StaleTime | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n    const aItemsSet = new Set(aItems)\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        ((!array && aItemsSet.has(key)) || array) &&\n        a[key] === undefined &&\n        b[key] === undefined\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwOnError function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "/* istanbul ignore file */\n\nimport type { QueryClient } from './queryClient'\nimport type { DehydrateOptions, HydrateOptions } from './hydration'\nimport type { MutationState } from './mutation'\nimport type { FetchDirection, Query, QueryBehavior } from './query'\nimport type { RetryDelayValue, RetryValue } from './retryer'\nimport type { QueryFilters, QueryTypeFilter, SkipToken } from './utils'\nimport type { QueryCache } from './queryCache'\nimport type { MutationCache } from './mutationCache'\n\nexport type NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type DistributiveOmit<\n  TObject,\n  TKey extends keyof TObject,\n> = TObject extends any ? Omit<TObject, TKey> : never\n\nexport type OmitKeyof<\n  TObject,\n  TKey extends TStrictly extends 'safely'\n    ?\n        | keyof TObject\n        | (string & Record<never, never>)\n        | (number & Record<never, never>)\n        | (symbol & Record<never, never>)\n    : keyof TObject,\n  TStrictly extends 'strictly' | 'safely' = 'strictly',\n> = Omit<TObject, TKey>\n\nexport type Override<TTargetA, TTargetB> = {\n  [AKey in keyof TTargetA]: AKey extends keyof TTargetB\n    ? TTargetB[AKey]\n    : TTargetA[AKey]\n}\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport interface Register {\n  // defaultError: Error\n  // queryMeta: Record<string, unknown>\n  // mutationMeta: Record<string, unknown>\n  // queryKey: ReadonlyArray<unknown>\n  // mutationKey: ReadonlyArray<unknown>\n}\n\nexport type DefaultError = Register extends {\n  defaultError: infer TError\n}\n  ? TError\n  : Error\n\nexport type QueryKey = Register extends {\n  queryKey: infer TQueryKey\n}\n  ? TQueryKey extends ReadonlyArray<unknown>\n    ? TQueryKey\n    : TQueryKey extends Array<unknown>\n      ? TQueryKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport const dataTagSymbol = Symbol('dataTagSymbol')\nexport type dataTagSymbol = typeof dataTagSymbol\nexport const dataTagErrorSymbol = Symbol('dataTagErrorSymbol')\nexport type dataTagErrorSymbol = typeof dataTagErrorSymbol\nexport const unsetMarker = Symbol('unsetMarker')\nexport type UnsetMarker = typeof unsetMarker\nexport type AnyDataTag = {\n  [dataTagSymbol]: any\n  [dataTagErrorSymbol]: any\n}\nexport type DataTag<\n  TType,\n  TValue,\n  TError = UnsetMarker,\n> = TType extends AnyDataTag\n  ? TType\n  : TType & {\n      [dataTagSymbol]: TValue\n      [dataTagErrorSymbol]: TError\n    }\n\nexport type InferDataFromTag<TQueryFnData, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, infer TaggedValue, unknown>\n    ? TaggedValue\n    : TQueryFnData\n\nexport type InferErrorFromTag<TError, TTaggedQueryKey extends QueryKey> =\n  TTaggedQueryKey extends DataTag<unknown, unknown, infer TaggedError>\n    ? TaggedError extends UnsetMarker\n      ? TError\n      : TaggedError\n    : TError\n\nexport type QueryFunction<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>\n\nexport type StaleTime = number | 'static'\n\nexport type StaleTimeFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | StaleTime\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => StaleTime)\n\nexport type Enabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | boolean\n  | ((query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean)\n\nexport type QueryPersister<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? (\n      queryFn: QueryFunction<T, TQueryKey, never>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n  : (\n      queryFn: QueryFunction<T, TQueryKey, TPageParam>,\n      context: QueryFunctionContext<TQueryKey>,\n      query: Query,\n    ) => T | Promise<T>\n\nexport type QueryFunctionContext<\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = [TPageParam] extends [never]\n  ? {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      meta: QueryMeta | undefined\n      pageParam?: unknown\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction?: unknown\n    }\n  : {\n      client: QueryClient\n      queryKey: TQueryKey\n      signal: AbortSignal\n      pageParam: TPageParam\n      /**\n       * @deprecated\n       * if you want access to the direction, you can add it to the pageParam\n       */\n      direction: FetchDirection\n      meta: QueryMeta | undefined\n    }\n\nexport type InitialDataFunction<T> = () => T | undefined\n\ntype NonFunctionGuard<T> = T extends Function ? never : T\n\nexport type PlaceholderDataFunction<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = (\n  previousData: TQueryData | undefined,\n  previousQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined,\n) => TQueryData | undefined\n\nexport type QueriesPlaceholderDataFunction<TQueryData> = (\n  previousData: undefined,\n  previousQuery: undefined,\n) => TQueryData | undefined\n\nexport type QueryKeyHashFunction<TQueryKey extends QueryKey> = (\n  queryKey: TQueryKey,\n) => string\n\nexport type GetPreviousPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  firstPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  firstPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport type GetNextPageParamFunction<TPageParam, TQueryFnData = unknown> = (\n  lastPage: TQueryFnData,\n  allPages: Array<TQueryFnData>,\n  lastPageParam: TPageParam,\n  allPageParams: Array<TPageParam>,\n) => TPageParam | undefined | null\n\nexport interface InfiniteData<TData, TPageParam = unknown> {\n  pages: Array<TData>\n  pageParams: Array<TPageParam>\n}\n\nexport type QueryMeta = Register extends {\n  queryMeta: infer TQueryMeta\n}\n  ? TQueryMeta extends Record<string, unknown>\n    ? TQueryMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type NetworkMode = 'online' | 'always' | 'offlineFirst'\n\nexport type NotifyOnChangeProps =\n  | Array<keyof InfiniteQueryObserverResult>\n  | 'all'\n  | undefined\n  | (() => Array<keyof InfiniteQueryObserverResult> | 'all' | undefined)\n\nexport interface QueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  /**\n   * The time in milliseconds that unused/inactive cache data remains in memory.\n   * When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration.\n   * When different garbage collection times are specified, the longest one will be used.\n   * Setting it to `Infinity` will disable garbage collection.\n   */\n  gcTime?: number\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam> | SkipToken\n  persister?: QueryPersister<\n    NoInfer<TQueryFnData>,\n    NoInfer<TQueryKey>,\n    NoInfer<TPageParam>\n  >\n  queryHash?: string\n  queryKey?: TQueryKey\n  queryKeyHashFn?: QueryKeyHashFunction<TQueryKey>\n  initialData?: TData | InitialDataFunction<TData>\n  initialDataUpdatedAt?: number | (() => number | undefined)\n  behavior?: QueryBehavior<TQueryFnData, TError, TData, TQueryKey>\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom structural sharing logic.\n   * Defaults to `true`.\n   */\n  structuralSharing?:\n    | boolean\n    | ((oldData: unknown | undefined, newData: unknown) => unknown)\n  _defaulted?: boolean\n  /**\n   * Additional payload to be stored on each query.\n   * Use this property to pass information that can be used in other places.\n   */\n  meta?: QueryMeta\n  /**\n   * Maximum number of pages to store in the data of an infinite query.\n   */\n  maxPages?: number\n}\n\nexport interface InitialPageParam<TPageParam = unknown> {\n  initialPageParam: TPageParam\n}\n\nexport interface InfiniteQueryPageParamsOptions<\n  TQueryFnData = unknown,\n  TPageParam = unknown,\n> extends InitialPageParam<TPageParam> {\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: GetPreviousPageParamFunction<TPageParam, TQueryFnData>\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n}\n\nexport type ThrowOnError<\n  TQueryFnData,\n  TError,\n  TQueryData,\n  TQueryKey extends QueryKey,\n> =\n  | boolean\n  | ((\n      error: TError,\n      query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    ) => boolean)\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  /**\n   * Set this to `false` or a function that returns `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Accepts a boolean or function that returns a boolean.\n   * Defaults to `true`.\n   */\n  enabled?: Enabled<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If set to `Infinity`, the data will never be considered stale.\n   * If set to a function, the function will be executed with the query to compute a `staleTime`.\n   * Defaults to `0`.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * If set to a function, the function will be executed with the latest data and query to compute a frequency\n   * Defaults to `false`.\n   */\n  refetchInterval?:\n    | number\n    | false\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => number | false | undefined)\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * If set to `true`, the query will refetch on window focus if the data is stale.\n   * If set to `false`, the query will not refetch on window focus.\n   * If set to `'always'`, the query will always refetch on window focus.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on reconnect if the data is stale.\n   * If set to `false`, the query will not refetch on reconnect.\n   * If set to `'always'`, the query will always refetch on reconnect.\n   * If set to a function, the function will be executed with the latest data and query to compute the value.\n   * Defaults to the value of `networkOnline` (`true`)\n   */\n  refetchOnReconnect?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `true`, the query will refetch on mount if the data is stale.\n   * If set to `false`, will disable additional instances of a query to trigger background refetch.\n   * If set to `'always'`, the query will always refetch on mount.\n   * If set to a function, the function will be executed with the latest data and query to compute the value\n   * Defaults to `true`.\n   */\n  refetchOnMount?:\n    | boolean\n    | 'always'\n    | ((\n        query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n      ) => boolean | 'always')\n  /**\n   * If set to `false`, the query will not be retried on mount if it contains an error.\n   * Defaults to `true`.\n   */\n  retryOnMount?: boolean\n  /**\n   * If set, the component will only re-render if any of the listed properties change.\n   * When set to `['data', 'error']`, the component will only re-render when the `data` or `error` properties change.\n   * When set to `'all'`, the component will re-render whenever a query is updated.\n   * When set to a function, the function will be executed to compute the list of properties.\n   * By default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\n   */\n  notifyOnChangeProps?: NotifyOnChangeProps\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * If set to `true` or `suspense` is `true`, all errors will be thrown to the error boundary.\n   * If set to `false` and `suspense` is `false`, errors are returned as state.\n   * If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (`true`) or return the error as state (`false`).\n   * Defaults to `false`.\n   */\n  throwOnError?: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  /**\n   * This option can be used to transform or select a part of the data returned by the query function.\n   */\n  select?: (data: TQueryData) => TData\n  /**\n   * If set to `true`, the query will suspend when `status === 'pending'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `loading` data and no initialData has been provided.\n   */\n  placeholderData?:\n    | NonFunctionGuard<TQueryData>\n    | PlaceholderDataFunction<\n        NonFunctionGuard<TQueryData>,\n        TError,\n        NonFunctionGuard<TQueryData>,\n        TQueryKey\n      >\n\n  _optimisticResults?: 'optimistic' | 'isRestoring'\n\n  /**\n   * Enable prefetching during rendering\n   */\n  experimental_prefetchInRender?: boolean\n}\n\nexport type WithRequired<TTarget, TKey extends keyof TTarget> = TTarget & {\n  [_ in TKey]: {}\n}\n\nexport type DefaultedQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey,\n      TPageParam\n    >,\n    InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam> {}\n\nexport type DefaultedInfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = WithRequired<\n  InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  'throwOnError' | 'refetchOnReconnect' | 'queryHash'\n>\n\nexport interface FetchQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n    QueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n    'queryKey'\n  > {\n  initialPageParam?: never\n  /**\n   * The time in milliseconds after data is considered stale.\n   * If the data is fresh it will be returned from the cache.\n   */\n  staleTime?: StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>\n}\n\nexport interface EnsureQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  > {\n  revalidateIfStale?: boolean\n}\n\nexport type EnsureInfiniteQueryDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = FetchInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  revalidateIfStale?: boolean\n}\n\ntype FetchInfiniteQueryPages<TQueryFnData = unknown, TPageParam = unknown> =\n  | { pages?: never }\n  | {\n      pages: number\n      getNextPageParam: GetNextPageParamFunction<TPageParam, TQueryFnData>\n    }\n\nexport type FetchInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  FetchQueryOptions<\n    TQueryFnData,\n    TError,\n    InfiniteData<TData, TPageParam>,\n    TQueryKey,\n    TPageParam\n  >,\n  'initialPageParam'\n> &\n  InitialPageParam<TPageParam> &\n  FetchInfiniteQueryPages<TQueryFnData, TPageParam>\n\nexport interface ResultOptions {\n  throwOnError?: boolean\n}\n\nexport interface RefetchOptions extends ResultOptions {\n  /**\n   * If set to `true`, a currently running request will be cancelled before a new request is made\n   *\n   * If set to `false`, no refetch will be made if there is already a request running.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface InvalidateQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {\n  refetchType?: QueryTypeFilter | 'none'\n}\n\nexport interface RefetchQueryFilters<TQueryKey extends QueryKey = QueryKey>\n  extends QueryFilters<TQueryKey> {}\n\nexport interface InvalidateOptions extends RefetchOptions {}\nexport interface ResetOptions extends RefetchOptions {}\n\nexport interface FetchNextPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchNextPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchNextPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport interface FetchPreviousPageOptions extends ResultOptions {\n  /**\n   * If set to `true`, calling `fetchPreviousPage` repeatedly will invoke `queryFn` every time,\n   * whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored.\n   *\n   * If set to `false`, calling `fetchPreviousPage` repeatedly won't have any effect until the first invocation has resolved.\n   *\n   * Defaults to `true`.\n   */\n  cancelRefetch?: boolean\n}\n\nexport type QueryStatus = 'pending' | 'error' | 'success'\nexport type FetchStatus = 'fetching' | 'paused' | 'idle'\n\nexport interface QueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> {\n  /**\n   * The last successfully resolved data for the query.\n   */\n  data: TData | undefined\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"success\"`.\n   */\n  dataUpdatedAt: number\n  /**\n   * The error object for the query, if an error was thrown.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * The timestamp for when the query most recently returned the `status` as `\"error\"`.\n   */\n  errorUpdatedAt: number\n  /**\n   * The failure count for the query.\n   * - Incremented every time the query fails.\n   * - Reset to `0` when the query succeeds.\n   */\n  failureCount: number\n  /**\n   * The failure reason for the query retry.\n   * - Reset to `null` when the query succeeds.\n   */\n  failureReason: TError | null\n  /**\n   * The sum of all errors.\n   */\n  errorUpdateCount: number\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * Will be `true` if the query has been fetched.\n   */\n  isFetched: boolean\n  /**\n   * Will be `true` if the query has been fetched after the component mounted.\n   * - This property can be used to not show any previously cached data.\n   */\n  isFetchedAfterMount: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - `true` whenever the `queryFn` is executing, which includes initial `pending` as well as background refetch.\n   */\n  isFetching: boolean\n  /**\n   * Is `true` whenever the first fetch for a query is in-flight.\n   * - Is the same as `isFetching && isPending`.\n   */\n  isLoading: boolean\n  /**\n   * Will be `pending` if there's no cached data and no query attempt was finished yet.\n   */\n  isPending: boolean\n  /**\n   * Will be `true` if the query failed while fetching for the first time.\n   */\n  isLoadingError: boolean\n  /**\n   * @deprecated `isInitialLoading` is being deprecated in favor of `isLoading`\n   * and will be removed in the next major version.\n   */\n  isInitialLoading: boolean\n  /**\n   * A derived boolean from the `fetchStatus` variable, provided for convenience.\n   * - The query wanted to fetch, but has been `paused`.\n   */\n  isPaused: boolean\n  /**\n   * Will be `true` if the data shown is the placeholder data.\n   */\n  isPlaceholderData: boolean\n  /**\n   * Will be `true` if the query failed while refetching.\n   */\n  isRefetchError: boolean\n  /**\n   * Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`.\n   * - Is the same as `isFetching && !isPending`.\n   */\n  isRefetching: boolean\n  /**\n   * Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.\n   */\n  isStale: boolean\n  /**\n   * A derived boolean from the `status` variable, provided for convenience.\n   * - `true` if the query has received a response with no errors and is ready to display its data.\n   */\n  isSuccess: boolean\n  /**\n   * `true` if this observer is enabled, `false` otherwise.\n   */\n  isEnabled: boolean\n  /**\n   * A function to manually refetch the query.\n   */\n  refetch: (\n    options?: RefetchOptions,\n  ) => Promise<QueryObserverResult<TData, TError>>\n  /**\n   * The status of the query.\n   * - Will be:\n   *   - `pending` if there's no cached data and no query attempt was finished yet.\n   *   - `error` if the query attempt resulted in an error.\n   *   - `success` if the query has received a response with no errors and is ready to display its data.\n   */\n  status: QueryStatus\n  /**\n   * The fetch status of the query.\n   * - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetch.\n   * - `paused`: The query wanted to fetch, but has been `paused`.\n   * - `idle`: The query is not fetching.\n   * - See [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.\n   */\n  fetchStatus: FetchStatus\n  /**\n   * A stable promise that will be resolved with the data of the query.\n   * Requires the `experimental_prefetchInRender` feature flag to be enabled.\n   * @example\n   *\n   * ### Enabling the feature flag\n   * ```ts\n   * const client = new QueryClient({\n   *   defaultOptions: {\n   *     queries: {\n   *       experimental_prefetchInRender: true,\n   *     },\n   *   },\n   * })\n   * ```\n   *\n   * ### Usage\n   * ```tsx\n   * import { useQuery } from '@tanstack/react-query'\n   * import React from 'react'\n   * import { fetchTodos, type Todo } from './api'\n   *\n   * function TodoList({ query }: { query: UseQueryResult<Todo[], Error> }) {\n   *   const data = React.use(query.promise)\n   *\n   *   return (\n   *     <ul>\n   *       {data.map(todo => (\n   *         <li key={todo.id}>{todo.title}</li>\n   *       ))}\n   *     </ul>\n   *   )\n   * }\n   *\n   * export function App() {\n   *   const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n   *\n   *   return (\n   *     <>\n   *       <h1>Todos</h1>\n   *       <React.Suspense fallback={<div>Loading...</div>}>\n   *         <TodoList query={query} />\n   *       </React.Suspense>\n   *     </>\n   *   )\n   * }\n   * ```\n   */\n  promise: Promise<TData>\n}\n\nexport interface QueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface QueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface QueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface QueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  status: 'success'\n}\n\nexport type DefinedQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | QueryObserverRefetchErrorResult<TData, TError>\n  | QueryObserverSuccessResult<TData, TError>\n\nexport type QueryObserverResult<TData = unknown, TError = DefaultError> =\n  | DefinedQueryObserverResult<TData, TError>\n  | QueryObserverLoadingErrorResult<TData, TError>\n  | QueryObserverLoadingResult<TData, TError>\n  | QueryObserverPendingResult<TData, TError>\n  | QueryObserverPlaceholderResult<TData, TError>\n\nexport interface InfiniteQueryObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends QueryObserverBaseResult<TData, TError> {\n  /**\n   * This function allows you to fetch the next \"page\" of results.\n   */\n  fetchNextPage: (\n    options?: FetchNextPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * This function allows you to fetch the previous \"page\" of results.\n   */\n  fetchPreviousPage: (\n    options?: FetchPreviousPageOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n  /**\n   * Will be `true` if there is a next page to be fetched (known via the `getNextPageParam` option).\n   */\n  hasNextPage: boolean\n  /**\n   * Will be `true` if there is a previous page to be fetched (known via the `getPreviousPageParam` option).\n   */\n  hasPreviousPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the next page.\n   */\n  isFetchNextPageError: boolean\n  /**\n   * Will be `true` while fetching the next page with `fetchNextPage`.\n   */\n  isFetchingNextPage: boolean\n  /**\n   * Will be `true` if the query failed while fetching the previous page.\n   */\n  isFetchPreviousPageError: boolean\n  /**\n   * Will be `true` while fetching the previous page with `fetchPreviousPage`.\n   */\n  isFetchingPreviousPage: boolean\n}\n\nexport interface InfiniteQueryObserverPendingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: null\n  isError: false\n  isPending: true\n  isLoading: true\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'pending'\n}\n\nexport interface InfiniteQueryObserverLoadingErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: undefined\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: true\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverRefetchErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: TError\n  isError: true\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: true\n  isSuccess: false\n  isPlaceholderData: false\n  status: 'error'\n}\n\nexport interface InfiniteQueryObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  error: null\n  isError: false\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  isSuccess: true\n  isPlaceholderData: false\n  status: 'success'\n}\n\nexport interface InfiniteQueryObserverPlaceholderResult<\n  TData = unknown,\n  TError = DefaultError,\n> extends InfiniteQueryObserverBaseResult<TData, TError> {\n  data: TData\n  isError: false\n  error: null\n  isPending: false\n  isLoading: false\n  isLoadingError: false\n  isRefetchError: false\n  isSuccess: true\n  isPlaceholderData: true\n  isFetchNextPageError: false\n  isFetchPreviousPageError: false\n  status: 'success'\n}\n\nexport type DefinedInfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | InfiniteQueryObserverRefetchErrorResult<TData, TError>\n  | InfiniteQueryObserverSuccessResult<TData, TError>\n\nexport type InfiniteQueryObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n> =\n  | DefinedInfiniteQueryObserverResult<TData, TError>\n  | InfiniteQueryObserverLoadingErrorResult<TData, TError>\n  | InfiniteQueryObserverLoadingResult<TData, TError>\n  | InfiniteQueryObserverPendingResult<TData, TError>\n  | InfiniteQueryObserverPlaceholderResult<TData, TError>\n\nexport type MutationKey = Register extends {\n  mutationKey: infer TMutationKey\n}\n  ? TMutationKey extends Array<unknown>\n    ? TMutationKey\n    : TMutationKey extends Array<unknown>\n      ? TMutationKey\n      : ReadonlyArray<unknown>\n  : ReadonlyArray<unknown>\n\nexport type MutationStatus = 'idle' | 'pending' | 'success' | 'error'\n\nexport type MutationScope = {\n  id: string\n}\n\nexport type MutationMeta = Register extends {\n  mutationMeta: infer TMutationMeta\n}\n  ? TMutationMeta extends Record<string, unknown>\n    ? TMutationMeta\n    : Record<string, unknown>\n  : Record<string, unknown>\n\nexport type MutationFunction<TData = unknown, TVariables = unknown> = (\n  variables: TVariables,\n) => Promise<TData>\n\nexport interface MutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  mutationFn?: MutationFunction<TData, TVariables>\n  mutationKey?: MutationKey\n  onMutate?: (\n    variables: TVariables,\n  ) => Promise<TContext | undefined> | TContext | undefined\n  onSuccess?: (\n    data: TData,\n    variables: TVariables,\n    context: TContext,\n  ) => Promise<unknown> | unknown\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => Promise<unknown> | unknown\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode?: NetworkMode\n  gcTime?: number\n  _defaulted?: boolean\n  meta?: MutationMeta\n  scope?: MutationScope\n}\n\nexport interface MutationObserverOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationOptions<TData, TError, TVariables, TContext> {\n  throwOnError?: boolean | ((error: TError) => boolean)\n}\n\nexport interface MutateOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  onSuccess?: (data: TData, variables: TVariables, context: TContext) => void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: TContext | undefined,\n  ) => void\n}\n\nexport type MutateFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  variables: TVariables,\n  options?: MutateOptions<TData, TError, TVariables, TContext>,\n) => Promise<TData>\n\nexport interface MutationObserverBaseResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationState<TData, TError, TVariables, TContext> {\n  /**\n   * The last successfully resolved data for the mutation.\n   */\n  data: TData | undefined\n  /**\n   * The variables object passed to the `mutationFn`.\n   */\n  variables: TVariables | undefined\n  /**\n   * The error object for the mutation, if an error was encountered.\n   * - Defaults to `null`.\n   */\n  error: TError | null\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt resulted in an error.\n   */\n  isError: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is in its initial state prior to executing.\n   */\n  isIdle: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the mutation is currently executing.\n   */\n  isPending: boolean\n  /**\n   * A boolean variable derived from `status`.\n   * - `true` if the last mutation attempt was successful.\n   */\n  isSuccess: boolean\n  /**\n   * The status of the mutation.\n   * - Will be:\n   *   - `idle` initial status prior to the mutation function executing.\n   *   - `pending` if the mutation is currently executing.\n   *   - `error` if the last mutation attempt resulted in an error.\n   *   - `success` if the last mutation attempt was successful.\n   */\n  status: MutationStatus\n  /**\n   * The mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\n   * @param variables - The variables object to pass to the `mutationFn`.\n   * @param options.onSuccess - This function will fire when the mutation is successful and will be passed the mutation's result.\n   * @param options.onError - This function will fire if the mutation encounters an error and will be passed the error.\n   * @param options.onSettled - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error.\n   * @remarks\n   * - If you make multiple requests, `onSuccess` will fire only after the latest call you've made.\n   * - All the callback functions (`onSuccess`, `onError`, `onSettled`) are void functions, and the returned value will be ignored.\n   */\n  mutate: MutateFunction<TData, TError, TVariables, TContext>\n  /**\n   * A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\n   */\n  reset: () => void\n}\n\nexport interface MutationObserverIdleResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: undefined\n  error: null\n  isError: false\n  isIdle: true\n  isPending: false\n  isSuccess: false\n  status: 'idle'\n}\n\nexport interface MutationObserverLoadingResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  variables: TVariables\n  error: null\n  isError: false\n  isIdle: false\n  isPending: true\n  isSuccess: false\n  status: 'pending'\n}\n\nexport interface MutationObserverErrorResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: undefined\n  error: TError\n  variables: TVariables\n  isError: true\n  isIdle: false\n  isPending: false\n  isSuccess: false\n  status: 'error'\n}\n\nexport interface MutationObserverSuccessResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends MutationObserverBaseResult<TData, TError, TVariables, TContext> {\n  data: TData\n  error: null\n  variables: TVariables\n  isError: false\n  isIdle: false\n  isPending: false\n  isSuccess: true\n  status: 'success'\n}\n\nexport type MutationObserverResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> =\n  | MutationObserverIdleResult<TData, TError, TVariables, TContext>\n  | MutationObserverLoadingResult<TData, TError, TVariables, TContext>\n  | MutationObserverErrorResult<TData, TError, TVariables, TContext>\n  | MutationObserverSuccessResult<TData, TError, TVariables, TContext>\n\nexport interface QueryClientConfig {\n  queryCache?: QueryCache\n  mutationCache?: MutationCache\n  defaultOptions?: DefaultOptions\n}\n\nexport interface DefaultOptions<TError = DefaultError> {\n  queries?: OmitKeyof<\n    QueryObserverOptions<unknown, TError>,\n    'suspense' | 'queryKey'\n  >\n  mutations?: MutationObserverOptions<unknown, TError, unknown, unknown>\n  hydrate?: HydrateOptions['defaultOptions']\n  dehydrate?: DehydrateOptions\n}\n\nexport interface CancelOptions {\n  revert?: boolean\n  silent?: boolean\n}\n\nexport interface SetDataOptions {\n  updatedAt?: number\n}\n\nexport type NotifyEventType =\n  | 'added'\n  | 'removed'\n  | 'updated'\n  | 'observerAdded'\n  | 'observerRemoved'\n  | 'observerResultsUpdated'\n  | 'observerOptionsUpdated'\n\nexport interface NotifyEvent {\n  type: NotifyEventType\n}\n", "'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n", "'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n", "'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state: DehydratedState | null | undefined\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = state.queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n", "'use client'\nimport * as React from 'react'\nimport { notifyManager } from '@tanstack/query-core'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport type { QueryClient, QueryFilters } from '@tanstack/query-core'\n\nexport function useIsFetching(\n  filters?: QueryFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  const queryCache = client.getQueryCache()\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters),\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nimport { notifyManager, replaceEqualDeep } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  Mutation,\n  MutationCache,\n  MutationFilters,\n  MutationState,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  queryClient?: QueryClient,\n): number {\n  const client = useQueryClient(queryClient)\n  return useMutationState(\n    { filters: { ...filters, status: 'pending' } },\n    client,\n  ).length\n}\n\ntype MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (mutation: Mutation) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select ? options.select(mutation) : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): Array<TResult> {\n  const mutationCache = useQueryClient(queryClient).getMutationCache()\n  const optionsRef = React.useRef(options)\n  const result = React.useRef<Array<TResult>>(null)\n  if (!result.current) {\n    result.current = getResult(mutationCache, options)\n  }\n\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(() => {\n          const nextResult = replaceEqualDeep(\n            result.current,\n            getResult(mutationCache, optionsRef.current),\n          )\n          if (result.current !== nextResult) {\n            result.current = nextResult\n            notifyManager.schedule(onStoreChange)\n          }\n        }),\n      [mutationCache],\n    ),\n    () => result.current,\n    () => result.current,\n  )!\n}\n", "'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n", "import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n", "function toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction mapValues(input, fn) {\n  var result = {};\n  for (var _key in input) {\n    result[_key] = fn(input[_key], _key);\n  }\n  return result;\n}\n\nvar shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {\n  for (var key of Object.keys(compoundCheck)) {\n    var _selections$key;\n    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {\n      return false;\n    }\n  }\n  return true;\n};\nvar createRuntimeFn = config => {\n  var runtimeFn = options => {\n    var className = config.defaultClassName;\n    var selections = _objectSpread2(_objectSpread2({}, config.defaultVariants), options);\n    for (var variantName in selections) {\n      var _selections$variantNa;\n      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];\n      if (variantSelection != null) {\n        var selection = variantSelection;\n        if (typeof selection === 'boolean') {\n          // @ts-expect-error\n          selection = selection === true ? 'true' : 'false';\n        }\n        var selectionClassName =\n        // @ts-expect-error\n        config.variantClassNames[variantName][selection];\n        if (selectionClassName) {\n          className += ' ' + selectionClassName;\n        }\n      }\n    }\n    for (var [compoundCheck, compoundClassName] of config.compoundVariants) {\n      if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) {\n        className += ' ' + compoundClassName;\n      }\n    }\n    return className;\n  };\n  runtimeFn.variants = () => Object.keys(config.variantClassNames);\n  runtimeFn.classNames = {\n    get base() {\n      return config.defaultClassName.split(' ')[0];\n    },\n    get variants() {\n      return mapValues(config.variantClassNames, classNames => mapValues(classNames, className => className.split(' ')[0]));\n    }\n  };\n  return runtimeFn;\n};\n\nexport { createRuntimeFn as c, mapValues as m };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tconst arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/utils';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytesVector`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst SUI_NS_NAME_REGEX =\n\t/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\n\nexport function isValidSuiNSName(name: string): boolean {\n\tif (name.length > MAX_SUI_NS_NAME_LENGTH) {\n\t\treturn false;\n\t}\n\n\tif (name.includes('@')) {\n\t\treturn SUI_NS_NAME_REGEX.test(name);\n\t}\n\n\treturn SUI_NS_DOMAIN_REGEX.test(name);\n}\n\nexport function normalizeSuiNSName(name: string, format: 'at' | 'dot' = 'at'): string {\n\tconst lowerCase = name.toLowerCase();\n\tlet parts;\n\n\tif (lowerCase.includes('@')) {\n\t\tif (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tconst [labels, domain] = lowerCase.split('@');\n\t\tparts = [...(labels ? labels.split('.') : []), domain];\n\t} else {\n\t\tif (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n\t\t\tthrow new Error(`Invalid SuiNS name ${name}`);\n\t\t}\n\t\tparts = lowerCase.split('.').slice(0, -1);\n\t}\n\n\tif (format === 'dot') {\n\t\treturn `${parts.join('.')}.sui`;\n\t}\n\n\treturn `${parts.slice(0, -1).join('.')}@${parts[parts.length - 1]}`;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isValidSuiNSName } from './suins.js';\n\n/** The pattern to find an optionally versioned name */\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\n/** The pattern for a valid version number */\nconst VERSION_REGEX = /^\\d+$/;\n/** The maximum size for an app */\nconst MAX_APP_SIZE = 64;\n/** The separator for the name */\nconst NAME_SEPARATOR = '/';\n\nexport const isValidNamedPackage = (name: string): boolean => {\n\tconst parts = name.split(NAME_SEPARATOR);\n\t// The name has to have 2 parts (without-version), or 3 parts (with version).\n\tif (parts.length < 2 || parts.length > 3) return false;\n\n\tconst [org, app, version] = parts; // split by {org} {app} {optional version}\n\n\t// If the version exists, it must be a number.\n\tif (version !== undefined && !VERSION_REGEX.test(version)) return false;\n\t// Check if the org is a valid SuiNS name.\n\tif (!isValidSuiNSName(org)) return false;\n\n\t// Check if the app is a valid name.\n\treturn NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\n\n/**\n * Checks if a type contains valid named packages.\n * This DOES NOT check if the type is a valid Move type.\n */\nexport const isValidNamedType = (type: string): boolean => {\n\t// split our type by all possible type delimeters.\n\tconst splitType = type.split(/::|<|>|,/);\n\tfor (const t of splitType) {\n\t\tif (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n\t}\n\t// TODO: Add `isValidStructTag` check once it's introduced.\n\treturn true;\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, splitGenericParameters } from '@mysten/bcs';\n\nimport { isValidNamedPackage } from './move-registry.js';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromBase58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst isMvrPackage = isValidNamedPackage(address);\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t\t)\n\t\t: [];\n\n\treturn {\n\t\taddress: isMvrPackage ? address : normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiObjectId } from './sui-types.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number | string) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\nexport const Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tvalidate: (val) => {\n\t\tconst address = typeof val === 'string' ? val : toHex(val);\n\t\tif (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n\t\t\tthrow new Error(`Invalid Sui address ${address}`);\n\t\t}\n\t},\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHex(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromBase58(value),\n\toutput: (value) => toBase58(new Uint8Array(value)),\n\tvalidate: (value) => {\n\t\tif (fromBase58(value).length !== 32) {\n\t\t\tthrow new Error('ObjectDigest must be 32 bytes');\n\t\t}\n\t},\n});\n\nexport const SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwnedObject: SuiObjectRef,\n\tSharedObject: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n\tAddressOwner: Address,\n\tObjectOwner: Address,\n\tShared: bcs.struct('Shared', {\n\t\tinitialSharedVersion: bcs.u64(),\n\t}),\n\tImmutable: null,\n\tConsensusAddressOwner: bcs.struct('ConsensusAddressOwner', {\n\t\towner: Address,\n\t\tstartVersion: bcs.u64(),\n\t}),\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n\tPure: bcs.struct('Pure', {\n\t\tbytes: bcs.vector(bcs.u8()).transform({\n\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t}),\n\t}),\n\tObject: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => InnerTypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n\tinput: (typeTag: string | TypeTagType) =>\n\t\ttypeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n\toutput: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n\tGasCoin: null,\n\tInput: bcs.u16(),\n\tResult: bcs.u16(),\n\tNestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n\tpackage: Address,\n\tmodule: bcs.string(),\n\tfunction: bcs.string(),\n\ttypeArguments: bcs.vector(TypeTag),\n\targuments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n\t/**\n\t * A Move Call - any public Move function can be called via\n\t * this transaction. The results can be used that instant to pass\n\t * into the next transaction.\n\t */\n\tMoveCall: ProgrammableMoveCall,\n\t/**\n\t * Transfer vector of objects to a receiver.\n\t */\n\tTransferObjects: bcs.struct('TransferObjects', {\n\t\tobjects: bcs.vector(Argument),\n\t\taddress: Argument,\n\t}),\n\t// /**\n\t//  * Split `amount` from a `coin`.\n\t//  */\n\tSplitCoins: bcs.struct('SplitCoins', {\n\t\tcoin: Argument,\n\t\tamounts: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Merge Vector of Coins (`sources`) into a `destination`.\n\t//  */\n\tMergeCoins: bcs.struct('MergeCoins', {\n\t\tdestination: Argument,\n\t\tsources: bcs.vector(Argument),\n\t}),\n\t// /**\n\t//  * Publish a Move module.\n\t//  */\n\tPublish: bcs.struct('Publish', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t}),\n\t// /**\n\t//  * Build a vector of objects using the input arguments.\n\t//  * It is impossible to export construct a `vector<T: key>` otherwise,\n\t//  * so this call serves a utility function.\n\t//  */\n\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\ttype: optionEnum(TypeTag).transform({\n\t\t\tinput: (val: string | null) =>\n\t\t\t\tval === null\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tNone: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tSome: val,\n\t\t\t\t\t\t},\n\t\t\toutput: (val) => val.Some ?? null,\n\t\t}),\n\t\telements: bcs.vector(Argument),\n\t}),\n\tUpgrade: bcs.struct('Upgrade', {\n\t\tmodules: bcs.vector(\n\t\t\tbcs.vector(bcs.u8()).transform({\n\t\t\t\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\t\t\t\toutput: (val) => toBase64(new Uint8Array(val)),\n\t\t\t}),\n\t\t),\n\t\tdependencies: bcs.vector(Address),\n\t\tpackage: Address,\n\t\tticket: Argument,\n\t}),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\tcommands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n\treturn bcs.struct(`IntentMessage<${T.name}>`, {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t});\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n\tPasskey: bcs.vector(bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n\tPasskey: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n\toutput: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n\tauthenticatorData: bcs.vector(bcs.u8()),\n\tclientDataJson: bcs.string(),\n\tuserSignature: bcs.vector(bcs.u8()),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport { Address, ObjectDigest, Owner, SuiObjectRef } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n\tUnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n\tNotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n\tIncompatibleUpgrade: null,\n\tDigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n\tUnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n\tPackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n\t\tpackageId: Address,\n\t\tticketId: Address,\n\t}),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n\taddress: Address,\n\tname: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n\tmodule: ModuleId,\n\tfunction: bcs.u16(),\n\tinstruction: bcs.u16(),\n\tfunctionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n\tTypeMismatch: null,\n\tInvalidBCSBytes: null,\n\tInvalidUsageOfPureArg: null,\n\tInvalidArgumentToPrivateEntryFunction: null,\n\tIndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n\tSecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n\tInvalidGasCoinUsage: null,\n\tInvalidValueUsage: null,\n\tInvalidObjectByValue: null,\n\tInvalidObjectByMutRef: null,\n\tSharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n\tTypeNotFound: null,\n\tConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n\tInsufficientGas: null,\n\tInvalidGasObject: null,\n\tInvariantViolation: null,\n\tFeatureNotYetSupported: null,\n\tMoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tMovePackageTooBig: bcs.struct('MovePackageTooBig', {\n\t\tobjectSize: bcs.u64(),\n\t\tmaxObjectSize: bcs.u64(),\n\t}),\n\tCircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n\tInsufficientCoinBalance: null,\n\tCoinBalanceOverflow: null,\n\tPublishErrorNonZeroAddress: null,\n\tSuiMoveVerificationError: null,\n\tMovePrimitiveRuntimeError: bcs.option(MoveLocation),\n\tMoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n\tVMVerificationOrDeserializationError: null,\n\tVMInvariantViolation: null,\n\tFunctionNotFound: null,\n\tArityMismatch: null,\n\tTypeArityMismatch: null,\n\tNonEntryFunctionInvoked: null,\n\tCommandArgumentError: bcs.struct('CommandArgumentError', {\n\t\targIdx: bcs.u16(),\n\t\tkind: CommandArgumentError,\n\t}),\n\tTypeArgumentError: bcs.struct('TypeArgumentError', {\n\t\targumentIdx: bcs.u16(),\n\t\tkind: TypeArgumentError,\n\t}),\n\tUnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n\t\tresultIdx: bcs.u16(),\n\t\tsecondaryIdx: bcs.u16(),\n\t}),\n\tInvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n\t\tidx: bcs.u16(),\n\t}),\n\tInvalidTransferObject: null,\n\tEffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n\tPublishUpgradeMissingDependency: null,\n\tPublishUpgradeDependencyDowngrade: null,\n\tPackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n\tWrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n\t\tcurrentSize: bcs.u64(),\n\t\tmaxSize: bcs.u64(),\n\t}),\n\tCertificateDenied: null,\n\tSuiMoveVerificationTimedout: null,\n\tSharedObjectOperationNotAllowed: null,\n\tInputObjectDeleted: null,\n\tExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n\t\t'ExecutionCancelledDueToSharedObjectCongestion',\n\t\t{\n\t\t\tcongestedObjects: bcs.vector(Address),\n\t\t},\n\t),\n\tAddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n\t\taddress: Address,\n\t\tcoinType: bcs.string(),\n\t}),\n\tCoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n\tExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n\tSuccess: null,\n\tFailed: bcs.struct('ExecutionFailed', {\n\t\terror: ExecutionFailureStatus,\n\t\tcommand: bcs.option(bcs.u64()),\n\t}),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n\tcomputationCost: bcs.u64(),\n\tstorageCost: bcs.u64(),\n\tstorageRebate: bcs.u64(),\n\tnonRefundableStorageFee: bcs.u64(),\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\tmodifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n\tsharedObjects: bcs.vector(SuiObjectRef),\n\ttransactionDigest: ObjectDigest,\n\tcreated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tmutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tunwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n\tdeleted: bcs.vector(SuiObjectRef),\n\tunwrappedThenDeleted: bcs.vector(SuiObjectRef),\n\twrapped: bcs.vector(SuiObjectRef),\n\tgasObject: bcs.tuple([SuiObjectRef, Owner]),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n\tNotExist: null,\n\tExist: bcs.tuple([VersionDigest, Owner]),\n});\n\nconst ObjectOut = bcs.enum('ObjectOut', {\n\tNotExist: null,\n\tObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n\tPackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n\tNone: null,\n\tCreated: null,\n\tDeleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n\tinputState: ObjectIn,\n\toutputState: ObjectOut,\n\tidOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n\tReadOnlyRoot: VersionDigest,\n\tMutateDeleted: bcs.u64(),\n\tReadDeleted: bcs.u64(),\n\tCancelled: bcs.u64(),\n\tPerEpochConfig: null,\n});\n\nconst TransactionEffectsV2 = bcs.struct('TransactionEffectsV2', {\n\tstatus: ExecutionStatus,\n\texecutedEpoch: bcs.u64(),\n\tgasUsed: GasCostSummary,\n\ttransactionDigest: ObjectDigest,\n\tgasObjectIndex: bcs.option(bcs.u32()),\n\teventsDigest: bcs.option(ObjectDigest),\n\tdependencies: bcs.vector(ObjectDigest),\n\tlamportVersion: bcs.u64(),\n\tchangedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n\tunchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n\tauxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n\tV1: TransactionEffectsV1,\n\tV2: TransactionEffectsV2,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { BcsType } from '@mysten/bcs';\n\nimport { Address } from './bcs.js';\n\nexport type BasePureType =\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| 'bool'\n\t| 'id'\n\t| 'string'\n\t| 'address';\n\ninterface PureShapeByType {\n\tu8: number;\n\tu16: number;\n\tu32: number;\n\tu64: bigint | string | number;\n\tu128: bigint | string | number;\n\tu256: bigint | string | number;\n\tbool: boolean;\n\tstring: string;\n\tid: string | Uint8Array;\n\taddress: string | Uint8Array;\n}\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n\t? PureTypeName\n\t: T extends `vector<${infer U}>`\n\t\t? ValidPureTypeName<U>\n\t\t: T extends `option<${infer U}>`\n\t\t\t? ValidPureTypeName<U>\n\t\t\t: PureTypeValidationError<T>;\n\nexport type ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n\t? PureShapeByType[T]\n\t: T extends `vector<${infer U extends PureTypeName}>`\n\t\t? ShapeFromPureTypeName<U>[]\n\t\t: T extends `option<${infer U extends PureTypeName}>`\n\t\t\t? ShapeFromPureTypeName<U> | null\n\t\t\t: never;\n\ntype PureTypeValidationError<T extends string> = T & {\n\terror: `Invalid Pure type name: ${T}`;\n};\n\nexport function pureBcsSchemaFromTypeName<T extends PureTypeName>(\n\tname: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n\tswitch (name) {\n\t\tcase 'u8':\n\t\t\treturn bcs.u8() as never;\n\t\tcase 'u16':\n\t\t\treturn bcs.u16() as never;\n\t\tcase 'u32':\n\t\t\treturn bcs.u32() as never;\n\t\tcase 'u64':\n\t\t\treturn bcs.u64() as never;\n\t\tcase 'u128':\n\t\t\treturn bcs.u128() as never;\n\t\tcase 'u256':\n\t\t\treturn bcs.u256() as never;\n\t\tcase 'bool':\n\t\t\treturn bcs.bool() as never;\n\t\tcase 'string':\n\t\t\treturn bcs.string() as never;\n\t\tcase 'id':\n\t\tcase 'address':\n\t\t\treturn Address as never;\n\t}\n\n\tconst generic = name.match(/^(vector|option)<(.+)>$/);\n\tif (generic) {\n\t\tconst [kind, inner] = generic.slice(1);\n\t\tif (kind === 'vector') {\n\t\t\treturn bcs.vector(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t} else {\n\t\t\treturn bcs.option(pureBcsSchemaFromTypeName(inner as PureTypeName)) as never;\n\t\t}\n\t}\n\n\tthrow new Error(`Invalid Pure type name: ${name}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\n\nimport {\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@mysten/bcs';\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tAppId,\n\tArgument,\n\tCallArg,\n\tCommand,\n\tCompressedSignature,\n\tGasData,\n\tIntent,\n\tIntentMessage,\n\tIntentScope,\n\tIntentVersion,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tOwner,\n\tPasskeyAuthenticator,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionEffects,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n};\nexport {\n\tpureBcsSchemaFromTypeName,\n\ttype ShapeFromPureTypeName,\n\ttype PureTypeName,\n} from './pure.js';\n\nexport { suiBcs as bcs };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nimport type { TypeTag } from '../bcs/bcs.js';\nimport { bcs } from '../bcs/index.js';\n\nexport function deriveDynamicFieldID(\n\tparentId: string,\n\ttypeTag: typeof TypeTag.$inferInput,\n\tkey: Uint8Array,\n) {\n\tconst address = bcs.Address.serialize(parentId).toBytes();\n\tconst tag = bcs.TypeTag.serialize(typeTag).toBytes();\n\tconst keyLength = bcs.u64().serialize(key.length).toBytes();\n\n\tconst hash = blake2b.create({\n\t\tdkLen: 32,\n\t});\n\n\thash.update(new Uint8Array([0xf0]));\n\thash.update(address);\n\thash.update(keyLength);\n\thash.update(key);\n\thash.update(tag);\n\n\treturn `0x${toHex(hash.digest().slice(0, 32))}`;\n}\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as MenuPrimitive from '@radix-ui/react-menu';\nimport { createMenuScope } from '@radix-ui/react-menu';\nimport { useId } from '@radix-ui/react-id';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst DROPDOWN_MENU_NAME = 'DropdownMenu';\n\ntype ScopedProps<P> = P & { __scopeDropdownMenu?: Scope };\nconst [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(\n  DROPDOWN_MENU_NAME,\n  [createMenuScope]\n);\nconst useMenuScope = createMenuScope();\n\ntype DropdownMenuContextValue = {\n  triggerId: string;\n  triggerRef: React.RefObject<HTMLButtonElement | null>;\n  contentId: string;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal: boolean;\n};\n\nconst [DropdownMenuProvider, useDropdownMenuContext] =\n  createDropdownMenuContext<DropdownMenuContextValue>(DROPDOWN_MENU_NAME);\n\ninterface DropdownMenuProps {\n  children?: React.ReactNode;\n  dir?: Direction;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  modal?: boolean;\n}\n\nconst DropdownMenu: React.FC<DropdownMenuProps> = (props: ScopedProps<DropdownMenuProps>) => {\n  const {\n    __scopeDropdownMenu,\n    children,\n    dir,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    modal = true,\n  } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: DROPDOWN_MENU_NAME,\n  });\n\n  return (\n    <DropdownMenuProvider\n      scope={__scopeDropdownMenu}\n      triggerId={useId()}\n      triggerRef={triggerRef}\n      contentId={useId()}\n      open={open}\n      onOpenChange={setOpen}\n      onOpenToggle={React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen])}\n      modal={modal}\n    >\n      <MenuPrimitive.Root {...menuScope} open={open} onOpenChange={setOpen} dir={dir} modal={modal}>\n        {children}\n      </MenuPrimitive.Root>\n    </DropdownMenuProvider>\n  );\n};\n\nDropdownMenu.displayName = DROPDOWN_MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'DropdownMenuTrigger';\n\ntype DropdownMenuTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface DropdownMenuTriggerProps extends PrimitiveButtonProps {}\n\nconst DropdownMenuTrigger = React.forwardRef<DropdownMenuTriggerElement, DropdownMenuTriggerProps>(\n  (props: ScopedProps<DropdownMenuTriggerProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;\n    const context = useDropdownMenuContext(TRIGGER_NAME, __scopeDropdownMenu);\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return (\n      <MenuPrimitive.Anchor asChild {...menuScope}>\n        <Primitive.button\n          type=\"button\"\n          id={context.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={context.open ? context.contentId : undefined}\n          data-state={context.open ? 'open' : 'closed'}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          {...triggerProps}\n          ref={composeRefs(forwardedRef, context.triggerRef)}\n          onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click)\n            if (!disabled && event.button === 0 && event.ctrlKey === false) {\n              context.onOpenToggle();\n              // prevent trigger focusing when opening\n              // this allows the content to be given focus without competition\n              if (!context.open) event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (disabled) return;\n            if (['Enter', ' '].includes(event.key)) context.onOpenToggle();\n            if (event.key === 'ArrowDown') context.onOpenChange(true);\n            // prevent keydown from scrolling window / first focused item to execute\n            // that keydown (inadvertently closing the menu)\n            if (['Enter', ' ', 'ArrowDown'].includes(event.key)) event.preventDefault();\n          })}\n        />\n      </MenuPrimitive.Anchor>\n    );\n  }\n);\n\nDropdownMenuTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'DropdownMenuPortal';\n\ntype MenuPortalProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Portal>;\ninterface DropdownMenuPortalProps extends MenuPortalProps {}\n\nconst DropdownMenuPortal: React.FC<DropdownMenuPortalProps> = (\n  props: ScopedProps<DropdownMenuPortalProps>\n) => {\n  const { __scopeDropdownMenu, ...portalProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.Portal {...menuScope} {...portalProps} />;\n};\n\nDropdownMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'DropdownMenuContent';\n\ntype DropdownMenuContentElement = React.ComponentRef<typeof MenuPrimitive.Content>;\ntype MenuContentProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Content>;\ninterface DropdownMenuContentProps extends Omit<MenuContentProps, 'onEntryFocus'> {}\n\nconst DropdownMenuContent = React.forwardRef<DropdownMenuContentElement, DropdownMenuContentProps>(\n  (props: ScopedProps<DropdownMenuContentProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...contentProps } = props;\n    const context = useDropdownMenuContext(CONTENT_NAME, __scopeDropdownMenu);\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    const hasInteractedOutsideRef = React.useRef(false);\n\n    return (\n      <MenuPrimitive.Content\n        id={context.contentId}\n        aria-labelledby={context.triggerId}\n        {...menuScope}\n        {...contentProps}\n        ref={forwardedRef}\n        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n          hasInteractedOutsideRef.current = false;\n          // Always prevent auto focus because we either focus manually or want user agent focus\n          event.preventDefault();\n        })}\n        onInteractOutside={composeEventHandlers(props.onInteractOutside, (event) => {\n          const originalEvent = event.detail.originalEvent as PointerEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;\n        })}\n        style={{\n          ...props.style,\n          // re-namespace exposed content custom properties\n          ...{\n            '--radix-dropdown-menu-content-transform-origin':\n              'var(--radix-popper-transform-origin)',\n            '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',\n            '--radix-dropdown-menu-content-available-height':\n              'var(--radix-popper-available-height)',\n            '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',\n            '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',\n          },\n        }}\n      />\n    );\n  }\n);\n\nDropdownMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'DropdownMenuGroup';\n\ntype DropdownMenuGroupElement = React.ComponentRef<typeof MenuPrimitive.Group>;\ntype MenuGroupProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Group>;\ninterface DropdownMenuGroupProps extends MenuGroupProps {}\n\nconst DropdownMenuGroup = React.forwardRef<DropdownMenuGroupElement, DropdownMenuGroupProps>(\n  (props: ScopedProps<DropdownMenuGroupProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...groupProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Group {...menuScope} {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'DropdownMenuLabel';\n\ntype DropdownMenuLabelElement = React.ComponentRef<typeof MenuPrimitive.Label>;\ntype MenuLabelProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Label>;\ninterface DropdownMenuLabelProps extends MenuLabelProps {}\n\nconst DropdownMenuLabel = React.forwardRef<DropdownMenuLabelElement, DropdownMenuLabelProps>(\n  (props: ScopedProps<DropdownMenuLabelProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...labelProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Label {...menuScope} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'DropdownMenuItem';\n\ntype DropdownMenuItemElement = React.ComponentRef<typeof MenuPrimitive.Item>;\ntype MenuItemProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Item>;\ninterface DropdownMenuItemProps extends MenuItemProps {}\n\nconst DropdownMenuItem = React.forwardRef<DropdownMenuItemElement, DropdownMenuItemProps>(\n  (props: ScopedProps<DropdownMenuItemProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...itemProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Item {...menuScope} {...itemProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'DropdownMenuCheckboxItem';\n\ntype DropdownMenuCheckboxItemElement = React.ComponentRef<typeof MenuPrimitive.CheckboxItem>;\ntype MenuCheckboxItemProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.CheckboxItem>;\ninterface DropdownMenuCheckboxItemProps extends MenuCheckboxItemProps {}\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  DropdownMenuCheckboxItemElement,\n  DropdownMenuCheckboxItemProps\n>((props: ScopedProps<DropdownMenuCheckboxItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...checkboxItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.CheckboxItem {...menuScope} {...checkboxItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'DropdownMenuRadioGroup';\n\ntype DropdownMenuRadioGroupElement = React.ComponentRef<typeof MenuPrimitive.RadioGroup>;\ntype MenuRadioGroupProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioGroup>;\ninterface DropdownMenuRadioGroupProps extends MenuRadioGroupProps {}\n\nconst DropdownMenuRadioGroup = React.forwardRef<\n  DropdownMenuRadioGroupElement,\n  DropdownMenuRadioGroupProps\n>((props: ScopedProps<DropdownMenuRadioGroupProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioGroupProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.RadioGroup {...menuScope} {...radioGroupProps} ref={forwardedRef} />;\n});\n\nDropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'DropdownMenuRadioItem';\n\ntype DropdownMenuRadioItemElement = React.ComponentRef<typeof MenuPrimitive.RadioItem>;\ntype MenuRadioItemProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioItem>;\ninterface DropdownMenuRadioItemProps extends MenuRadioItemProps {}\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  DropdownMenuRadioItemElement,\n  DropdownMenuRadioItemProps\n>((props: ScopedProps<DropdownMenuRadioItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.RadioItem {...menuScope} {...radioItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'DropdownMenuItemIndicator';\n\ntype DropdownMenuItemIndicatorElement = React.ComponentRef<typeof MenuPrimitive.ItemIndicator>;\ntype MenuItemIndicatorProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.ItemIndicator>;\ninterface DropdownMenuItemIndicatorProps extends MenuItemIndicatorProps {}\n\nconst DropdownMenuItemIndicator = React.forwardRef<\n  DropdownMenuItemIndicatorElement,\n  DropdownMenuItemIndicatorProps\n>((props: ScopedProps<DropdownMenuItemIndicatorProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.ItemIndicator {...menuScope} {...itemIndicatorProps} ref={forwardedRef} />;\n});\n\nDropdownMenuItemIndicator.displayName = INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'DropdownMenuSeparator';\n\ntype DropdownMenuSeparatorElement = React.ComponentRef<typeof MenuPrimitive.Separator>;\ntype MenuSeparatorProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Separator>;\ninterface DropdownMenuSeparatorProps extends MenuSeparatorProps {}\n\nconst DropdownMenuSeparator = React.forwardRef<\n  DropdownMenuSeparatorElement,\n  DropdownMenuSeparatorProps\n>((props: ScopedProps<DropdownMenuSeparatorProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...separatorProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.Separator {...menuScope} {...separatorProps} ref={forwardedRef} />;\n});\n\nDropdownMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'DropdownMenuArrow';\n\ntype DropdownMenuArrowElement = React.ComponentRef<typeof MenuPrimitive.Arrow>;\ntype MenuArrowProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Arrow>;\ninterface DropdownMenuArrowProps extends MenuArrowProps {}\n\nconst DropdownMenuArrow = React.forwardRef<DropdownMenuArrowElement, DropdownMenuArrowProps>(\n  (props: ScopedProps<DropdownMenuArrowProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...arrowProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Arrow {...menuScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSub\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DropdownMenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst DropdownMenuSub: React.FC<DropdownMenuSubProps> = (\n  props: ScopedProps<DropdownMenuSubProps>\n) => {\n  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: 'DropdownMenuSub',\n  });\n\n  return (\n    <MenuPrimitive.Sub {...menuScope} open={open} onOpenChange={setOpen}>\n      {children}\n    </MenuPrimitive.Sub>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'DropdownMenuSubTrigger';\n\ntype DropdownMenuSubTriggerElement = React.ComponentRef<typeof MenuPrimitive.SubTrigger>;\ntype MenuSubTriggerProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.SubTrigger>;\ninterface DropdownMenuSubTriggerProps extends MenuSubTriggerProps {}\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  DropdownMenuSubTriggerElement,\n  DropdownMenuSubTriggerProps\n>((props: ScopedProps<DropdownMenuSubTriggerProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subTriggerProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.SubTrigger {...menuScope} {...subTriggerProps} ref={forwardedRef} />;\n});\n\nDropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'DropdownMenuSubContent';\n\ntype DropdownMenuSubContentElement = React.ComponentRef<typeof MenuPrimitive.Content>;\ntype MenuSubContentProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.SubContent>;\ninterface DropdownMenuSubContentProps extends MenuSubContentProps {}\n\nconst DropdownMenuSubContent = React.forwardRef<\n  DropdownMenuSubContentElement,\n  DropdownMenuSubContentProps\n>((props: ScopedProps<DropdownMenuSubContentProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subContentProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n\n  return (\n    <MenuPrimitive.SubContent\n      {...menuScope}\n      {...subContentProps}\n      ref={forwardedRef}\n      style={{\n        ...props.style,\n        // re-namespace exposed content custom properties\n        ...{\n          '--radix-dropdown-menu-content-transform-origin': 'var(--radix-popper-transform-origin)',\n          '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',\n          '--radix-dropdown-menu-content-available-height': 'var(--radix-popper-available-height)',\n          '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',\n          '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',\n        },\n      }}\n    />\n  );\n});\n\nDropdownMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = DropdownMenu;\nconst Trigger = DropdownMenuTrigger;\nconst Portal = DropdownMenuPortal;\nconst Content = DropdownMenuContent;\nconst Group = DropdownMenuGroup;\nconst Label = DropdownMenuLabel;\nconst Item = DropdownMenuItem;\nconst CheckboxItem = DropdownMenuCheckboxItem;\nconst RadioGroup = DropdownMenuRadioGroup;\nconst RadioItem = DropdownMenuRadioItem;\nconst ItemIndicator = DropdownMenuItemIndicator;\nconst Separator = DropdownMenuSeparator;\nconst Arrow = DropdownMenuArrow;\nconst Sub = DropdownMenuSub;\nconst SubTrigger = DropdownMenuSubTrigger;\nconst SubContent = DropdownMenuSubContent;\n\nexport {\n  createDropdownMenuScope,\n  //\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuPortal,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuLabel,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n  DropdownMenuItemIndicator,\n  DropdownMenuSeparator,\n  DropdownMenuArrow,\n  DropdownMenuSub,\n  DropdownMenuSubTrigger,\n  DropdownMenuSubContent,\n  //\n  Root,\n  Trigger,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  DropdownMenuProps,\n  DropdownMenuTriggerProps,\n  DropdownMenuPortalProps,\n  DropdownMenuContentProps,\n  DropdownMenuGroupProps,\n  DropdownMenuLabelProps,\n  DropdownMenuItemProps,\n  DropdownMenuCheckboxItemProps,\n  DropdownMenuRadioGroupProps,\n  DropdownMenuRadioItemProps,\n  DropdownMenuItemIndicatorProps,\n  DropdownMenuSeparatorProps,\n  DropdownMenuArrowProps,\n  DropdownMenuSubProps,\n  DropdownMenuSubTriggerProps,\n  DropdownMenuSubContentProps,\n};\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { createSlot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ComponentRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ComponentRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst Slot = createSlot('MenuContent.ScrollLock');\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus({ preventScroll: true });\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n                preventScrollOnEntryFocus\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ComponentRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ComponentRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus({ preventScroll: true });\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ComponentRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ComponentRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ComponentRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ComponentRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0]! : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const ii = polygon[i]!;\n    const jj = polygon[j]!;\n    const xi = ii.x;\n    const yi = ii.y;\n    const xj = jj.x;\n    const yj = jj.y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>\u2026</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\nimport type { EntryOf } from './ordered-dictionary';\nimport { OrderedDict } from './ordered-dictionary';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\ninterface BaseItemData {\n  id?: string;\n}\n\ntype ItemDataWithElement<\n  ItemData extends BaseItemData,\n  ItemElement extends HTMLElement,\n> = ItemData & {\n  element: ItemElement;\n};\n\ntype ItemMap<ItemElement extends HTMLElement, ItemData extends BaseItemData> = OrderedDict<\n  ItemElement,\n  ItemDataWithElement<ItemData, ItemElement>\n>;\n\nfunction createCollection<\n  ItemElement extends HTMLElement,\n  ItemData extends BaseItemData = BaseItemData,\n>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionElement: CollectionElement | null;\n    collectionRef: React.Ref<CollectionElement | null>;\n    collectionRefObject: React.RefObject<CollectionElement | null>;\n    itemMap: ItemMap<ItemElement, ItemData>;\n    setItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>;\n  };\n\n  const [CollectionContextProvider, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    {\n      collectionElement: null,\n      collectionRef: { current: null },\n      collectionRefObject: { current: null },\n      itemMap: new OrderedDict(),\n      setItemMap: () => void 0,\n    }\n  );\n\n  type CollectionState = [\n    ItemMap: ItemMap<ItemElement, ItemData>,\n    SetItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>,\n  ];\n\n  const CollectionProvider: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state?: CollectionState;\n  }> = ({ state, ...props }) => {\n    return state ? (\n      <CollectionProviderImpl {...props} state={state} />\n    ) : (\n      <CollectionInit {...props} />\n    );\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  const CollectionInit: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n  }> = (props) => {\n    const state = useInitCollection();\n    return <CollectionProviderImpl {...props} state={state} />;\n  };\n  CollectionInit.displayName = PROVIDER_NAME + 'Init';\n\n  const CollectionProviderImpl: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state: CollectionState;\n  }> = (props) => {\n    const { scope, children, state } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const [collectionElement, setCollectionElement] = React.useState<CollectionElement | null>(\n      null\n    );\n    const composeRefs = useComposedRefs(ref, setCollectionElement);\n    const [itemMap, setItemMap] = state;\n\n    React.useEffect(() => {\n      if (!collectionElement) return;\n\n      const observer = getChildListObserver(() => {\n        // setItemMap((map) => {\n        //   const copy = new OrderedDict(map).toSorted(([, a], [, b]) =>\n        //     !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1\n        //   );\n        //   // check if the order has changed\n        //   let index = -1;\n        //   for (const entry of copy) {\n        //     index++;\n        //     const key = map.keyAt(index)!;\n        //     const [copyKey] = entry;\n        //     if (key !== copyKey) {\n        //       // order has changed!\n        //       return copy;\n        //     }\n        //   }\n        //   return map;\n        // });\n      });\n      observer.observe(collectionElement, {\n        childList: true,\n        subtree: true,\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [collectionElement]);\n\n    return (\n      <CollectionContextProvider\n        scope={scope}\n        itemMap={itemMap}\n        setItemMap={setItemMap}\n        collectionRef={composeRefs}\n        collectionRefObject={ref}\n        collectionElement={collectionElement}\n      >\n        {children}\n      </CollectionContextProvider>\n    );\n  };\n\n  CollectionProviderImpl.displayName = PROVIDER_NAME + 'Impl';\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const [element, setElement] = React.useState<ItemElement | null>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref, setElement);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      const { setItemMap } = context;\n\n      const itemDataRef = React.useRef(itemData);\n      if (!shallowEqual(itemDataRef.current, itemData)) {\n        itemDataRef.current = itemData;\n      }\n      const memoizedItemData = itemDataRef.current;\n\n      React.useEffect(() => {\n        const itemData = memoizedItemData;\n        setItemMap((map) => {\n          if (!element) {\n            return map;\n          }\n\n          if (!map.has(element)) {\n            map.set(element, { ...(itemData as unknown as ItemData), element });\n            return map.toSorted(sortByDocumentPosition);\n          }\n\n          return map\n            .set(element, { ...(itemData as unknown as ItemData), element })\n            .toSorted(sortByDocumentPosition);\n        });\n\n        return () => {\n          setItemMap((map) => {\n            if (!element || !map.has(element)) {\n              return map;\n            }\n            map.delete(element);\n            return new OrderedDict(map);\n          });\n        };\n      }, [element, memoizedItemData, setItemMap]);\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs as any}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useInitCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useInitCollection() {\n    return React.useState<ItemMap<ItemElement, ItemData>>(new OrderedDict());\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const { itemMap } = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    return itemMap;\n  }\n\n  const functions = {\n    createCollectionScope,\n    useCollection,\n    useInitCollection,\n  };\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    functions,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n\nfunction shallowEqual(a: any, b: any) {\n  if (a === b) return true;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a == null || b == null) return false;\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (a[key] !== b[key]) return false;\n  }\n  return true;\n}\n\nfunction isElementPreceding(a: Element, b: Element) {\n  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);\n}\n\nfunction sortByDocumentPosition<E extends HTMLElement, T extends BaseItemData>(\n  a: EntryOf<ItemMap<E, T>>,\n  b: EntryOf<ItemMap<E, T>>\n) {\n  return !a[1].element || !b[1].element\n    ? 0\n    : isElementPreceding(a[1].element, b[1].element)\n      ? -1\n      : 1;\n}\n\nfunction getChildListObserver(callback: () => void) {\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'childList') {\n        callback();\n        return;\n      }\n    }\n  });\n\n  return observer;\n}\n", "// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n", "import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n", "import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    React.useEffect(() => {\n      // Consumer can anchor the popper to something that isn't\n      // a DOM node e.g. pointer position, so we override the\n      // `anchorRef` with their virtual ref in this case.\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ComponentRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n", "import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import { computePosition, arrow as arrow$2, autoPlacement as autoPlacement$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1 } from '@floating-ui/dom';\nexport { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\nvar isClient = typeof document !== 'undefined';\n\nvar noop = function noop() {};\nvar index = isClient ? useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$2({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow$2({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => ({\n  ...offset$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => ({\n  ...shift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => ({\n  ...limitShift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => ({\n  ...flip$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => ({\n  ...size$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => ({\n  ...autoPlacement$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => ({\n  ...hide$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => ({\n  ...inline$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n\nexport { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };\n", "import * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Arrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Arrow';\n\ntype ArrowElement = React.ComponentRef<typeof Primitive.svg>;\ntype PrimitiveSvgProps = React.ComponentPropsWithoutRef<typeof Primitive.svg>;\ninterface ArrowProps extends PrimitiveSvgProps {}\n\nconst Arrow = React.forwardRef<ArrowElement, ArrowProps>((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return (\n    <Primitive.svg\n      {...arrowProps}\n      ref={forwardedRef}\n      width={width}\n      height={height}\n      viewBox=\"0 0 30 10\"\n      preserveAspectRatio=\"none\"\n    >\n      {/* We use their children if they're slotting to replace the whole svg */}\n      {props.asChild ? children : <polygon points=\"0,0 30,0 15,10\" />}\n    </Primitive.svg>\n  );\n});\n\nArrow.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Arrow;\n\nexport {\n  Arrow,\n  //\n  Root,\n};\nexport type { ArrowProps };\n", "/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nfunction useSize(element: HTMLElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  useLayoutEffect(() => {\n    if (element) {\n      // provide size as early as possible\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate it ourselves to get the correct border box.\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => resizeObserver.unobserve(element);\n    } else {\n      // We only want to reset to `undefined` when the element becomes `null`,\n      // not if it changes to another element.\n      setSize(undefined);\n    }\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends Omit<PrimitiveSpanProps, 'children'> {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { hasTabStop: boolean; isCurrentTabStop: boolean }) => React.ReactNode);\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        >\n          {typeof children === 'function'\n            ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null })\n            : children}\n        </Primitive.span>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '1.36.1';\nexport const TARGETED_RPC_VERSION = '1.53.0';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst CODE_TO_ERROR_TYPE: Record<number, string> = {\n\t'-32700': 'ParseError',\n\t'-32701': 'OversizedRequest',\n\t'-32702': 'OversizedResponse',\n\t'-32600': 'InvalidRequest',\n\t'-32601': 'MethodNotFound',\n\t'-32602': 'InvalidParams',\n\t'-32603': 'InternalError',\n\t'-32604': 'ServerBusy',\n\t'-32000': 'CallExecutionFailed',\n\t'-32001': 'UnknownError',\n\t'-32003': 'SubscriptionClosed',\n\t'-32004': 'SubscriptionClosedWithError',\n\t'-32005': 'BatchesNotSupported',\n\t'-32006': 'TooManySubscriptions',\n\t'-32050': 'TransientError',\n\t'-32002': 'TransactionExecutionClientError',\n};\n\nexport class SuiHTTPTransportError extends Error {}\n\nexport class JsonRpcError extends SuiHTTPTransportError {\n\tcode: number;\n\ttype: string;\n\n\tconstructor(message: string, code: number) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.type = CODE_TO_ERROR_TYPE[code] ?? 'ServerError';\n\t}\n}\n\nexport class SuiHTTPStatusError extends SuiHTTPTransportError {\n\tstatus: number;\n\tstatusText: string;\n\n\tconstructor(message: string, status: number, statusText: string) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.statusText = statusText;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JsonRpcError } from './errors.js';\n\nfunction getWebsocketUrl(httpUrl: string): string {\n\tconst url = new URL(httpUrl);\n\turl.protocol = url.protocol.replace('http', 'ws');\n\treturn url.toString();\n}\n\ntype JsonRpcMessage =\n\t| {\n\t\t\tid: number;\n\t\t\tresult: never;\n\t\t\terror: {\n\t\t\t\tcode: number;\n\t\t\t\tmessage: string;\n\t\t\t};\n\t  }\n\t| {\n\t\t\tid: number;\n\t\t\tresult: unknown;\n\t\t\terror: never;\n\t  }\n\t| {\n\t\t\tmethod: string;\n\t\t\tparams: NotificationMessageParams;\n\t  };\n\ntype NotificationMessageParams = {\n\tsubscription?: number;\n\tresult: object;\n};\n\ntype SubscriptionRequest<T = any> = {\n\tmethod: string;\n\tunsubscribe: string;\n\tparams: any[];\n\tonMessage: (event: T) => void;\n\tsignal?: AbortSignal;\n};\n\n/**\n * Configuration options for the websocket connection\n */\nexport type WebsocketClientOptions = {\n\t/**\n\t * Custom WebSocket class to use. Defaults to the global WebSocket class, if available.\n\t */\n\tWebSocketConstructor?: typeof WebSocket;\n\t/**\n\t * Milliseconds before timing out while calling an RPC method\n\t */\n\tcallTimeout?: number;\n\t/**\n\t * Milliseconds between attempts to connect\n\t */\n\treconnectTimeout?: number;\n\t/**\n\t * Maximum number of times to try connecting before giving up\n\t */\n\tmaxReconnects?: number;\n};\n\nexport const DEFAULT_CLIENT_OPTIONS = {\n\t// We fudge the typing because we also check for undefined in the constructor:\n\tWebSocketConstructor: (typeof WebSocket !== 'undefined'\n\t\t? WebSocket\n\t\t: undefined) as typeof WebSocket,\n\tcallTimeout: 30000,\n\treconnectTimeout: 3000,\n\tmaxReconnects: 5,\n} satisfies WebsocketClientOptions;\n\nexport class WebsocketClient {\n\tendpoint: string;\n\toptions: Required<WebsocketClientOptions>;\n\t#requestId = 0;\n\t#disconnects = 0;\n\t#webSocket: WebSocket | null = null;\n\t#connectionPromise: Promise<WebSocket> | null = null;\n\t#subscriptions = new Set<RpcSubscription>();\n\t#pendingRequests = new Map<\n\t\tnumber,\n\t\t{\n\t\t\tresolve: (result: Extract<JsonRpcMessage, { id: number }>) => void;\n\t\t\treject: (reason: unknown) => void;\n\t\t\ttimeout: ReturnType<typeof setTimeout>;\n\t\t}\n\t>();\n\n\tconstructor(endpoint: string, options: WebsocketClientOptions = {}) {\n\t\tthis.endpoint = endpoint;\n\t\tthis.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };\n\n\t\tif (!this.options.WebSocketConstructor) {\n\t\t\tthrow new Error('Missing WebSocket constructor');\n\t\t}\n\n\t\tif (this.endpoint.startsWith('http')) {\n\t\t\tthis.endpoint = getWebsocketUrl(this.endpoint);\n\t\t}\n\t}\n\n\tasync makeRequest<T>(method: string, params: any[], signal?: AbortSignal): Promise<T> {\n\t\tconst webSocket = await this.#setupWebSocket();\n\n\t\treturn new Promise<Extract<JsonRpcMessage, { id: number }>>((resolve, reject) => {\n\t\t\tthis.#requestId += 1;\n\t\t\tthis.#pendingRequests.set(this.#requestId, {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject,\n\t\t\t\ttimeout: setTimeout(() => {\n\t\t\t\t\tthis.#pendingRequests.delete(this.#requestId);\n\t\t\t\t\treject(new Error(`Request timeout: ${method}`));\n\t\t\t\t}, this.options.callTimeout),\n\t\t\t});\n\n\t\t\tsignal?.addEventListener('abort', () => {\n\t\t\t\tthis.#pendingRequests.delete(this.#requestId);\n\t\t\t\treject(signal.reason);\n\t\t\t});\n\n\t\t\twebSocket.send(JSON.stringify({ jsonrpc: '2.0', id: this.#requestId, method, params }));\n\t\t}).then(({ error, result }) => {\n\t\t\tif (error) {\n\t\t\t\tthrow new JsonRpcError(error.message, error.code);\n\t\t\t}\n\n\t\t\treturn result as T;\n\t\t});\n\t}\n\n\t#setupWebSocket() {\n\t\tif (this.#connectionPromise) {\n\t\t\treturn this.#connectionPromise;\n\t\t}\n\n\t\tthis.#connectionPromise = new Promise<WebSocket>((resolve) => {\n\t\t\tthis.#webSocket?.close();\n\t\t\tthis.#webSocket = new this.options.WebSocketConstructor(this.endpoint);\n\n\t\t\tthis.#webSocket.addEventListener('open', () => {\n\t\t\t\tthis.#disconnects = 0;\n\t\t\t\tresolve(this.#webSocket!);\n\t\t\t});\n\n\t\t\tthis.#webSocket.addEventListener('close', () => {\n\t\t\t\tthis.#disconnects++;\n\t\t\t\tif (this.#disconnects <= this.options.maxReconnects) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.#reconnect();\n\t\t\t\t\t}, this.options.reconnectTimeout);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.#webSocket.addEventListener('message', ({ data }: { data: string }) => {\n\t\t\t\tlet json: JsonRpcMessage;\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(data) as JsonRpcMessage;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ('id' in json && json.id != null && this.#pendingRequests.has(json.id)) {\n\t\t\t\t\tconst { resolve, timeout } = this.#pendingRequests.get(json.id)!;\n\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\tresolve(json);\n\t\t\t\t} else if ('params' in json) {\n\t\t\t\t\tconst { params } = json;\n\t\t\t\t\tthis.#subscriptions.forEach((subscription) => {\n\t\t\t\t\t\tif (subscription.subscriptionId === params.subscription)\n\t\t\t\t\t\t\tif (params.subscription === subscription.subscriptionId) {\n\t\t\t\t\t\t\t\tsubscription.onMessage(params.result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn this.#connectionPromise;\n\t}\n\n\tasync #reconnect() {\n\t\tthis.#webSocket?.close();\n\t\tthis.#connectionPromise = null;\n\n\t\treturn Promise.allSettled(\n\t\t\t[...this.#subscriptions].map((subscription) => subscription.subscribe(this)),\n\t\t);\n\t}\n\n\tasync subscribe<T>(input: SubscriptionRequest<T>) {\n\t\tconst subscription = new RpcSubscription(input);\n\t\tthis.#subscriptions.add(subscription);\n\t\tawait subscription.subscribe(this);\n\t\treturn () => subscription.unsubscribe(this);\n\t}\n}\n\nclass RpcSubscription {\n\tsubscriptionId: number | null = null;\n\tinput: SubscriptionRequest<any>;\n\tsubscribed = false;\n\n\tconstructor(input: SubscriptionRequest) {\n\t\tthis.input = input;\n\t}\n\n\tonMessage(message: unknown) {\n\t\tif (this.subscribed) {\n\t\t\tthis.input.onMessage(message);\n\t\t}\n\t}\n\n\tasync unsubscribe(client: WebsocketClient) {\n\t\tconst { subscriptionId } = this;\n\t\tthis.subscribed = false;\n\t\tif (subscriptionId == null) return false;\n\t\tthis.subscriptionId = null;\n\n\t\treturn client.makeRequest(this.input.unsubscribe, [subscriptionId]);\n\t}\n\n\tasync subscribe(client: WebsocketClient) {\n\t\tthis.subscriptionId = null;\n\t\tthis.subscribed = true;\n\t\tconst newSubscriptionId = await client.makeRequest<number>(\n\t\t\tthis.input.method,\n\t\t\tthis.input.params,\n\t\t\tthis.input.signal,\n\t\t);\n\n\t\tif (this.subscribed) {\n\t\t\tthis.subscriptionId = newSubscriptionId;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PACKAGE_VERSION, TARGETED_RPC_VERSION } from '../version.js';\nimport { JsonRpcError, SuiHTTPStatusError } from './errors.js';\nimport type { WebsocketClientOptions } from './rpc-websocket-client.js';\nimport { WebsocketClient } from './rpc-websocket-client.js';\n\n/**\n * An object defining headers to be passed to the RPC server\n */\nexport type HttpHeaders = { [header: string]: string };\n\nexport interface SuiHTTPTransportOptions {\n\tfetch?: typeof fetch;\n\tWebSocketConstructor?: typeof WebSocket;\n\turl: string;\n\trpc?: {\n\t\theaders?: HttpHeaders;\n\t\turl?: string;\n\t};\n\twebsocket?: WebsocketClientOptions & {\n\t\turl?: string;\n\t};\n}\n\nexport interface SuiTransportRequestOptions {\n\tmethod: string;\n\tparams: unknown[];\n\tsignal?: AbortSignal;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport interface SuiTransportSubscribeOptions<T> {\n\tmethod: string;\n\tunsubscribe: string;\n\tparams: unknown[];\n\tonMessage: (event: T) => void;\n\tsignal?: AbortSignal;\n}\n\nexport interface SuiTransport {\n\trequest<T = unknown>(input: SuiTransportRequestOptions): Promise<T>;\n\tsubscribe<T = unknown>(input: SuiTransportSubscribeOptions<T>): Promise<() => Promise<boolean>>;\n}\n\nexport class SuiHTTPTransport implements SuiTransport {\n\t#requestId = 0;\n\t#options: SuiHTTPTransportOptions;\n\t#websocketClient?: WebsocketClient;\n\n\tconstructor(options: SuiHTTPTransportOptions) {\n\t\tthis.#options = options;\n\t}\n\n\tfetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n\t\tconst fetchFn = this.#options.fetch ?? fetch;\n\n\t\tif (!fetchFn) {\n\t\t\tthrow new Error(\n\t\t\t\t'The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.',\n\t\t\t);\n\t\t}\n\n\t\treturn fetchFn(input, init);\n\t}\n\n\t#getWebsocketClient(): WebsocketClient {\n\t\tif (!this.#websocketClient) {\n\t\t\tconst WebSocketConstructor = this.#options.WebSocketConstructor ?? WebSocket;\n\t\t\tif (!WebSocketConstructor) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.#websocketClient = new WebsocketClient(\n\t\t\t\tthis.#options.websocket?.url ?? this.#options.url,\n\t\t\t\t{\n\t\t\t\t\tWebSocketConstructor,\n\t\t\t\t\t...this.#options.websocket,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\treturn this.#websocketClient;\n\t}\n\n\tasync request<T>(input: SuiTransportRequestOptions): Promise<T> {\n\t\tthis.#requestId += 1;\n\n\t\tconst res = await this.fetch(this.#options.rpc?.url ?? this.#options.url, {\n\t\t\tmethod: 'POST',\n\t\t\tsignal: input.signal,\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t'Client-Sdk-Type': 'typescript',\n\t\t\t\t'Client-Sdk-Version': PACKAGE_VERSION,\n\t\t\t\t'Client-Target-Api-Version': TARGETED_RPC_VERSION,\n\t\t\t\t'Client-Request-Method': input.method,\n\t\t\t\t...this.#options.rpc?.headers,\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tjsonrpc: '2.0',\n\t\t\t\tid: this.#requestId,\n\t\t\t\tmethod: input.method,\n\t\t\t\tparams: input.params,\n\t\t\t}),\n\t\t});\n\n\t\tif (!res.ok) {\n\t\t\tthrow new SuiHTTPStatusError(\n\t\t\t\t`Unexpected status code: ${res.status}`,\n\t\t\t\tres.status,\n\t\t\t\tres.statusText,\n\t\t\t);\n\t\t}\n\n\t\tconst data = await res.json();\n\n\t\tif ('error' in data && data.error != null) {\n\t\t\tthrow new JsonRpcError(data.error.message, data.error.code);\n\t\t}\n\n\t\treturn data.result;\n\t}\n\n\tasync subscribe<T>(input: SuiTransportSubscribeOptions<T>): Promise<() => Promise<boolean>> {\n\t\tconst unsubscribe = await this.#getWebsocketClient().subscribe(input);\n\n\t\tif (input.signal) {\n\t\t\tinput.signal.throwIfAborted();\n\t\t\tinput.signal.addEventListener('abort', () => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\n\t\treturn async () => !!(await unsubscribe());\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function getFullnodeUrl(network: 'mainnet' | 'testnet' | 'devnet' | 'localnet') {\n\tswitch (network) {\n\t\tcase 'mainnet':\n\t\t\treturn 'https://fullnode.mainnet.sui.io:443';\n\t\tcase 'testnet':\n\t\t\treturn 'https://fullnode.testnet.sui.io:443';\n\t\tcase 'devnet':\n\t\t\treturn 'https://fullnode.devnet.sui.io:443';\n\t\tcase 'localnet':\n\t\t\treturn 'http://127.0.0.1:9000';\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown network: ${network}`);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface ClientCacheOptions {\n\tprefix?: string[];\n\tcache?: Map<string, unknown>;\n}\n\nexport class ClientCache {\n\t#prefix: string[];\n\t#cache: Map<string, unknown>;\n\n\tconstructor({ prefix, cache }: ClientCacheOptions = {}) {\n\t\tthis.#prefix = prefix ?? [];\n\t\tthis.#cache = cache ?? new Map();\n\t}\n\n\tread<T>(key: [string, ...string[]], load: () => T | Promise<T>): T | Promise<T> {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\tif (typeof result === 'object' && result !== null && 'then' in result) {\n\t\t\treturn Promise.resolve(result)\n\t\t\t\t.then((v) => {\n\t\t\t\t\tthis.#cache.set(cacheKey, v);\n\t\t\t\t\treturn v as T;\n\t\t\t\t})\n\t\t\t\t.catch((err) => {\n\t\t\t\t\tthis.#cache.delete(cacheKey);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t}\n\n\t\treturn result as T;\n\t}\n\n\treadSync<T>(key: [string, ...string[]], load: () => T): T {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\treturn result as T;\n\t}\n\n\tclear(prefix?: string[]) {\n\t\tconst prefixKey = [...this.#prefix, ...(prefix ?? [])].join(':');\n\t\tif (!prefixKey) {\n\t\t\tthis.#cache.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const key of this.#cache.keys()) {\n\t\t\tif (key.startsWith(prefixKey)) {\n\t\t\t\tthis.#cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tscope(prefix: string | string[]) {\n\t\treturn new ClientCache({\n\t\t\tprefix: [...this.#prefix, ...(Array.isArray(prefix) ? prefix : [prefix])],\n\t\t\tcache: this.#cache,\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n/* eslint-disable @typescript-eslint/ban-types */\n\nimport type { Simplify, UnionToIntersection } from '@mysten/utils';\nimport { ClientCache } from './cache.js';\nimport type { Experimental_CoreClient } from './core.js';\nimport type {\n\tClientWithExtensions,\n\tExperimental_SuiClientTypes,\n\tSuiClientRegistration,\n} from './types.js';\n\nexport abstract class Experimental_BaseClient {\n\tnetwork: Experimental_SuiClientTypes.Network;\n\tcache: ClientCache;\n\tbase: Experimental_BaseClient;\n\n\tconstructor({\n\t\tnetwork,\n\t\tbase,\n\t\tcache = base?.cache ?? new ClientCache(),\n\t}: Experimental_SuiClientTypes.SuiClientOptions) {\n\t\tthis.network = network;\n\t\tthis.base = base ?? this;\n\t\tthis.cache = cache;\n\t}\n\n\tabstract core: Experimental_CoreClient;\n\n\t$extend<const Registrations extends SuiClientRegistration<this>[]>(\n\t\t...registrations: Registrations\n\t) {\n\t\treturn Object.create(\n\t\t\tthis,\n\t\t\tObject.fromEntries(\n\t\t\t\tregistrations.map((registration) => {\n\t\t\t\t\tif ('experimental_asClientExtension' in registration) {\n\t\t\t\t\t\tconst { name, register } = registration.experimental_asClientExtension();\n\t\t\t\t\t\treturn [name, { value: register(this) }];\n\t\t\t\t\t}\n\t\t\t\t\treturn [registration.name, { value: registration.register(this) }];\n\t\t\t\t}),\n\t\t\t),\n\t\t) as ClientWithExtensions<\n\t\t\tSimplify<\n\t\t\t\tUnionToIntersection<\n\t\t\t\t\t{\n\t\t\t\t\t\t[K in keyof Registrations]: Registrations[K] extends SuiClientRegistration<\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tinfer Name extends string,\n\t\t\t\t\t\t\tinfer Extension\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t[K2 in Name]: Extension;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: never;\n\t\t\t\t\t}[number]\n\t\t\t\t>\n\t\t\t>,\n\t\t\tthis\n\t\t>;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcheck,\n\tinteger,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\nimport type { Simplify } from '@mysten/utils';\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n\tEnumInputShape<\n\t\tSimplify<{\n\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t}>\n\t>,\n\tEnumOutputShape<\n\t\tSimplify<{\n\t\t\t[K in keyof T]: InferOutput<T[K]>;\n\t\t}>\n\t>\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn pipe(\n\t\tunion(unionOptions),\n\t\ttransform((value) => ({\n\t\t\t...value,\n\t\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t\t})),\n\t) as EnumSchema<T>;\n}\n\nexport const SuiAddress = pipe(\n\tstring(),\n\ttransform((value) => normalizeSuiAddress(value)),\n\tcheck(isValidSuiAddress),\n);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n\tunion([string(), pipe(number(), integer())]),\n\n\tcheck((val) => {\n\t\ttry {\n\t\t\tBigInt(val);\n\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, 'Invalid u64'),\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRef>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const Argument = pipe(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n\t\tobject({ Result: pipe(number(), integer()) }),\n\t\tobject({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n\t]),\n\ttransform((value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof Argument>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\nexport type GasData = InferOutput<typeof GasData>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTag>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: GenericSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(lazy(() => OpenMoveTypeSignatureBody)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignature>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\nexport type CallArg = InferOutput<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n});\nexport type TransactionData = InferOutput<typeof TransactionData>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { AsyncTransactionThunk, Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof Argument>\n\t| ((tx: Transaction) => InferInput<typeof Argument>)\n\t| AsyncTransactionThunk;\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof Argument>[],\n\t\taddress: InferInput<typeof Argument>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(Argument, o)),\n\t\t\t\taddress: parse(Argument, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof Argument>,\n\t\tamounts: InferInput<typeof Argument>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(Argument, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof Argument>,\n\t\tsources: InferInput<typeof Argument>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(Argument, destination),\n\t\t\t\tsources: sources.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof Argument>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(Argument, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof Argument>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(Argument, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value) ? value.map((o) => parse(Argument, o)) : parse(Argument, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tbigint,\n\tboolean,\n\tcheck,\n\tinteger,\n\tis,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tparse,\n\tpipe,\n\tstring,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n\tdigest: string(),\n\tobjectId: string(),\n\tversion: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n\tImmOrOwned: ObjectRef,\n\tShared: object({\n\t\tobjectId: ObjectID,\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: literal('pure'),\n\t}),\n]);\n\nconst TransactionExpiration = union([\n\tobject({ Epoch: pipe(number(), integer()) }),\n\tobject({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n\tunion([number(), string(), bigint()]),\n\tcheck((val) => {\n\t\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\t\ttry {\n\t\t\tBigInt(val as string);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n\tobject({ bool: nullable(literal(true)) }),\n\tobject({ u8: nullable(literal(true)) }),\n\tobject({ u64: nullable(literal(true)) }),\n\tobject({ u128: nullable(literal(true)) }),\n\tobject({ address: nullable(literal(true)) }),\n\tobject({ signer: nullable(literal(true)) }),\n\tobject({ vector: lazy(() => TypeTag) }),\n\tobject({ struct: lazy(() => StructTag) }),\n\tobject({ u16: nullable(literal(true)) }),\n\tobject({ u32: nullable(literal(true)) }),\n\tobject({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\ttypeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(ObjectRef)),\n\towner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n\tTransactionInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: pipe(number(), integer()) }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: pipe(number(), integer()),\n\t\tresultIndex: pipe(number(), integer()),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: pipe(\n\t\tstring(),\n\t\tcheck((target) => target.split('::').length === 3),\n\t) as GenericSchema<`${string}::${string}::${string}`>,\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\ttype: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n\tobjects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: nullish(TransactionExpiration),\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionInput),\n\ttransactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n\ttransactionData: TransactionData,\n): SerializedTransactionDataV1 {\n\tconst inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n\t\t(input, index) => {\n\t\t\tif (input.Object) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tObject: input.Object.ImmOrOwnedObject\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tImmOrOwned: input.Object.ImmOrOwnedObject,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: input.Object.Receiving\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\t\tdigest: input.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\t\tversion: input.Object.Receiving.version,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tShared: {\n\t\t\t\t\t\t\t\t\t\t\tmutable: input.Object.SharedObject.mutable,\n\t\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.SharedObject.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'object',\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (input.Pure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tPure: Array.from(fromBase64(input.Pure.bytes)),\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedPure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedPure.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedObject) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedObject.objectId,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t},\n\t);\n\n\treturn {\n\t\tversion: 1,\n\t\tsender: transactionData.sender ?? undefined,\n\t\texpiration:\n\t\t\ttransactionData.expiration?.$kind === 'Epoch'\n\t\t\t\t? { Epoch: Number(transactionData.expiration.Epoch) }\n\t\t\t\t: transactionData.expiration\n\t\t\t\t\t? { None: true }\n\t\t\t\t\t: null,\n\t\tgasConfig: {\n\t\t\towner: transactionData.gasData.owner ?? undefined,\n\t\t\tbudget: transactionData.gasData.budget ?? undefined,\n\t\t\tprice: transactionData.gasData.price ?? undefined,\n\t\t\tpayment: transactionData.gasData.payment ?? undefined,\n\t\t},\n\t\tinputs,\n\t\ttransactions: transactionData.commands.map((command): InferOutput<typeof TransactionType> => {\n\t\t\tif (command.MakeMoveVec) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\t\ttype:\n\t\t\t\t\t\tcommand.MakeMoveVec.type === null\n\t\t\t\t\t\t\t? { None: true }\n\t\t\t\t\t\t\t: { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n\t\t\t\t\tobjects: command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MergeCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MergeCoins',\n\t\t\t\t\tdestination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n\t\t\t\t\tsources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MoveCall) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MoveCall',\n\t\t\t\t\ttarget: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n\t\t\t\t\ttypeArguments: command.MoveCall.typeArguments,\n\t\t\t\t\targuments: command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.Publish) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Publish',\n\t\t\t\t\tmodules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Publish.dependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.SplitCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'SplitCoins',\n\t\t\t\t\tcoin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n\t\t\t\t\tamounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.TransferObjects) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'TransferObjects',\n\t\t\t\t\tobjects: command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t\taddress: convertTransactionArgument(command.TransferObjects.address, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.Upgrade) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Upgrade',\n\t\t\t\t\tmodules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Upgrade.dependencies,\n\t\t\t\t\tpackageId: command.Upgrade.package,\n\t\t\t\t\tticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(command)}`);\n\t\t}),\n\t};\n}\n\nfunction convertTransactionArgument(\n\targ: Argument,\n\tinputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n\tif (arg.$kind === 'GasCoin') {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\tif (arg.$kind === 'Result') {\n\t\treturn { kind: 'Result', index: arg.Result };\n\t}\n\tif (arg.$kind === 'NestedResult') {\n\t\treturn { kind: 'NestedResult', index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n\t}\n\tif (arg.$kind === 'Input') {\n\t\treturn inputs[arg.Input];\n\t}\n\n\tthrow new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n\treturn parse(TransactionData, {\n\t\tversion: 2,\n\t\tsender: data.sender ?? null,\n\t\texpiration: data.expiration\n\t\t\t? 'Epoch' in data.expiration\n\t\t\t\t? { Epoch: data.expiration.Epoch }\n\t\t\t\t: { None: true }\n\t\t\t: null,\n\t\tgasData: {\n\t\t\towner: data.gasConfig.owner ?? null,\n\t\t\tbudget: data.gasConfig.budget?.toString() ?? null,\n\t\t\tprice: data.gasConfig.price?.toString() ?? null,\n\t\t\tpayment:\n\t\t\t\tdata.gasConfig.payment?.map((ref) => ({\n\t\t\t\t\tdigest: ref.digest,\n\t\t\t\t\tobjectId: ref.objectId,\n\t\t\t\t\tversion: ref.version.toString(),\n\t\t\t\t})) ?? null,\n\t\t},\n\t\tinputs: data.inputs.map((input) => {\n\t\t\tif (input.kind === 'Input') {\n\t\t\t\tif (is(NormalizedCallArg, input.value)) {\n\t\t\t\t\tconst value = parse(NormalizedCallArg, input.value);\n\n\t\t\t\t\tif (value.Object) {\n\t\t\t\t\t\tif (value.Object.ImmOrOwned) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.ImmOrOwned.objectId,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.ImmOrOwned.version),\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.ImmOrOwned.digest,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Shared) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tSharedObject: {\n\t\t\t\t\t\t\t\t\t\tmutable: value.Object.Shared.mutable ?? null,\n\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: value.Object.Shared.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Shared.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Receiving) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.Receiving.version),\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error('Invalid object input');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: toBase64(new Uint8Array(value.Pure)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'object') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: input.value as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tUnresolvedPure: {\n\t\t\t\t\t\tvalue: input.value,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t}),\n\t\tcommands: data.transactions.map((transaction) => {\n\t\t\tswitch (transaction.kind) {\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMakeMoveVec: {\n\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t'Some' in transaction.type\n\t\t\t\t\t\t\t\t\t? TypeTagSerializer.tagToString(transaction.type.Some)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\telements: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\tcase 'MergeCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMergeCoins: {\n\t\t\t\t\t\t\tdestination: parseV1TransactionArgument(transaction.destination),\n\t\t\t\t\t\t\tsources: transaction.sources.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'MoveCall': {\n\t\t\t\t\tconst [pkg, mod, fn] = transaction.target.split('::');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMoveCall: {\n\t\t\t\t\t\t\tpackage: pkg,\n\t\t\t\t\t\t\tmodule: mod,\n\t\t\t\t\t\t\tfunction: fn,\n\t\t\t\t\t\t\ttypeArguments: transaction.typeArguments,\n\t\t\t\t\t\t\targuments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Publish': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPublish: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'SplitCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tSplitCoins: {\n\t\t\t\t\t\t\tcoin: parseV1TransactionArgument(transaction.coin),\n\t\t\t\t\t\t\tamounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'TransferObjects': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tTransferObjects: {\n\t\t\t\t\t\t\tobjects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t\taddress: parseV1TransactionArgument(transaction.address),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Upgrade': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUpgrade: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t\tpackage: transaction.packageId,\n\t\t\t\t\t\t\tticket: parseV1TransactionArgument(transaction.ticket),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(transaction)}`);\n\t\t}),\n\t} satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n\targ: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n\tswitch (arg.kind) {\n\t\tcase 'GasCoin': {\n\t\t\treturn { GasCoin: true };\n\t\t}\n\t\tcase 'Result':\n\t\t\treturn { Result: arg.index };\n\t\tcase 'NestedResult': {\n\t\t\treturn { NestedResult: [arg.index, arg.resultIndex] };\n\t\t}\n\t\tcase 'Input': {\n\t\t\treturn { Input: arg.index };\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, SuiAddress } from './internal.js';\nimport type { Simplify } from '@mysten/utils';\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n\treturn union(\n\t\tObject.entries(options).map(([key, value]) => object({ [key]: value })),\n\t) as GenericSchema<\n\t\tEnumInputShape<\n\t\t\tSimplify<{\n\t\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t\t}>\n\t\t>\n\t>;\n}\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n\tGasCoin: literal(true),\n\tInput: pipe(number(), integer()),\n\tResult: pipe(number(), integer()),\n\tNestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRef)),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n});\n\nconst $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n\tImmOrOwnedObject: ObjectRef,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t}),\n});\n\nconst TransactionExpiration = enumUnion({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2 = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n\tdigest: optional(nullable(string())),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n\treturn {\n\t\t$kind: 'Pure',\n\t\tPure: {\n\t\t\tbytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n\t\t},\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'ImmOrOwnedObject',\n\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({\n\t\tobjectId,\n\t\tmutable,\n\t\tinitialSharedVersion,\n\t}: {\n\t\tobjectId: string;\n\t\tmutable: boolean;\n\t\tinitialSharedVersion: number | string;\n\t}): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'SharedObject',\n\t\t\t\tSharedObject: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'Receiving',\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n\tconst struct =\n\t\ttypeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n\treturn (\n\t\t!!struct &&\n\t\tnormalizeSuiAddress(struct.package) === normalizeSuiAddress('0x2') &&\n\t\tstruct.module === 'tx_context' &&\n\t\tstruct.type === 'TxContext'\n\t);\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\tif (typeSignature.vector === 'u8') {\n\t\t\treturn bcs.vector(bcs.U8).transform({\n\t\t\t\tinput: (val: string | Uint8Array) =>\n\t\t\t\t\ttypeof val === 'string' ? new TextEncoder().encode(val) : val,\n\t\t\t\toutput: (val) => val,\n\t\t\t});\n\t\t}\n\t\tconst type = getPureBcsSchema(typeSignature.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t}\n\n\tif ('datatype' in typeSignature) {\n\t\tconst pkg = normalizeSuiAddress(typeSignature.datatype.package);\n\n\t\tif (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n\t\t\t) {\n\t\t\t\tconst type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) &&\n\t\t\ttypeSignature.datatype.module === OBJECT_MODULE_NAME &&\n\t\t\ttypeSignature.datatype.type === ID_STRUCT_NAME\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignature {\n\tif (typeof type === 'object' && 'Reference' in type) {\n\t\treturn {\n\t\t\tref: '&',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n\t\t};\n\t}\n\tif (typeof type === 'object' && 'MutableReference' in type) {\n\t\treturn {\n\t\t\tref: '&mut',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n\t\t};\n\t}\n\n\treturn {\n\t\tref: null,\n\t\tbody: normalizedTypeToMoveTypeSignatureBody(type),\n\t};\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n\t}\n\n\tif ('Struct' in type) {\n\t\treturn {\n\t\t\tdatatype: {\n\t\t\t\tpackage: type.Struct.address,\n\t\t\t\tmodule: type.Struct.module,\n\t\t\t\ttype: type.Struct.name,\n\t\t\t\ttypeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody),\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\treturn { typeParameter: type.TypeParameter };\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n\ttypeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\treturn bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n\t}\n\n\tthrow new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../../utils/index.js';\nimport { ObjectRef } from '../../transactions/data/internal.js';\nimport type { CallArg, Command, OpenMoveTypeSignature } from '../../transactions/data/internal.js';\nimport { Inputs } from '../../transactions/Inputs.js';\nimport {\n\tgetPureBcsSchema,\n\tisTxContext,\n\tnormalizedTypeToMoveTypeSignature,\n} from '../../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { SuiClient } from '../../client/index.js';\nimport type { BuildTransactionOptions } from '../../transactions/index.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport function suiClientResolveTransactionPlugin(client: SuiClient) {\n\treturn async function resolveTransactionData(\n\t\ttransactionData: TransactionDataBuilder,\n\t\toptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) {\n\t\tawait normalizeInputs(transactionData, client);\n\t\tawait resolveObjectReferences(transactionData, client);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait setGasPrice(transactionData, client);\n\t\t\tawait setGasBudget(transactionData, client);\n\t\t\tawait setGasPayment(transactionData, client);\n\t\t}\n\n\t\treturn await next();\n\t};\n}\n\nasync function setGasPrice(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await client.dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await client.getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));\n\t}\n}\n\nasync function resolveObjectReferences(transactionData: TransactionDataBuilder, client: SuiClient) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tclient.multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? 'Shared' in owner\n\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t: 'ConsensusAddressOwner' in owner\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.start_version\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: SuiClient) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) => input?.UnresolvedPure || input?.UnresolvedObject,\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\n\nimport type { ClientWithCoreApi } from '../experimental/index.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\nimport type { BcsType } from '@mysten/bcs';\nimport { Inputs } from './Inputs.js';\nimport { bcs } from '../bcs/index.js';\nimport { suiClientResolveTransactionPlugin } from '../experimental/transports/json-rpc-resolver.js';\nimport type { SuiClient } from '../client/index.js';\n\nexport interface BuildTransactionOptions {\n\tclient?: ClientWithCoreApi;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport function needsTransactionResolution(\n\tdata: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n): boolean {\n\tif (\n\t\tdata.inputs.some((input) => {\n\t\t\treturn input.UnresolvedObject || input.UnresolvedPure;\n\t\t})\n\t) {\n\t\treturn true;\n\t}\n\n\tif (!options.onlyTransactionKind) {\n\t\tif (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function resolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tnormalizeRawArguments(transactionData);\n\tif (!needsTransactionResolution(transactionData, options)) {\n\t\tawait validate(transactionData);\n\t\treturn next();\n\t}\n\n\tconst client = getClient(options);\n\tconst plugin =\n\t\tclient.core?.resolveTransactionPlugin() ??\n\t\tsuiClientResolveTransactionPlugin(client as SuiClient);\n\n\treturn plugin(transactionData, options, async () => {\n\t\tawait validate(transactionData);\n\t\tawait next();\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction normalizeRawArguments(transactionData: TransactionDataBuilder) {\n\tfor (const command of transactionData.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n\tfunction object(value: TransactionObjectInput) {\n\t\treturn makeObject(value);\n\t}\n\n\tobject.system = () => object('0x5');\n\tobject.clock = () => object('0x6');\n\tobject.random = () => object('0x8');\n\tobject.denyList = () => object('0x403');\n\tobject.option =\n\t\t({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.moveCall({\n\t\t\t\ttypeArguments: [type],\n\t\t\t\ttarget: `0x1::option::${value === null ? 'none' : 'some'}`,\n\t\t\t\targuments: value === null ? [] : [tx.object(value)],\n\t\t\t});\n\n\treturn object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<T extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<T> : T,\n\t\tvalue: ShapeFromPureTypeName<T>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(index: number, replacement: Command | Command[], resultIndex = index) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\t\tthis.commands.splice(index, 1, ...replacement);\n\n\t\tif (sizeDiff !== 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result === index) {\n\t\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] === index) {\n\t\t\t\t\t\t\targ.NestedResult[0] = resultIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionData, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { is } from 'valibot';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg } from './data/internal.js';\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\n\tif (arg.Object) {\n\t\tif (arg.Object.ImmOrOwnedObject) {\n\t\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\n\t\tif (arg.Object.Receiving) {\n\t\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t\t}\n\n\t\treturn normalizeSuiAddress(arg.Object.SharedObject.objectId);\n\t}\n\n\tif (arg.UnresolvedObject) {\n\t\treturn normalizeSuiAddress(arg.UnresolvedObject.objectId);\n\t}\n\n\treturn undefined;\n}\n\nexport function isArgument(value: unknown): value is Argument {\n\treturn is(Argument, value);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { Experimental_SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements Experimental_SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: Experimental_SuiClientTypes.MvrResolvePackageOptions): Promise<Experimental_SuiClientTypes.MvrResolvePackageResponse> {\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: Experimental_SuiClientTypes.MvrResolveTypeOptions): Promise<Experimental_SuiClientTypes.MvrResolveTypeResponse> {\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: Experimental_SuiClientTypes.MvrResolveOptions): Promise<Experimental_SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: Experimental_SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '../../experimental/cache.js';\nimport { MvrClient } from '../../experimental/mvr.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\nimport { findNamesInTransaction, replaceNames } from '../../experimental/mvr.js';\nimport type { NamedPackagesOverrides } from '../../experimental/mvr.js';\n\nexport type NamedPackagesPluginOptions = {\n\t/**\n\t * The URL of the MVR API to use for resolving names.\n\t */\n\turl: string;\n\t/**\n\t * The number of names to resolve in each batch request.\n\t * Needs to be calculated based on the GraphQL query limits.\n\t */\n\tpageSize?: number;\n\t/**\n\t * Local overrides for the resolution plugin. Pass this to pre-populate\n\t * the cache with known packages / types (especially useful for local or CI testing).\n\t *\n\t * The type cache expects ONLY first-level types to ensure the cache is more composable.\n\t *\n\t * \tExpected format example:\n\t *  {\n\t * \t\tpackages: {\n\t * \t\t\t'@framework/std': '0x1234',\n\t * \t\t},\n\t * \t\ttypes: {\n\t * \t\t\t'@framework/std::string::String': '0x1234::string::String',\n\t * \t\t},\n\t * \t}\n\t *\n\t */\n\toverrides?: NamedPackagesOverrides;\n};\n\n// The original versions of the mvr plugin cached lookups by mutating overrides.\n// We don't want to mutate the options, but we can link our cache to the provided overrides object\n// This preserves the caching across transactions while removing the mutation side effects\nconst cacheMap = new WeakMap<object, ClientCache>();\n\n/**\n * @experimental This plugin is in experimental phase and there might be breaking changes in the future\n *\n * Adds named resolution so that you can use .move names in your transactions.\n * e.g. `@org/app::type::Type` will be resolved to `0x1234::type::Type`.\n * This plugin will resolve all names & types in the transaction block.\n *\n * To install this plugin globally in your app, use:\n * ```\n * Transaction.registerGlobalSerializationPlugin(\"namedPackagesPlugin\", namedPackagesPlugin({ suiGraphQLClient }));\n * ```\n *\n * You can also define `overrides` to pre-populate name resolutions locally (removes the GraphQL request).\n */\nexport const namedPackagesPlugin = (options?: NamedPackagesPluginOptions) => {\n\tlet mvrClient: MvrClient | undefined;\n\n\tif (options) {\n\t\tconst overrides = options.overrides ?? {\n\t\t\tpackages: {},\n\t\t\ttypes: {},\n\t\t};\n\n\t\tif (!cacheMap.has(overrides)) {\n\t\t\tcacheMap.set(overrides, new ClientCache());\n\t\t}\n\n\t\tmvrClient = new MvrClient({\n\t\t\tcache: cacheMap.get(overrides)!,\n\t\t\turl: options.url,\n\t\t\tpageSize: options.pageSize,\n\t\t\toverrides: overrides,\n\t\t});\n\t}\n\n\treturn async (\n\t\ttransactionData: TransactionDataBuilder,\n\t\tbuildOptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) => {\n\t\tconst names = findNamesInTransaction(transactionData);\n\n\t\tif (names.types.length === 0 && names.packages.length === 0) {\n\t\t\treturn next();\n\t\t}\n\n\t\tconst resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n\t\t\ttypes: names.types,\n\t\t\tpackages: names.packages,\n\t\t});\n\n\t\treplaceNames(transactionData, resolved);\n\n\t\tawait next();\n\t};\n};\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SuiClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n\t| ((tx: Transaction) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch (e) {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | Transaction) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = new TransactionDataBuilder(transaction.getData());\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(Argument, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(Argument, resolved);\n\t\t}\n\n\t\treturn parse(Argument, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#data.commands.some((cmd) => cmd.$Intent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\tconst createNext = (i: number) => {\n\t\t\tif (i >= plugins.length) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\t\t\tconst plugin = plugins[i];\n\n\t\t\treturn async () => {\n\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\tlet calledNext = false;\n\t\t\t\tlet nextResolved = false;\n\n\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\tawait next();\n\n\t\t\t\t\tnextResolved = true;\n\t\t\t\t});\n\n\t\t\t\tif (!calledNext) {\n\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t}\n\n\t\t\t\tif (!nextResolved) {\n\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tawait createNext(0)();\n\n\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\tthis.#commandSection = this.#data.commands.slice();\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TypeTagSerializer } from '../bcs/type-tag-serializer.js';\nimport type { TransactionPlugin } from '../transactions/index.js';\nimport { deriveDynamicFieldID } from '../utils/dynamic-fields.js';\nimport { normalizeStructTag, parseStructTag, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { Experimental_BaseClient } from './client.js';\nimport type { ClientWithExtensions, Experimental_SuiClientTypes } from './types.js';\nimport { MvrClient } from './mvr.js';\n\nexport type ClientWithCoreApi = ClientWithExtensions<{\n\tcore: Experimental_CoreClient;\n}>;\n\nexport interface Experimental_CoreClientOptions\n\textends Experimental_SuiClientTypes.SuiClientOptions {\n\tbase: Experimental_BaseClient;\n\tmvr?: Experimental_SuiClientTypes.MvrOptions;\n}\n\nconst DEFAULT_MVR_URLS: Record<string, string> = {\n\tmainnet: 'https://mainnet.mvr.mystenlabs.com',\n\ttestnet: 'https://testnet.mvr.mystenlabs.com',\n};\n\nexport abstract class Experimental_CoreClient\n\textends Experimental_BaseClient\n\timplements Experimental_SuiClientTypes.TransportMethods\n{\n\tcore = this;\n\tmvr: Experimental_SuiClientTypes.MvrMethods;\n\n\tconstructor(options: Experimental_CoreClientOptions) {\n\t\tsuper(options);\n\n\t\tthis.mvr = new MvrClient({\n\t\t\tcache: this.cache.scope('core.mvr'),\n\t\t\turl: options.mvr?.url ?? DEFAULT_MVR_URLS[this.network],\n\t\t\tpageSize: options.mvr?.pageSize,\n\t\t\toverrides: options.mvr?.overrides,\n\t\t});\n\t}\n\n\tabstract getObjects(\n\t\toptions: Experimental_SuiClientTypes.GetObjectsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetObjectsResponse>;\n\n\tasync getObject(\n\t\toptions: Experimental_SuiClientTypes.GetObjectOptions,\n\t): Promise<Experimental_SuiClientTypes.GetObjectResponse> {\n\t\tconst { objectId } = options;\n\t\tconst {\n\t\t\tobjects: [result],\n\t\t} = await this.getObjects({ objectIds: [objectId], signal: options.signal });\n\t\tif (result instanceof Error) {\n\t\t\tthrow result;\n\t\t}\n\t\treturn { object: result };\n\t}\n\n\tabstract getCoins(\n\t\toptions: Experimental_SuiClientTypes.GetCoinsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetCoinsResponse>;\n\n\tabstract getOwnedObjects(\n\t\toptions: Experimental_SuiClientTypes.GetOwnedObjectsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetOwnedObjectsResponse>;\n\n\tabstract getBalance(\n\t\toptions: Experimental_SuiClientTypes.GetBalanceOptions,\n\t): Promise<Experimental_SuiClientTypes.GetBalanceResponse>;\n\n\tabstract getAllBalances(\n\t\toptions: Experimental_SuiClientTypes.GetAllBalancesOptions,\n\t): Promise<Experimental_SuiClientTypes.GetAllBalancesResponse>;\n\n\tabstract getTransaction(\n\t\toptions: Experimental_SuiClientTypes.GetTransactionOptions,\n\t): Promise<Experimental_SuiClientTypes.GetTransactionResponse>;\n\n\tabstract executeTransaction(\n\t\toptions: Experimental_SuiClientTypes.ExecuteTransactionOptions,\n\t): Promise<Experimental_SuiClientTypes.ExecuteTransactionResponse>;\n\n\tabstract dryRunTransaction(\n\t\toptions: Experimental_SuiClientTypes.DryRunTransactionOptions,\n\t): Promise<Experimental_SuiClientTypes.DryRunTransactionResponse>;\n\n\tabstract getReferenceGasPrice(\n\t\toptions?: Experimental_SuiClientTypes.GetReferenceGasPriceOptions,\n\t): Promise<Experimental_SuiClientTypes.GetReferenceGasPriceResponse>;\n\n\tabstract getDynamicFields(\n\t\toptions: Experimental_SuiClientTypes.GetDynamicFieldsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetDynamicFieldsResponse>;\n\n\tabstract resolveTransactionPlugin(): TransactionPlugin;\n\n\tabstract verifyZkLoginSignature(\n\t\toptions: Experimental_SuiClientTypes.VerifyZkLoginSignatureOptions,\n\t): Promise<Experimental_SuiClientTypes.ZkLoginVerifyResponse>;\n\n\tasync getDynamicField(\n\t\toptions: Experimental_SuiClientTypes.GetDynamicFieldOptions,\n\t): Promise<Experimental_SuiClientTypes.GetDynamicFieldResponse> {\n\t\tconst fieldId = deriveDynamicFieldID(\n\t\t\toptions.parentId,\n\t\t\tTypeTagSerializer.parseFromStr(options.name.type),\n\t\t\toptions.name.bcs,\n\t\t);\n\t\tconst {\n\t\t\tobjects: [fieldObject],\n\t\t} = await this.getObjects({\n\t\t\tobjectIds: [fieldId],\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\tif (fieldObject instanceof Error) {\n\t\t\tthrow fieldObject;\n\t\t}\n\n\t\tconst fieldType = parseStructTag(fieldObject.type);\n\t\tconst content = await fieldObject.content;\n\n\t\treturn {\n\t\t\tdynamicField: {\n\t\t\t\tid: fieldObject.id,\n\t\t\t\tdigest: fieldObject.digest,\n\t\t\t\tversion: fieldObject.version,\n\t\t\t\ttype: fieldObject.type,\n\t\t\t\tname: {\n\t\t\t\t\ttype:\n\t\t\t\t\t\ttypeof fieldType.typeParams[0] === 'string'\n\t\t\t\t\t\t\t? fieldType.typeParams[0]\n\t\t\t\t\t\t\t: normalizeStructTag(fieldType.typeParams[0]),\n\t\t\t\t\tbcs: options.name.bcs,\n\t\t\t\t},\n\t\t\t\tvalue: {\n\t\t\t\t\ttype:\n\t\t\t\t\t\ttypeof fieldType.typeParams[1] === 'string'\n\t\t\t\t\t\t\t? fieldType.typeParams[1]\n\t\t\t\t\t\t\t: normalizeStructTag(fieldType.typeParams[1]),\n\t\t\t\t\tbcs: content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\tasync waitForTransaction({\n\t\tsignal,\n\t\ttimeout = 60 * 1000,\n\t\t...input\n\t}: {\n\t\t/** An optional abort signal that can be used to cancel the wait. */\n\t\tsignal?: AbortSignal;\n\t\t/** The amount of time to wait for transaction. Defaults to one minute. */\n\t\ttimeout?: number;\n\t} & Experimental_SuiClientTypes.GetTransactionOptions): Promise<Experimental_SuiClientTypes.GetTransactionResponse> {\n\t\tconst abortSignal = signal\n\t\t\t? AbortSignal.any([AbortSignal.timeout(timeout), signal])\n\t\t\t: AbortSignal.timeout(timeout);\n\n\t\tconst abortPromise = new Promise((_, reject) => {\n\t\t\tabortSignal.addEventListener('abort', () => reject(abortSignal.reason));\n\t\t});\n\n\t\tabortPromise.catch(() => {\n\t\t\t// Swallow unhandled rejections that might be thrown after early return\n\t\t});\n\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tabortSignal.throwIfAborted();\n\t\t\ttry {\n\t\t\t\treturn await this.getTransaction({\n\t\t\t\t\t...input,\n\t\t\t\t\tsignal: abortSignal,\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tawait Promise.race([new Promise((resolve) => setTimeout(resolve, 2_000)), abortPromise]);\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ObjectResponseError } from '../client/index.js';\n\nexport class SuiClientError extends Error {}\n\nexport class ObjectError extends SuiClientError {\n\tcode: string;\n\n\tconstructor(code: string, message: string) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t}\n\n\tstatic fromResponse(response: ObjectResponseError, objectId?: string): ObjectError {\n\t\tswitch (response.code) {\n\t\t\tcase 'notExists':\n\t\t\t\treturn new ObjectError(response.code, `Object ${response.object_id} does not exist`);\n\t\t\tcase 'dynamicFieldNotFound':\n\t\t\t\treturn new ObjectError(\n\t\t\t\t\tresponse.code,\n\t\t\t\t\t`Dynamic field not found for object ${response.parent_object_id}`,\n\t\t\t\t);\n\t\t\tcase 'deleted':\n\t\t\t\treturn new ObjectError(response.code, `Object ${response.object_id} has been deleted`);\n\t\t\tcase 'displayError':\n\t\t\t\treturn new ObjectError(response.code, `Display error: ${response.error}`);\n\t\t\tcase 'unknown':\n\t\t\tdefault:\n\t\t\t\treturn new ObjectError(\n\t\t\t\t\tresponse.code,\n\t\t\t\t\t`Unknown error while loading object${objectId ? ` ${objectId}` : ''}`,\n\t\t\t\t);\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../../bcs/index.js';\nimport { TransactionDataBuilder } from '../../transactions/TransactionData.js';\nimport type { Experimental_SuiClientTypes } from '../types.js';\n\nexport function parseTransactionBcs(\n\tbytes: Uint8Array,\n): Experimental_SuiClientTypes.TransactionResponse['transaction'] {\n\treturn {\n\t\t...TransactionDataBuilder.fromBytes(bytes).snapshot(),\n\t\tbcs: bytes,\n\t};\n}\n\nexport function parseTransactionEffectsBcs(\n\teffects: Uint8Array,\n): Experimental_SuiClientTypes.TransactionEffects {\n\tconst parsed = bcs.TransactionEffects.parse(effects);\n\n\tswitch (parsed.$kind) {\n\t\tcase 'V1':\n\t\t\treturn parseTransactionEffectsV1({ bytes: effects, effects: parsed.V1 });\n\t\tcase 'V2':\n\t\t\treturn parseTransactionEffectsV2({ bytes: effects, effects: parsed.V2 });\n\t\tdefault:\n\t\t\tthrow new Error(\n\t\t\t\t`Unknown transaction effects version: ${(parsed as { $kind: string }).$kind}`,\n\t\t\t);\n\t}\n}\n\nfunction parseTransactionEffectsV1(_: {\n\tbytes: Uint8Array;\n\teffects: NonNullable<(typeof bcs.TransactionEffects.$inferType)['V1']>;\n}): Experimental_SuiClientTypes.TransactionEffects {\n\tthrow new Error('V1 effects are not supported yet');\n}\n\nfunction parseTransactionEffectsV2({\n\tbytes,\n\teffects,\n}: {\n\tbytes: Uint8Array;\n\teffects: NonNullable<(typeof bcs.TransactionEffects.$inferType)['V2']>;\n}): Experimental_SuiClientTypes.TransactionEffects {\n\tconst changedObjects = effects.changedObjects.map(\n\t\t([id, change]): Experimental_SuiClientTypes.ChangedObject => {\n\t\t\treturn {\n\t\t\t\tid,\n\t\t\t\tinputState: change.inputState.$kind === 'Exist' ? 'Exists' : 'DoesNotExist',\n\t\t\t\tinputVersion: change.inputState.Exist?.[0][0] ?? null,\n\t\t\t\tinputDigest: change.inputState.Exist?.[0][1] ?? null,\n\t\t\t\tinputOwner: change.inputState.Exist?.[1] ?? null,\n\t\t\t\toutputState:\n\t\t\t\t\tchange.outputState.$kind === 'NotExist' ? 'DoesNotExist' : change.outputState.$kind,\n\t\t\t\toutputVersion:\n\t\t\t\t\tchange.outputState.$kind === 'PackageWrite'\n\t\t\t\t\t\t? change.outputState.PackageWrite?.[0]\n\t\t\t\t\t\t: change.outputState.ObjectWrite\n\t\t\t\t\t\t\t? effects.lamportVersion\n\t\t\t\t\t\t\t: null,\n\t\t\t\toutputDigest:\n\t\t\t\t\tchange.outputState.$kind === 'PackageWrite'\n\t\t\t\t\t\t? change.outputState.PackageWrite?.[1]\n\t\t\t\t\t\t: (change.outputState.ObjectWrite?.[0] ?? null),\n\t\t\t\toutputOwner: change.outputState.ObjectWrite ? change.outputState.ObjectWrite[1] : null,\n\t\t\t\tidOperation: change.idOperation.$kind,\n\t\t\t};\n\t\t},\n\t);\n\n\treturn {\n\t\tbcs: bytes,\n\t\tdigest: effects.transactionDigest,\n\t\tversion: 2,\n\t\tstatus:\n\t\t\teffects.status.$kind === 'Success'\n\t\t\t\t? {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\t// TODO: add command\n\t\t\t\t\t\terror: effects.status.Failed.error.$kind,\n\t\t\t\t\t},\n\t\tgasUsed: effects.gasUsed,\n\t\ttransactionDigest: effects.transactionDigest,\n\t\tgasObject:\n\t\t\teffects.gasObjectIndex === null ? null : (changedObjects[effects.gasObjectIndex] ?? null),\n\t\teventsDigest: effects.eventsDigest,\n\t\tdependencies: effects.dependencies,\n\t\tlamportVersion: effects.lamportVersion,\n\t\tchangedObjects,\n\t\tunchangedSharedObjects: effects.unchangedSharedObjects.map(\n\t\t\t([objectId, object]): Experimental_SuiClientTypes.UnchangedSharedObject => {\n\t\t\t\treturn {\n\t\t\t\t\tkind: object.$kind,\n\t\t\t\t\tobjectId: objectId,\n\t\t\t\t\tversion:\n\t\t\t\t\t\tobject.$kind === 'ReadOnlyRoot'\n\t\t\t\t\t\t\t? object.ReadOnlyRoot[0]\n\t\t\t\t\t\t\t: (object[object.$kind] as string | null),\n\t\t\t\t\tdigest: object.$kind === 'ReadOnlyRoot' ? object.ReadOnlyRoot[1] : null,\n\t\t\t\t};\n\t\t\t},\n\t\t),\n\t\tauxiliaryDataDigest: effects.auxDataDigest,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\n\nimport { bcs } from '../../bcs/index.js';\nimport type {\n\tObjectOwner,\n\tSuiClient,\n\tSuiObjectChange,\n\tSuiObjectData,\n\tSuiTransactionBlockResponse,\n\tTransactionEffects,\n} from '../../client/index.js';\nimport { Transaction } from '../../transactions/Transaction.js';\nimport { Experimental_CoreClient } from '../core.js';\nimport { ObjectError } from '../errors.js';\nimport type { Experimental_SuiClientTypes } from '../types.js';\nimport { parseTransactionBcs, parseTransactionEffectsBcs } from './utils.js';\nimport { suiClientResolveTransactionPlugin } from './json-rpc-resolver.js';\nimport { TransactionDataBuilder } from '../../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\n\nexport class JSONRpcTransport extends Experimental_CoreClient {\n\t#jsonRpcClient: SuiClient;\n\n\tconstructor({\n\t\tjsonRpcClient,\n\t\tmvr,\n\t}: {\n\t\tjsonRpcClient: SuiClient;\n\t\tmvr?: Experimental_SuiClientTypes.MvrOptions;\n\t}) {\n\t\tsuper({ network: jsonRpcClient.network, base: jsonRpcClient, mvr });\n\t\tthis.#jsonRpcClient = jsonRpcClient;\n\t}\n\n\tasync getObjects(options: Experimental_SuiClientTypes.GetObjectsOptions) {\n\t\tconst batches = chunk(options.objectIds, 50);\n\t\tconst results: Experimental_SuiClientTypes.GetObjectsResponse['objects'] = [];\n\n\t\tfor (const batch of batches) {\n\t\t\tconst objects = await this.#jsonRpcClient.multiGetObjects({\n\t\t\t\tids: batch,\n\t\t\t\toptions: {\n\t\t\t\t\tshowOwner: true,\n\t\t\t\t\tshowType: true,\n\t\t\t\t\tshowBcs: true,\n\t\t\t\t},\n\t\t\t\tsignal: options.signal,\n\t\t\t});\n\n\t\t\tfor (const [idx, object] of objects.entries()) {\n\t\t\t\tif (object.error) {\n\t\t\t\t\tresults.push(ObjectError.fromResponse(object.error, batch[idx]));\n\t\t\t\t} else {\n\t\t\t\t\tresults.push(parseObject(object.data!));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tobjects: results,\n\t\t};\n\t}\n\tasync getOwnedObjects(options: Experimental_SuiClientTypes.GetOwnedObjectsOptions) {\n\t\tconst objects = await this.#jsonRpcClient.getOwnedObjects({\n\t\t\towner: options.address,\n\t\t\tlimit: options.limit,\n\t\t\tcursor: options.cursor,\n\t\t\toptions: {\n\t\t\t\tshowOwner: true,\n\t\t\t\tshowType: true,\n\t\t\t\tshowBcs: true,\n\t\t\t},\n\t\t\tfilter: options.type ? { StructType: options.type } : null,\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\treturn {\n\t\t\tobjects: objects.data.map((result) => {\n\t\t\t\tif (result.error) {\n\t\t\t\t\tthrow ObjectError.fromResponse(result.error);\n\t\t\t\t}\n\n\t\t\t\treturn parseObject(result.data!);\n\t\t\t}),\n\t\t\thasNextPage: objects.hasNextPage,\n\t\t\tcursor: objects.nextCursor ?? null,\n\t\t};\n\t}\n\n\tasync getCoins(options: Experimental_SuiClientTypes.GetCoinsOptions) {\n\t\tconst coins = await this.#jsonRpcClient.getCoins({\n\t\t\towner: options.address,\n\t\t\tcoinType: options.coinType,\n\t\t\tlimit: options.limit,\n\t\t\tcursor: options.cursor,\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\treturn {\n\t\t\tobjects: coins.data.map((coin) => {\n\t\t\t\treturn {\n\t\t\t\t\tid: coin.coinObjectId,\n\t\t\t\t\tversion: coin.version,\n\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\tbalance: coin.balance,\n\t\t\t\t\ttype: `0x2::coin::Coin<${coin.coinType}>`,\n\t\t\t\t\tcontent: Promise.resolve(\n\t\t\t\t\t\tCoin.serialize({\n\t\t\t\t\t\t\tid: coin.coinObjectId,\n\t\t\t\t\t\t\tbalance: {\n\t\t\t\t\t\t\t\tvalue: coin.balance,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}).toBytes(),\n\t\t\t\t\t),\n\t\t\t\t\towner: {\n\t\t\t\t\t\t$kind: 'ObjectOwner' as const,\n\t\t\t\t\t\tObjectOwner: options.address,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}),\n\t\t\thasNextPage: coins.hasNextPage,\n\t\t\tcursor: coins.nextCursor ?? null,\n\t\t};\n\t}\n\n\tasync getBalance(options: Experimental_SuiClientTypes.GetBalanceOptions) {\n\t\tconst balance = await this.#jsonRpcClient.getBalance({\n\t\t\towner: options.address,\n\t\t\tcoinType: options.coinType,\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\treturn {\n\t\t\tbalance: {\n\t\t\t\tcoinType: balance.coinType,\n\t\t\t\tbalance: balance.totalBalance,\n\t\t\t},\n\t\t};\n\t}\n\tasync getAllBalances(options: Experimental_SuiClientTypes.GetAllBalancesOptions) {\n\t\tconst balances = await this.#jsonRpcClient.getAllBalances({\n\t\t\towner: options.address,\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\treturn {\n\t\t\tbalances: balances.map((balance) => ({\n\t\t\t\tcoinType: balance.coinType,\n\t\t\t\tbalance: balance.totalBalance,\n\t\t\t})),\n\t\t\thasNextPage: false,\n\t\t\tcursor: null,\n\t\t};\n\t}\n\tasync getTransaction(options: Experimental_SuiClientTypes.GetTransactionOptions) {\n\t\tconst transaction = await this.#jsonRpcClient.getTransactionBlock({\n\t\t\tdigest: options.digest,\n\t\t\toptions: {\n\t\t\t\tshowRawInput: true,\n\t\t\t\tshowObjectChanges: true,\n\t\t\t\tshowRawEffects: true,\n\t\t\t\tshowEvents: true,\n\t\t\t\tshowEffects: true,\n\t\t\t},\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: parseTransaction(transaction),\n\t\t};\n\t}\n\tasync executeTransaction(options: Experimental_SuiClientTypes.ExecuteTransactionOptions) {\n\t\tconst transaction = await this.#jsonRpcClient.executeTransactionBlock({\n\t\t\ttransactionBlock: options.transaction,\n\t\t\tsignature: options.signatures,\n\t\t\toptions: {\n\t\t\t\tshowRawEffects: true,\n\t\t\t\tshowEvents: true,\n\t\t\t\tshowObjectChanges: true,\n\t\t\t\tshowRawInput: true,\n\t\t\t\tshowEffects: true,\n\t\t\t},\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: parseTransaction(transaction),\n\t\t};\n\t}\n\tasync dryRunTransaction(options: Experimental_SuiClientTypes.DryRunTransactionOptions) {\n\t\tconst tx = Transaction.from(options.transaction);\n\t\tconst result = await this.#jsonRpcClient.dryRunTransactionBlock({\n\t\t\ttransactionBlock: options.transaction,\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\tconst { effects, objectTypes } = parseTransactionEffectsJson({\n\t\t\teffects: result.effects,\n\t\t\tobjectChanges: result.objectChanges,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: {\n\t\t\t\tdigest: await tx.getDigest(),\n\t\t\t\tepoch: null,\n\t\t\t\teffects,\n\t\t\t\tobjectTypes: Promise.resolve(objectTypes),\n\t\t\t\tsignatures: [],\n\t\t\t\ttransaction: parseTransactionBcs(options.transaction),\n\t\t\t},\n\t\t};\n\t}\n\tasync getReferenceGasPrice(options?: Experimental_SuiClientTypes.GetReferenceGasPriceOptions) {\n\t\tconst referenceGasPrice = await this.#jsonRpcClient.getReferenceGasPrice({\n\t\t\tsignal: options?.signal,\n\t\t});\n\t\treturn {\n\t\t\treferenceGasPrice: String(referenceGasPrice),\n\t\t};\n\t}\n\n\tasync getDynamicFields(options: Experimental_SuiClientTypes.GetDynamicFieldsOptions) {\n\t\tconst dynamicFields = await this.#jsonRpcClient.getDynamicFields({\n\t\t\tparentId: options.parentId,\n\t\t\tlimit: options.limit,\n\t\t\tcursor: options.cursor,\n\t\t});\n\n\t\treturn {\n\t\t\tdynamicFields: dynamicFields.data.map((dynamicField) => {\n\t\t\t\treturn {\n\t\t\t\t\tid: dynamicField.objectId,\n\t\t\t\t\ttype: dynamicField.objectType,\n\t\t\t\t\tname: {\n\t\t\t\t\t\ttype: dynamicField.name.type,\n\t\t\t\t\t\tbcs: fromBase64(dynamicField.bcsName),\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}),\n\t\t\thasNextPage: dynamicFields.hasNextPage,\n\t\t\tcursor: dynamicFields.nextCursor,\n\t\t};\n\t}\n\n\tasync verifyZkLoginSignature(options: Experimental_SuiClientTypes.VerifyZkLoginSignatureOptions) {\n\t\tconst result = await this.#jsonRpcClient.verifyZkLoginSignature({\n\t\t\tbytes: options.bytes,\n\t\t\tsignature: options.signature,\n\t\t\tintentScope: options.intentScope,\n\t\t\tauthor: options.author,\n\t\t});\n\n\t\treturn {\n\t\t\tsuccess: result.success,\n\t\t\terrors: result.errors,\n\t\t};\n\t}\n\n\tresolveNameServiceNames(\n\t\toptions: Experimental_SuiClientTypes.ResolveNameServiceNamesOptions,\n\t): Promise<Experimental_SuiClientTypes.ResolveNameServiceNamesResponse> {\n\t\treturn this.#jsonRpcClient.resolveNameServiceNames(options);\n\t}\n\n\tresolveTransactionPlugin() {\n\t\treturn suiClientResolveTransactionPlugin(this.#jsonRpcClient);\n\t}\n}\n\nfunction parseObject(object: SuiObjectData): Experimental_SuiClientTypes.ObjectResponse {\n\treturn {\n\t\tid: object.objectId,\n\t\tversion: object.version,\n\t\tdigest: object.digest,\n\t\ttype: object.type!,\n\t\tcontent: Promise.resolve(\n\t\t\tobject.bcs?.dataType === 'moveObject' ? fromBase64(object.bcs.bcsBytes) : new Uint8Array(),\n\t\t),\n\t\towner: parseOwner(object.owner!),\n\t};\n}\n\nfunction parseOwner(owner: ObjectOwner): Experimental_SuiClientTypes.ObjectOwner {\n\tif (owner === 'Immutable') {\n\t\treturn {\n\t\t\t$kind: 'Immutable',\n\t\t\tImmutable: true,\n\t\t};\n\t}\n\n\tif ('ConsensusAddressOwner' in owner) {\n\t\treturn {\n\t\t\t$kind: 'ConsensusAddressOwner',\n\t\t\tConsensusAddressOwner: {\n\t\t\t\towner: owner.ConsensusAddressOwner.owner,\n\t\t\t\tstartVersion: owner.ConsensusAddressOwner.start_version,\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('AddressOwner' in owner) {\n\t\treturn {\n\t\t\t$kind: 'AddressOwner',\n\t\t\tAddressOwner: owner.AddressOwner,\n\t\t};\n\t}\n\n\tif ('ObjectOwner' in owner) {\n\t\treturn {\n\t\t\t$kind: 'ObjectOwner',\n\t\t\tObjectOwner: owner.ObjectOwner,\n\t\t};\n\t}\n\n\tif ('Shared' in owner) {\n\t\treturn {\n\t\t\t$kind: 'Shared',\n\t\t\tShared: {\n\t\t\t\tinitialSharedVersion: owner.Shared.initial_shared_version,\n\t\t\t},\n\t\t};\n\t}\n\n\tthrow new Error(`Unknown owner type: ${JSON.stringify(owner)}`);\n}\n\nfunction parseTransaction(\n\ttransaction: SuiTransactionBlockResponse,\n): Experimental_SuiClientTypes.TransactionResponse {\n\tconst parsedTx = bcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction!))[0];\n\tconst objectTypes: Record<string, string> = {};\n\n\ttransaction.objectChanges?.forEach((change) => {\n\t\tif (change.type !== 'published') {\n\t\t\tobjectTypes[change.objectId] = change.objectType;\n\t\t}\n\t});\n\n\tconst bytes = bcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes();\n\n\tconst data = TransactionDataBuilder.restore({\n\t\tversion: 2,\n\t\tsender: parsedTx.intentMessage.value.V1.sender,\n\t\texpiration: parsedTx.intentMessage.value.V1.expiration,\n\t\tgasData: parsedTx.intentMessage.value.V1.gasData,\n\t\tinputs: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction!.inputs,\n\t\tcommands: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction!.commands,\n\t});\n\n\treturn {\n\t\tdigest: transaction.digest,\n\t\tepoch: transaction.effects?.executedEpoch ?? null,\n\t\teffects: parseTransactionEffectsBcs(new Uint8Array(transaction.rawEffects!)),\n\t\tobjectTypes: Promise.resolve(objectTypes),\n\t\ttransaction: {\n\t\t\t...data,\n\t\t\tbcs: bytes,\n\t\t},\n\t\tsignatures: parsedTx.txSignatures,\n\t};\n}\n\nfunction parseTransactionEffectsJson({\n\tbytes,\n\teffects,\n\tobjectChanges,\n}: {\n\tbytes?: Uint8Array;\n\teffects: TransactionEffects;\n\tobjectChanges: SuiObjectChange[] | null;\n}): {\n\teffects: Experimental_SuiClientTypes.TransactionEffects;\n\tobjectTypes: Record<string, string>;\n} {\n\tconst changedObjects: Experimental_SuiClientTypes.ChangedObject[] = [];\n\tconst unchangedSharedObjects: Experimental_SuiClientTypes.UnchangedSharedObject[] = [];\n\tconst objectTypes: Record<string, string> = {};\n\n\tobjectChanges?.forEach((change) => {\n\t\tswitch (change.type) {\n\t\t\tcase 'published':\n\t\t\t\tchangedObjects.push({\n\t\t\t\t\tid: change.packageId,\n\t\t\t\t\tinputState: 'DoesNotExist',\n\t\t\t\t\tinputVersion: null,\n\t\t\t\t\tinputDigest: null,\n\t\t\t\t\tinputOwner: null,\n\t\t\t\t\toutputState: 'PackageWrite',\n\t\t\t\t\toutputVersion: change.version,\n\t\t\t\t\toutputDigest: change.digest,\n\t\t\t\t\toutputOwner: null,\n\t\t\t\t\tidOperation: 'Created',\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'transferred':\n\t\t\t\tchangedObjects.push({\n\t\t\t\t\tid: change.objectId,\n\t\t\t\t\tinputState: 'Exists',\n\t\t\t\t\tinputVersion: change.version,\n\t\t\t\t\tinputDigest: change.digest,\n\t\t\t\t\tinputOwner: {\n\t\t\t\t\t\t$kind: 'AddressOwner' as const,\n\t\t\t\t\t\tAddressOwner: change.sender,\n\t\t\t\t\t},\n\t\t\t\t\toutputState: 'ObjectWrite',\n\t\t\t\t\toutputVersion: change.version,\n\t\t\t\t\toutputDigest: change.digest,\n\t\t\t\t\toutputOwner: parseOwner(change.recipient),\n\t\t\t\t\tidOperation: 'None',\n\t\t\t\t});\n\t\t\t\tobjectTypes[change.objectId] = change.objectType;\n\t\t\t\tbreak;\n\t\t\tcase 'mutated':\n\t\t\t\tchangedObjects.push({\n\t\t\t\t\tid: change.objectId,\n\t\t\t\t\tinputState: 'Exists',\n\t\t\t\t\tinputVersion: change.previousVersion,\n\t\t\t\t\tinputDigest: null,\n\t\t\t\t\tinputOwner: parseOwner(change.owner),\n\t\t\t\t\toutputState: 'ObjectWrite',\n\t\t\t\t\toutputVersion: change.version,\n\t\t\t\t\toutputDigest: change.digest,\n\t\t\t\t\toutputOwner: parseOwner(change.owner),\n\t\t\t\t\tidOperation: 'None',\n\t\t\t\t});\n\t\t\t\tobjectTypes[change.objectId] = change.objectType;\n\t\t\t\tbreak;\n\t\t\tcase 'deleted':\n\t\t\t\tchangedObjects.push({\n\t\t\t\t\tid: change.objectId,\n\t\t\t\t\tinputState: 'Exists',\n\t\t\t\t\tinputVersion: change.version,\n\t\t\t\t\tinputDigest: effects.deleted?.find((d) => d.objectId === change.objectId)?.digest ?? null,\n\t\t\t\t\tinputOwner: null,\n\t\t\t\t\toutputState: 'DoesNotExist',\n\t\t\t\t\toutputVersion: null,\n\t\t\t\t\toutputDigest: null,\n\t\t\t\t\toutputOwner: null,\n\t\t\t\t\tidOperation: 'Deleted',\n\t\t\t\t});\n\t\t\t\tobjectTypes[change.objectId] = change.objectType;\n\t\t\t\tbreak;\n\t\t\tcase 'wrapped':\n\t\t\t\tchangedObjects.push({\n\t\t\t\t\tid: change.objectId,\n\t\t\t\t\tinputState: 'Exists',\n\t\t\t\t\tinputVersion: change.version,\n\t\t\t\t\tinputDigest: null,\n\t\t\t\t\tinputOwner: {\n\t\t\t\t\t\t$kind: 'AddressOwner' as const,\n\t\t\t\t\t\tAddressOwner: change.sender,\n\t\t\t\t\t},\n\t\t\t\t\toutputState: 'ObjectWrite',\n\t\t\t\t\toutputVersion: change.version,\n\t\t\t\t\toutputDigest:\n\t\t\t\t\t\teffects.wrapped?.find((w) => w.objectId === change.objectId)?.digest ?? null,\n\t\t\t\t\toutputOwner: {\n\t\t\t\t\t\t$kind: 'ObjectOwner' as const,\n\t\t\t\t\t\tObjectOwner: change.sender,\n\t\t\t\t\t},\n\t\t\t\t\tidOperation: 'None',\n\t\t\t\t});\n\t\t\t\tobjectTypes[change.objectId] = change.objectType;\n\t\t\t\tbreak;\n\t\t\tcase 'created':\n\t\t\t\tchangedObjects.push({\n\t\t\t\t\tid: change.objectId,\n\t\t\t\t\tinputState: 'DoesNotExist',\n\t\t\t\t\tinputVersion: null,\n\t\t\t\t\tinputDigest: null,\n\t\t\t\t\tinputOwner: null,\n\t\t\t\t\toutputState: 'ObjectWrite',\n\t\t\t\t\toutputVersion: change.version,\n\t\t\t\t\toutputDigest: change.digest,\n\t\t\t\t\toutputOwner: parseOwner(change.owner),\n\t\t\t\t\tidOperation: 'Created',\n\t\t\t\t});\n\t\t\t\tobjectTypes[change.objectId] = change.objectType;\n\t\t\t\tbreak;\n\t\t}\n\t});\n\n\treturn {\n\t\tobjectTypes,\n\t\teffects: {\n\t\t\tbcs: bytes ?? null,\n\t\t\tdigest: effects.transactionDigest,\n\t\t\tversion: 2,\n\t\t\tstatus:\n\t\t\t\teffects.status.status === 'success'\n\t\t\t\t\t? { success: true, error: null }\n\t\t\t\t\t: { success: false, error: effects.status.error! },\n\t\t\tgasUsed: effects.gasUsed,\n\t\t\ttransactionDigest: effects.transactionDigest,\n\t\t\tgasObject: {\n\t\t\t\tid: effects.gasObject?.reference.objectId,\n\t\t\t\tinputState: 'Exists',\n\t\t\t\tinputVersion: null,\n\t\t\t\tinputDigest: null,\n\t\t\t\tinputOwner: null,\n\t\t\t\toutputState: 'ObjectWrite',\n\t\t\t\toutputVersion: effects.gasObject.reference.version,\n\t\t\t\toutputDigest: effects.gasObject.reference.digest,\n\t\t\t\toutputOwner: parseOwner(effects.gasObject.owner),\n\t\t\t\tidOperation: 'None',\n\t\t\t},\n\t\t\teventsDigest: effects.eventsDigest ?? null,\n\t\t\tdependencies: effects.dependencies ?? [],\n\t\t\tlamportVersion: effects.gasObject.reference.version,\n\t\t\tchangedObjects,\n\t\t\tunchangedSharedObjects,\n\t\t\tauxiliaryDataDigest: null,\n\t\t},\n\t};\n}\n\nconst Balance = bcs.struct('Balance', {\n\tvalue: bcs.u64(),\n});\n\nconst Coin = bcs.struct('Coin', {\n\tid: bcs.Address,\n\tbalance: Balance,\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { fromBase58, toBase64, toHex } from '@mysten/bcs';\n\nimport type { Signer } from '../cryptography/index.js';\nimport { Experimental_BaseClient } from '../experimental/client.js';\nimport { JSONRpcTransport } from '../experimental/transports/jsonRPC.js';\nimport type {\n\tExperimental_SuiClientTypes,\n\tSelfRegisteringClientExtension,\n} from '../experimental/types.js';\nimport type { Transaction } from '../transactions/Transaction.js';\nimport { isTransaction } from '../transactions/Transaction.js';\nimport {\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n} from '../utils/sui-types.js';\nimport { normalizeSuiNSName } from '../utils/suins.js';\nimport { SuiHTTPTransport } from './http-transport.js';\nimport type { SuiTransport } from './http-transport.js';\nimport type {\n\tAddressMetrics,\n\tAllEpochsAddressMetrics,\n\tCheckpoint,\n\tCheckpointPage,\n\tCoinBalance,\n\tCoinMetadata,\n\tCoinSupply,\n\tCommitteeInfo,\n\tDelegatedStake,\n\tDevInspectResults,\n\tDevInspectTransactionBlockParams,\n\tDryRunTransactionBlockParams,\n\tDryRunTransactionBlockResponse,\n\tDynamicFieldPage,\n\tEpochInfo,\n\tEpochMetricsPage,\n\tEpochPage,\n\tExecuteTransactionBlockParams,\n\tGetAllBalancesParams,\n\tGetAllCoinsParams,\n\tGetBalanceParams,\n\tGetCheckpointParams,\n\tGetCheckpointsParams,\n\tGetCoinMetadataParams,\n\tGetCoinsParams,\n\tGetCommitteeInfoParams,\n\tGetDynamicFieldObjectParams,\n\tGetDynamicFieldsParams,\n\tGetLatestCheckpointSequenceNumberParams,\n\tGetLatestSuiSystemStateParams,\n\tGetMoveFunctionArgTypesParams,\n\tGetNormalizedMoveFunctionParams,\n\tGetNormalizedMoveModuleParams,\n\tGetNormalizedMoveModulesByPackageParams,\n\tGetNormalizedMoveStructParams,\n\tGetObjectParams,\n\tGetOwnedObjectsParams,\n\tGetProtocolConfigParams,\n\tGetReferenceGasPriceParams,\n\tGetStakesByIdsParams,\n\tGetStakesParams,\n\tGetTotalSupplyParams,\n\tGetTransactionBlockParams,\n\tMoveCallMetrics,\n\tMultiGetObjectsParams,\n\tMultiGetTransactionBlocksParams,\n\tNetworkMetrics,\n\tObjectRead,\n\tOrder,\n\tPaginatedCoins,\n\tPaginatedEvents,\n\tPaginatedObjectsResponse,\n\tPaginatedTransactionResponse,\n\tProtocolConfig,\n\tQueryEventsParams,\n\tQueryTransactionBlocksParams,\n\tResolvedNameServiceNames,\n\tResolveNameServiceAddressParams,\n\tResolveNameServiceNamesParams,\n\tSubscribeEventParams,\n\tSubscribeTransactionParams,\n\tSuiEvent,\n\tSuiMoveFunctionArgType,\n\tSuiMoveNormalizedFunction,\n\tSuiMoveNormalizedModule,\n\tSuiMoveNormalizedModules,\n\tSuiMoveNormalizedStruct,\n\tSuiObjectResponse,\n\tSuiObjectResponseQuery,\n\tSuiSystemStateSummary,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseQuery,\n\tTransactionEffects,\n\tTryGetPastObjectParams,\n\tUnsubscribe,\n\tValidatorsApy,\n\tVerifyZkLoginSignatureParams,\n\tZkLoginVerifyResult,\n} from './types/index.js';\nimport { isValidNamedPackage } from '../utils/move-registry.js';\nimport { hasMvrName } from '../experimental/mvr.js';\n\nexport interface PaginationArguments<Cursor> {\n\t/** Optional paging cursor */\n\tcursor?: Cursor;\n\t/** Maximum item returned per page */\n\tlimit?: number | null;\n}\n\nexport interface OrderArguments {\n\torder?: Order | null;\n}\n\n/**\n * Configuration options for the SuiClient\n * You must provide either a `url` or a `transport`\n */\nexport type SuiClientOptions = NetworkOrTransport & {\n\tnetwork?: Experimental_SuiClientTypes.Network;\n\tmvr?: Experimental_SuiClientTypes.MvrOptions;\n};\n\ntype NetworkOrTransport =\n\t| {\n\t\t\turl: string;\n\t\t\ttransport?: never;\n\t  }\n\t| {\n\t\t\ttransport: SuiTransport;\n\t\t\turl?: never;\n\t  };\n\nconst SUI_CLIENT_BRAND = Symbol.for('@mysten/SuiClient') as never;\n\nexport function isSuiClient(client: unknown): client is SuiClient {\n\treturn (\n\t\ttypeof client === 'object' && client !== null && (client as any)[SUI_CLIENT_BRAND] === true\n\t);\n}\n\nexport class SuiClient extends Experimental_BaseClient implements SelfRegisteringClientExtension {\n\tcore: JSONRpcTransport;\n\tjsonRpc = this;\n\tprotected transport: SuiTransport;\n\n\tget [SUI_CLIENT_BRAND]() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Establish a connection to a Sui RPC endpoint\n\t *\n\t * @param options configuration options for the API Client\n\t */\n\tconstructor(options: SuiClientOptions) {\n\t\tsuper({ network: options.network ?? 'unknown' });\n\t\tthis.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });\n\t\tthis.core = new JSONRpcTransport({\n\t\t\tjsonRpcClient: this,\n\t\t\tmvr: options.mvr,\n\t\t});\n\t}\n\n\tasync getRpcApiVersion({ signal }: { signal?: AbortSignal } = {}): Promise<string | undefined> {\n\t\tconst resp = await this.transport.request<{ info: { version: string } }>({\n\t\t\tmethod: 'rpc.discover',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\n\t\treturn resp.info.version;\n\t}\n\n\t/**\n\t * Get all Coin<`coin_type`> objects owned by an address.\n\t */\n\tasync getCoins({\n\t\tcoinType,\n\t\towner,\n\t\tcursor,\n\t\tlimit,\n\t\tsignal,\n\t}: GetCoinsParams): Promise<PaginatedCoins> {\n\t\tif (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCoins',\n\t\t\tparams: [owner, coinType, cursor, limit],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get all Coin objects owned by an address.\n\t */\n\tasync getAllCoins(input: GetAllCoinsParams): Promise<PaginatedCoins> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllCoins',\n\t\t\tparams: [input.owner, input.cursor, input.limit],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get the total coin balance for one coin type, owned by the address owner.\n\t */\n\tasync getBalance({ owner, coinType, signal }: GetBalanceParams): Promise<CoinBalance> {\n\t\tif (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getBalance',\n\t\t\tparams: [owner, coinType],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get the total coin balance for all coin types, owned by the address owner.\n\t */\n\tasync getAllBalances(input: GetAllBalancesParams): Promise<CoinBalance[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllBalances',\n\t\t\tparams: [input.owner],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Fetch CoinMetadata for a given coin type\n\t */\n\tasync getCoinMetadata({ coinType, signal }: GetCoinMetadataParams): Promise<CoinMetadata | null> {\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCoinMetadata',\n\t\t\tparams: [coinType],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t *  Fetch total supply for a coin\n\t */\n\tasync getTotalSupply({ coinType, signal }: GetTotalSupplyParams): Promise<CoinSupply> {\n\t\tif (coinType && hasMvrName(coinType)) {\n\t\t\tcoinType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: coinType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getTotalSupply',\n\t\t\tparams: [coinType],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke any RPC method\n\t * @param method the method to be invoked\n\t * @param args the arguments to be passed to the RPC request\n\t */\n\tasync call<T = unknown>(\n\t\tmethod: string,\n\t\tparams: unknown[],\n\t\t{ signal }: { signal?: AbortSignal } = {},\n\t): Promise<T> {\n\t\treturn await this.transport.request({ method, params, signal });\n\t}\n\n\t/**\n\t * Get Move function argument types like read, write and full access\n\t */\n\tasync getMoveFunctionArgTypes({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tfunction: fn,\n\t\tsignal,\n\t}: GetMoveFunctionArgTypesParams): Promise<SuiMoveFunctionArgType[]> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getMoveFunctionArgTypes',\n\t\t\tparams: [pkg, module, fn],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a map from module name to\n\t * structured representations of Move modules\n\t */\n\tasync getNormalizedMoveModulesByPackage({\n\t\tpackage: pkg,\n\t\tsignal,\n\t}: GetNormalizedMoveModulesByPackageParams): Promise<SuiMoveNormalizedModules> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveModulesByPackage',\n\t\t\tparams: [pkg],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move module\n\t */\n\tasync getNormalizedMoveModule({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tsignal,\n\t}: GetNormalizedMoveModuleParams): Promise<SuiMoveNormalizedModule> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveModule',\n\t\t\tparams: [pkg, module],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move function\n\t */\n\tasync getNormalizedMoveFunction({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tfunction: fn,\n\t\tsignal,\n\t}: GetNormalizedMoveFunctionParams): Promise<SuiMoveNormalizedFunction> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveFunction',\n\t\t\tparams: [pkg, module, fn],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move struct\n\t */\n\tasync getNormalizedMoveStruct({\n\t\tpackage: pkg,\n\t\tmodule,\n\t\tstruct,\n\t\tsignal,\n\t}: GetNormalizedMoveStructParams): Promise<SuiMoveNormalizedStruct> {\n\t\tif (pkg && isValidNamedPackage(pkg)) {\n\t\t\tpkg = (\n\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\tpackage: pkg,\n\t\t\t\t})\n\t\t\t).package;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveStruct',\n\t\t\tparams: [pkg, module, struct],\n\t\t\tsignal: signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get all objects owned by an address\n\t */\n\tasync getOwnedObjects(input: GetOwnedObjectsParams): Promise<PaginatedObjectsResponse> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\tconst filter = input.filter\n\t\t\t? {\n\t\t\t\t\t...input.filter,\n\t\t\t\t}\n\t\t\t: undefined;\n\n\t\tif (filter && 'MoveModule' in filter && isValidNamedPackage(filter.MoveModule.package)) {\n\t\t\tfilter.MoveModule = {\n\t\t\t\tmodule: filter.MoveModule.module,\n\t\t\t\tpackage: (\n\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\tpackage: filter.MoveModule.package,\n\t\t\t\t\t})\n\t\t\t\t).package,\n\t\t\t};\n\t\t} else if (filter && 'StructType' in filter && hasMvrName(filter.StructType)) {\n\t\t\tfilter.StructType = (\n\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\ttype: filter.StructType,\n\t\t\t\t})\n\t\t\t).type;\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getOwnedObjects',\n\t\t\tparams: [\n\t\t\t\tinput.owner,\n\t\t\t\t{\n\t\t\t\t\tfilter,\n\t\t\t\t\toptions: input.options,\n\t\t\t\t} as SuiObjectResponseQuery,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get details about an object\n\t */\n\tasync getObject(input: GetObjectParams): Promise<SuiObjectResponse> {\n\t\tif (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getObject',\n\t\t\tparams: [input.id, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync tryGetPastObject(input: TryGetPastObjectParams): Promise<ObjectRead> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_tryGetPastObject',\n\t\t\tparams: [input.id, input.version, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n\t */\n\tasync multiGetObjects(input: MultiGetObjectsParams): Promise<SuiObjectResponse[]> {\n\t\tinput.ids.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Object id ${id}`);\n\t\t\t}\n\t\t});\n\t\tconst hasDuplicates = input.ids.length !== new Set(input.ids).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate object ids in batch call ${input.ids}`);\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_multiGetObjects',\n\t\t\tparams: [input.ids, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get transaction blocks for a given query criteria\n\t */\n\tasync queryTransactionBlocks({\n\t\tfilter,\n\t\toptions,\n\t\tcursor,\n\t\tlimit,\n\t\torder,\n\t\tsignal,\n\t}: QueryTransactionBlocksParams): Promise<PaginatedTransactionResponse> {\n\t\tif (filter && 'MoveFunction' in filter && isValidNamedPackage(filter.MoveFunction.package)) {\n\t\t\tfilter = {\n\t\t\t\t...filter,\n\t\t\t\tMoveFunction: {\n\t\t\t\t\tpackage: (\n\t\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\t\tpackage: filter.MoveFunction.package,\n\t\t\t\t\t\t})\n\t\t\t\t\t).package,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_queryTransactionBlocks',\n\t\t\tparams: [\n\t\t\t\t{\n\t\t\t\t\tfilter,\n\t\t\t\t\toptions,\n\t\t\t\t} as SuiTransactionBlockResponseQuery,\n\t\t\t\tcursor,\n\t\t\t\tlimit,\n\t\t\t\t(order || 'descending') === 'descending',\n\t\t\t],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\tasync getTransactionBlock(\n\t\tinput: GetTransactionBlockParams,\n\t): Promise<SuiTransactionBlockResponse> {\n\t\tif (!isValidTransactionDigest(input.digest)) {\n\t\t\tthrow new Error('Invalid Transaction digest');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getTransactionBlock',\n\t\t\tparams: [input.digest, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync multiGetTransactionBlocks(\n\t\tinput: MultiGetTransactionBlocksParams,\n\t): Promise<SuiTransactionBlockResponse[]> {\n\t\tinput.digests.forEach((d) => {\n\t\t\tif (!isValidTransactionDigest(d)) {\n\t\t\t\tthrow new Error(`Invalid Transaction digest ${d}`);\n\t\t\t}\n\t\t});\n\n\t\tconst hasDuplicates = input.digests.length !== new Set(input.digests).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate digests in batch call ${input.digests}`);\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_multiGetTransactionBlocks',\n\t\t\tparams: [input.digests, input.options],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync executeTransactionBlock({\n\t\ttransactionBlock,\n\t\tsignature,\n\t\toptions,\n\t\trequestType,\n\t\tsignal,\n\t}: ExecuteTransactionBlockParams): Promise<SuiTransactionBlockResponse> {\n\t\tconst result: SuiTransactionBlockResponse = await this.transport.request({\n\t\t\tmethod: 'sui_executeTransactionBlock',\n\t\t\tparams: [\n\t\t\t\ttypeof transactionBlock === 'string' ? transactionBlock : toBase64(transactionBlock),\n\t\t\t\tArray.isArray(signature) ? signature : [signature],\n\t\t\t\toptions,\n\t\t\t],\n\t\t\tsignal,\n\t\t});\n\n\t\tif (requestType === 'WaitForLocalExecution') {\n\t\t\ttry {\n\t\t\t\tawait this.waitForTransaction({\n\t\t\t\t\tdigest: result.digest,\n\t\t\t\t});\n\t\t\t} catch (_) {\n\t\t\t\t// Ignore error while waiting for transaction\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync signAndExecuteTransaction({\n\t\ttransaction,\n\t\tsigner,\n\t\t...input\n\t}: {\n\t\ttransaction: Uint8Array | Transaction;\n\t\tsigner: Signer;\n\t} & Omit<\n\t\tExecuteTransactionBlockParams,\n\t\t'transactionBlock' | 'signature'\n\t>): Promise<SuiTransactionBlockResponse> {\n\t\tlet transactionBytes;\n\n\t\tif (transaction instanceof Uint8Array) {\n\t\t\ttransactionBytes = transaction;\n\t\t} else {\n\t\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\t\t\ttransactionBytes = await transaction.build({ client: this });\n\t\t}\n\n\t\tconst { signature, bytes } = await signer.signTransaction(transactionBytes);\n\n\t\treturn this.executeTransactionBlock({\n\t\t\ttransactionBlock: bytes,\n\t\t\tsignature,\n\t\t\t...input,\n\t\t});\n\t}\n\n\t/**\n\t * Get total number of transactions\n\t */\n\n\tasync getTotalTransactionBlocks({ signal }: { signal?: AbortSignal } = {}): Promise<bigint> {\n\t\tconst resp = await this.transport.request<string>({\n\t\t\tmethod: 'sui_getTotalTransactionBlocks',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Getting the reference gas price for the network\n\t */\n\tasync getReferenceGasPrice({ signal }: GetReferenceGasPriceParams = {}): Promise<bigint> {\n\t\tconst resp = await this.transport.request<string>({\n\t\t\tmethod: 'suix_getReferenceGasPrice',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Return the delegated stakes for an address\n\t */\n\tasync getStakes(input: GetStakesParams): Promise<DelegatedStake[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getStakes',\n\t\t\tparams: [input.owner],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the delegated stakes queried by id.\n\t */\n\tasync getStakesByIds(input: GetStakesByIdsParams): Promise<DelegatedStake[]> {\n\t\tinput.stakedSuiIds.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Stake id ${id}`);\n\t\t\t}\n\t\t});\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getStakesByIds',\n\t\t\tparams: [input.stakedSuiIds],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the latest system state content.\n\t */\n\tasync getLatestSuiSystemState({\n\t\tsignal,\n\t}: GetLatestSuiSystemStateParams = {}): Promise<SuiSystemStateSummary> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getLatestSuiSystemState',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Get events for a given query criteria\n\t */\n\tasync queryEvents({\n\t\tquery,\n\t\tcursor,\n\t\tlimit,\n\t\torder,\n\t\tsignal,\n\t}: QueryEventsParams): Promise<PaginatedEvents> {\n\t\tif (query && 'MoveEventType' in query && hasMvrName(query.MoveEventType)) {\n\t\t\tquery = {\n\t\t\t\t...query,\n\t\t\t\tMoveEventType: (\n\t\t\t\t\tawait this.core.mvr.resolveType({\n\t\t\t\t\t\ttype: query.MoveEventType,\n\t\t\t\t\t})\n\t\t\t\t).type,\n\t\t\t};\n\t\t}\n\n\t\tif (query && 'MoveEventModule' in query && isValidNamedPackage(query.MoveEventModule.package)) {\n\t\t\tquery = {\n\t\t\t\t...query,\n\t\t\t\tMoveEventModule: {\n\t\t\t\t\tmodule: query.MoveEventModule.module,\n\t\t\t\t\tpackage: (\n\t\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\t\tpackage: query.MoveEventModule.package,\n\t\t\t\t\t\t})\n\t\t\t\t\t).package,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif ('MoveModule' in query && isValidNamedPackage(query.MoveModule.package)) {\n\t\t\tquery = {\n\t\t\t\t...query,\n\t\t\t\tMoveModule: {\n\t\t\t\t\tmodule: query.MoveModule.module,\n\t\t\t\t\tpackage: (\n\t\t\t\t\t\tawait this.core.mvr.resolvePackage({\n\t\t\t\t\t\t\tpackage: query.MoveModule.package,\n\t\t\t\t\t\t})\n\t\t\t\t\t).package,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_queryEvents',\n\t\t\tparams: [query, cursor, limit, (order || 'descending') === 'descending'],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Subscribe to get notifications whenever an event matching the filter occurs\n\t *\n\t * @deprecated\n\t */\n\tasync subscribeEvent(\n\t\tinput: SubscribeEventParams & {\n\t\t\t/** function to run when we receive a notification of a new event matching the filter */\n\t\t\tonMessage: (event: SuiEvent) => void;\n\t\t},\n\t): Promise<Unsubscribe> {\n\t\treturn this.transport.subscribe({\n\t\t\tmethod: 'suix_subscribeEvent',\n\t\t\tunsubscribe: 'suix_unsubscribeEvent',\n\t\t\tparams: [input.filter],\n\t\t\tonMessage: input.onMessage,\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated\n\t */\n\tasync subscribeTransaction(\n\t\tinput: SubscribeTransactionParams & {\n\t\t\t/** function to run when we receive a notification of a new event matching the filter */\n\t\t\tonMessage: (event: TransactionEffects) => void;\n\t\t},\n\t): Promise<Unsubscribe> {\n\t\treturn this.transport.subscribe({\n\t\t\tmethod: 'suix_subscribeTransaction',\n\t\t\tunsubscribe: 'suix_unsubscribeTransaction',\n\t\t\tparams: [input.filter],\n\t\t\tonMessage: input.onMessage,\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n\t * transaction (or Move call) with any arguments. Detailed results are\n\t * provided, including both the transaction effects and any return values.\n\t */\n\tasync devInspectTransactionBlock(\n\t\tinput: DevInspectTransactionBlockParams,\n\t): Promise<DevInspectResults> {\n\t\tlet devInspectTxBytes;\n\t\tif (isTransaction(input.transactionBlock)) {\n\t\t\tinput.transactionBlock.setSenderIfNotSet(input.sender);\n\t\t\tdevInspectTxBytes = toBase64(\n\t\t\t\tawait input.transactionBlock.build({\n\t\t\t\t\tclient: this,\n\t\t\t\t\tonlyTransactionKind: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t} else if (typeof input.transactionBlock === 'string') {\n\t\t\tdevInspectTxBytes = input.transactionBlock;\n\t\t} else if (input.transactionBlock instanceof Uint8Array) {\n\t\t\tdevInspectTxBytes = toBase64(input.transactionBlock);\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction block format.');\n\t\t}\n\n\t\tinput.signal?.throwIfAborted();\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_devInspectTransactionBlock',\n\t\t\tparams: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Dry run a transaction block and return the result.\n\t */\n\tasync dryRunTransactionBlock(\n\t\tinput: DryRunTransactionBlockParams,\n\t): Promise<DryRunTransactionBlockResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_dryRunTransactionBlock',\n\t\t\tparams: [\n\t\t\t\ttypeof input.transactionBlock === 'string'\n\t\t\t\t\t? input.transactionBlock\n\t\t\t\t\t: toBase64(input.transactionBlock),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Return the list of dynamic field objects owned by an object\n\t */\n\tasync getDynamicFields(input: GetDynamicFieldsParams): Promise<DynamicFieldPage> {\n\t\tif (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getDynamicFields',\n\t\t\tparams: [input.parentId, input.cursor, input.limit],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the dynamic field object information for a specified object\n\t */\n\tasync getDynamicFieldObject(input: GetDynamicFieldObjectParams): Promise<SuiObjectResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getDynamicFieldObject',\n\t\t\tparams: [input.parentId, input.name],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Get the sequence number of the latest checkpoint that has been executed\n\t */\n\tasync getLatestCheckpointSequenceNumber({\n\t\tsignal,\n\t}: GetLatestCheckpointSequenceNumberParams = {}): Promise<string> {\n\t\tconst resp = await this.transport.request({\n\t\t\tmethod: 'sui_getLatestCheckpointSequenceNumber',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t\treturn String(resp);\n\t}\n\n\t/**\n\t * Returns information about a given checkpoint\n\t */\n\tasync getCheckpoint(input: GetCheckpointParams): Promise<Checkpoint> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getCheckpoint',\n\t\t\tparams: [input.id],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Returns historical checkpoints paginated\n\t */\n\tasync getCheckpoints(\n\t\tinput: PaginationArguments<CheckpointPage['nextCursor']> & GetCheckpointsParams,\n\t): Promise<CheckpointPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getCheckpoints',\n\t\t\tparams: [input.cursor, input?.limit, input.descendingOrder],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCommitteeInfo(input?: GetCommitteeInfoParams): Promise<CommitteeInfo> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCommitteeInfo',\n\t\t\tparams: [input?.epoch],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\tasync getNetworkMetrics({ signal }: { signal?: AbortSignal } = {}): Promise<NetworkMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getNetworkMetrics',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\tasync getAddressMetrics({ signal }: { signal?: AbortSignal } = {}): Promise<AddressMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getLatestAddressMetrics',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\tasync getEpochMetrics(\n\t\tinput?: {\n\t\t\tdescendingOrder?: boolean;\n\t\t\tsignal?: AbortSignal;\n\t\t} & PaginationArguments<EpochMetricsPage['nextCursor']>,\n\t): Promise<EpochMetricsPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getEpochMetrics',\n\t\t\tparams: [input?.cursor, input?.limit, input?.descendingOrder],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\tasync getAllEpochAddressMetrics(input?: {\n\t\tdescendingOrder?: boolean;\n\t\tsignal?: AbortSignal;\n\t}): Promise<AllEpochsAddressMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllEpochAddressMetrics',\n\t\t\tparams: [input?.descendingOrder],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getEpochs(\n\t\tinput?: {\n\t\t\tdescendingOrder?: boolean;\n\t\t\tsignal?: AbortSignal;\n\t\t} & PaginationArguments<EpochPage['nextCursor']>,\n\t): Promise<EpochPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getEpochs',\n\t\t\tparams: [input?.cursor, input?.limit, input?.descendingOrder],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Returns list of top move calls by usage\n\t */\n\tasync getMoveCallMetrics({ signal }: { signal?: AbortSignal } = {}): Promise<MoveCallMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getMoveCallMetrics',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCurrentEpoch({ signal }: { signal?: AbortSignal } = {}): Promise<EpochInfo> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCurrentEpoch',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t/**\n\t * Return the Validators APYs\n\t */\n\tasync getValidatorsApy({ signal }: { signal?: AbortSignal } = {}): Promise<ValidatorsApy> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getValidatorsApy',\n\t\t\tparams: [],\n\t\t\tsignal,\n\t\t});\n\t}\n\n\t// TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n\tasync getChainIdentifier({ signal }: { signal?: AbortSignal } = {}): Promise<string> {\n\t\tconst checkpoint = await this.getCheckpoint({ id: '0', signal });\n\t\tconst bytes = fromBase58(checkpoint.digest);\n\t\treturn toHex(bytes.slice(0, 4));\n\t}\n\n\tasync resolveNameServiceAddress(input: ResolveNameServiceAddressParams): Promise<string | null> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_resolveNameServiceAddress',\n\t\t\tparams: [input.name],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\tasync resolveNameServiceNames({\n\t\tformat = 'dot',\n\t\t...input\n\t}: ResolveNameServiceNamesParams & {\n\t\tformat?: 'at' | 'dot';\n\t}): Promise<ResolvedNameServiceNames> {\n\t\tconst { nextCursor, hasNextPage, data }: ResolvedNameServiceNames =\n\t\t\tawait this.transport.request({\n\t\t\t\tmethod: 'suix_resolveNameServiceNames',\n\t\t\t\tparams: [input.address, input.cursor, input.limit],\n\t\t\t\tsignal: input.signal,\n\t\t\t});\n\n\t\treturn {\n\t\t\thasNextPage,\n\t\t\tnextCursor,\n\t\t\tdata: data.map((name) => normalizeSuiNSName(name, format)),\n\t\t};\n\t}\n\n\tasync getProtocolConfig(input?: GetProtocolConfigParams): Promise<ProtocolConfig> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getProtocolConfig',\n\t\t\tparams: [input?.version],\n\t\t\tsignal: input?.signal,\n\t\t});\n\t}\n\n\tasync verifyZkLoginSignature(input: VerifyZkLoginSignatureParams): Promise<ZkLoginVerifyResult> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_verifyZkLoginSignature',\n\t\t\tparams: [input.bytes, input.signature, input.intentScope, input.author],\n\t\t\tsignal: input.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Wait for a transaction block result to be available over the API.\n\t * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n\t * be available via the API.\n\t * This currently polls the `getTransactionBlock` API to check for the transaction.\n\t */\n\tasync waitForTransaction({\n\t\tsignal,\n\t\ttimeout = 60 * 1000,\n\t\tpollInterval = 2 * 1000,\n\t\t...input\n\t}: {\n\t\t/** An optional abort signal that can be used to cancel */\n\t\tsignal?: AbortSignal;\n\t\t/** The amount of time to wait for a transaction block. Defaults to one minute. */\n\t\ttimeout?: number;\n\t\t/** The amount of time to wait between checks for the transaction block. Defaults to 2 seconds. */\n\t\tpollInterval?: number;\n\t} & Parameters<SuiClient['getTransactionBlock']>[0]): Promise<SuiTransactionBlockResponse> {\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout);\n\t\tconst timeoutPromise = new Promise((_, reject) => {\n\t\t\ttimeoutSignal.addEventListener('abort', () => reject(timeoutSignal.reason));\n\t\t});\n\n\t\ttimeoutPromise.catch(() => {\n\t\t\t// Swallow unhandled rejections that might be thrown after early return\n\t\t});\n\n\t\twhile (!timeoutSignal.aborted) {\n\t\t\tsignal?.throwIfAborted();\n\t\t\ttry {\n\t\t\t\treturn await this.getTransactionBlock(input);\n\t\t\t} catch (e) {\n\t\t\t\t// Wait for either the next poll interval, or the timeout.\n\t\t\t\tawait Promise.race([\n\t\t\t\t\tnew Promise((resolve) => setTimeout(resolve, pollInterval)),\n\t\t\t\t\ttimeoutPromise,\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\ttimeoutSignal.throwIfAborted();\n\n\t\t// This should never happen, because the above case should always throw, but just adding it in the event that something goes horribly wrong.\n\t\tthrow new Error('Unexpected error while waiting for transaction block.');\n\t}\n\n\texperimental_asClientExtension(this: SuiClient) {\n\t\treturn {\n\t\t\tname: 'jsonRPC',\n\t\t\tregister: () => {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t} as const;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../bcs/index.js';\n\nexport type IntentScope = Exclude<keyof typeof bcs.IntentScope.$inferType, '$kind'>;\n/**\n * Inserts a domain separator for a message that is being signed\n */\nexport function messageWithIntent(scope: IntentScope, message: Uint8Array) {\n\treturn bcs\n\t\t.IntentMessage(bcs.fixedArray(message.length, bcs.u8()))\n\t\t.serialize({\n\t\t\tintent: {\n\t\t\t\tscope: { [scope as 'PersonalMessage']: true },\n\t\t\t\tversion: { V0: true },\n\t\t\t\tappId: { Sui: true },\n\t\t\t},\n\t\t\tvalue: message,\n\t\t})\n\t\t.toBytes();\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport const SIGNATURE_SCHEME_TO_FLAG = {\n\tED25519: 0x00,\n\tSecp256k1: 0x01,\n\tSecp256r1: 0x02,\n\tMultiSig: 0x03,\n\tZkLogin: 0x05,\n\tPasskey: 0x06,\n} as const;\n\nexport const SIGNATURE_SCHEME_TO_SIZE = {\n\tED25519: 32,\n\tSecp256k1: 33,\n\tSecp256r1: 33,\n\tPasskey: 33,\n};\n\nexport const SIGNATURE_FLAG_TO_SCHEME = {\n\t0x00: 'ED25519',\n\t0x01: 'Secp256k1',\n\t0x02: 'Secp256r1',\n\t0x03: 'MultiSig',\n\t0x05: 'ZkLogin',\n\t0x06: 'Passkey',\n} as const;\n\nexport type SignatureScheme =\n\t| 'ED25519'\n\t| 'Secp256k1'\n\t| 'Secp256r1'\n\t| 'MultiSig'\n\t| 'ZkLogin'\n\t| 'Passkey';\n\nexport type SignatureFlag = keyof typeof SIGNATURE_FLAG_TO_SCHEME;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport type { IntentScope } from './intent.js';\nimport { messageWithIntent } from './intent.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_SIZE } from './signature-scheme.js';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n\tif (a === b) return true;\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * A public key\n */\nexport abstract class PublicKey {\n\t/**\n\t * Checks if two public keys are equal\n\t */\n\tequals(publicKey: PublicKey) {\n\t\treturn bytesEqual(this.toRawBytes(), publicKey.toRawBytes());\n\t}\n\n\t/**\n\t * Return the base-64 representation of the public key\n\t */\n\ttoBase64() {\n\t\treturn toBase64(this.toRawBytes());\n\t}\n\n\ttoString(): never {\n\t\tthrow new Error(\n\t\t\t'`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.',\n\t\t);\n\t}\n\n\t/**\n\t * Return the Sui representation of the public key encoded in\n\t * base-64. A Sui public key is formed by the concatenation\n\t * of the scheme flag with the raw bytes of the public key\n\t */\n\ttoSuiPublicKey(): string {\n\t\tconst bytes = this.toSuiBytes();\n\t\treturn toBase64(bytes);\n\t}\n\n\tverifyWithIntent(\n\t\tbytes: Uint8Array,\n\t\tsignature: Uint8Array | string,\n\t\tintent: IntentScope,\n\t): Promise<boolean> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\treturn this.verify(digest, signature);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\treturn this.verifyWithIntent(\n\t\t\tbcs.vector(bcs.u8()).serialize(message).toBytes(),\n\t\t\tsignature,\n\t\t\t'PersonalMessage',\n\t\t);\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\treturn this.verifyWithIntent(transaction, signature, 'TransactionData');\n\t}\n\n\t/**\n\t * Verifies that the public key is associated with the provided address\n\t */\n\tverifyAddress(address: string): boolean {\n\t\treturn this.toSuiAddress() === address;\n\t}\n\n\t/**\n\t * Returns the bytes representation of the public key\n\t * prefixed with the signature scheme flag\n\t */\n\ttoSuiBytes(): Uint8Array {\n\t\tconst rawBytes = this.toRawBytes();\n\t\tconst suiBytes = new Uint8Array(rawBytes.length + 1);\n\t\tsuiBytes.set([this.flag()]);\n\t\tsuiBytes.set(rawBytes, 1);\n\n\t\treturn suiBytes;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Ed25519 public key\n\t */\n\ttoSuiAddress(): string {\n\t\t// Each hex char represents half a byte, hence hex address doubles the length\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(this.toSuiBytes(), { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the public key\n\t */\n\tabstract toRawBytes(): Uint8Array;\n\n\t/**\n\t * Return signature scheme flag of the public key\n\t */\n\tabstract flag(): number;\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tabstract verify(data: Uint8Array, signature: Uint8Array | string): Promise<boolean>;\n}\n\nexport function parseSerializedKeypairSignature(serializedSignature: string) {\n\tconst bytes = fromBase64(serializedSignature);\n\n\tconst signatureScheme =\n\t\tSIGNATURE_FLAG_TO_SCHEME[bytes[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\tcase 'Secp256k1':\n\t\tcase 'Secp256r1':\n\t\t\tconst size =\n\t\t\t\tSIGNATURE_SCHEME_TO_SIZE[signatureScheme as keyof typeof SIGNATURE_SCHEME_TO_SIZE];\n\t\t\tconst signature = bytes.slice(1, bytes.length - size);\n\t\t\tconst publicKey = bytes.slice(1 + signature.length);\n\n\t\t\treturn {\n\t\t\t\tserializedSignature,\n\t\t\t\tsignatureScheme,\n\t\t\t\tsignature,\n\t\t\t\tpublicKey,\n\t\t\t\tbytes,\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported signature scheme');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { PasskeyAuthenticator } from '../../bcs/bcs.js';\nimport { bytesEqual, PublicKey } from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nexport const PASSKEY_PUBLIC_KEY_SIZE = 33;\nexport const PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nexport const PASSKEY_SIGNATURE_SIZE = 64;\n/** Fixed DER header for secp256r1 SubjectPublicKeyInfo\nDER structure for P-256 SPKI:\n30 -- SEQUENCE\n  59 -- length (89 bytes)\n  30 -- SEQUENCE\n    13 -- length (19 bytes)\n    06 -- OBJECT IDENTIFIER\n      07 -- length\n      2A 86 48 CE 3D 02 01 -- id-ecPublicKey\n    06 -- OBJECT IDENTIFIER\n      08 -- length\n      2A 86 48 CE 3D 03 01 07 -- secp256r1/prime256v1\n  03 -- BIT STRING\n    42 -- length (66 bytes)\n    00 -- padding\n\t===== above bytes are considered header =====\n    04 || x || y -- uncompressed point (65 bytes: 0x04 || 32-byte x || 32-byte y)\n*/\nexport const SECP256R1_SPKI_HEADER = new Uint8Array([\n\t0x30,\n\t0x59, // SEQUENCE, length 89\n\t0x30,\n\t0x13, // SEQUENCE, length 19\n\t0x06,\n\t0x07, // OID, length 7\n\t0x2a,\n\t0x86,\n\t0x48,\n\t0xce,\n\t0x3d,\n\t0x02,\n\t0x01, // OID: 1.2.840.10045.2.1 (ecPublicKey)\n\t0x06,\n\t0x08, // OID, length 8\n\t0x2a,\n\t0x86,\n\t0x48,\n\t0xce,\n\t0x3d,\n\t0x03,\n\t0x01,\n\t0x07, // OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)\n\t0x03,\n\t0x42, // BIT STRING, length 66\n\t0x00, // no unused bits\n] as const);\n\n/**\n * A passkey public key\n */\nexport class PasskeyPublicKey extends PublicKey {\n\tstatic SIZE = PASSKEY_PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array;\n\n\t/**\n\t * Create a new PasskeyPublicKey object\n\t * @param value passkey public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two passkey public keys are equal\n\t */\n\toverride equals(publicKey: PasskeyPublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Secp256r1 public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Secp256r1 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['Passkey'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsed = parseSerializedPasskeySignature(signature);\n\t\tconst clientDataJSON = JSON.parse(parsed.clientDataJson);\n\n\t\tif (clientDataJSON.type !== 'webauthn.get') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// parse challenge from base64 url\n\t\tconst parsedChallenge = fromBase64(\n\t\t\tclientDataJSON.challenge.replace(/-/g, '+').replace(/_/g, '/'),\n\t\t);\n\t\tif (!bytesEqual(message, parsedChallenge)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);\n\t\tif (!bytesEqual(this.toRawBytes(), pk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst payload = new Uint8Array([...parsed.authenticatorData, ...sha256(parsed.clientDataJson)]);\n\t\tconst sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);\n\t\treturn secp256r1.verify(sig, sha256(payload), pk);\n\t}\n}\n\n/**\n * Parses a DER SubjectPublicKeyInfo into an uncompressed public key. This also verifies\n * that the curve used is P-256 (secp256r1).\n *\n * @param data: DER SubjectPublicKeyInfo\n * @returns uncompressed public key (`0x04 || x || y`)\n */\nexport function parseDerSPKI(derBytes: Uint8Array): Uint8Array {\n\t// Verify length and header bytes are expected\n\tif (derBytes.length !== SECP256R1_SPKI_HEADER.length + PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n\t\tthrow new Error('Invalid DER length');\n\t}\n\tfor (let i = 0; i < SECP256R1_SPKI_HEADER.length; i++) {\n\t\tif (derBytes[i] !== SECP256R1_SPKI_HEADER[i]) {\n\t\t\tthrow new Error('Invalid spki header');\n\t\t}\n\t}\n\n\tif (derBytes[SECP256R1_SPKI_HEADER.length] !== 0x04) {\n\t\tthrow new Error('Invalid point marker');\n\t}\n\n\t// Returns the last 65 bytes `04 || x || y`\n\treturn derBytes.slice(SECP256R1_SPKI_HEADER.length);\n}\n\n/**\n * Parse signature from bytes or base64 string into the following fields.\n */\nexport function parseSerializedPasskeySignature(signature: Uint8Array | string) {\n\tconst bytes = typeof signature === 'string' ? fromBase64(signature) : signature;\n\n\tif (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {\n\t\tthrow new Error('Invalid signature scheme');\n\t}\n\tconst dec = PasskeyAuthenticator.parse(bytes.slice(1));\n\treturn {\n\t\tsignatureScheme: 'Passkey' as const,\n\t\tserializedSignature: toBase64(bytes),\n\t\tsignature: bytes,\n\t\tauthenticatorData: dec.authenticatorData,\n\t\tclientDataJson: dec.clientDataJson,\n\t\tuserSignature: new Uint8Array(dec.userSignature),\n\t\tpublicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE)),\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n/* eslint-disable */\n\nimport { DocumentTypeDecoration } from '@graphql-typed-document-node/core';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n  /** String containing Base64-encoded binary data. */\n  Base64: { input: any; output: any; }\n  /** String representation of an arbitrary width, possibly signed integer. */\n  BigInt: { input: any; output: any; }\n  /** ISO-8601 Date and Time: RFC3339 in UTC with format: YYYY-MM-DDTHH:MM:SS.mmmZ. Note that the milliseconds part is optional, and it may be omitted if its value is 0. */\n  DateTime: { input: any; output: any; }\n  /** Arbitrary JSON data. */\n  JSON: { input: any; output: any; }\n  /**\n   * The contents of a Move Value, corresponding to the following recursive type:\n   *\n   * type MoveData =\n   *     { Address: SuiAddress }\n   *   | { UID:     SuiAddress }\n   *   | { ID:      SuiAddress }\n   *   | { Bool:    bool }\n   *   | { Number:  BigInt }\n   *   | { String:  string }\n   *   | { Vector:  [MoveData] }\n   *   | { Option:   MoveData? }\n   *   | { Struct:  [{ name: string , value: MoveData }] }\n   *   | { Variant: {\n   *       name: string,\n   *       fields: [{ name: string, value: MoveData }],\n   *   }\n   */\n  MoveData: { input: any; output: any; }\n  /**\n   * The shape of a concrete Move Type (a type with all its type parameters instantiated with concrete types), corresponding to the following recursive type:\n   *\n   * type MoveTypeLayout =\n   *     \"address\"\n   *   | \"bool\"\n   *   | \"u8\" | \"u16\" | ... | \"u256\"\n   *   | { vector: MoveTypeLayout }\n   *   | {\n   *       struct: {\n   *         type: string,\n   *         fields: [{ name: string, layout: MoveTypeLayout }],\n   *       }\n   *     }\n   *   | { enum: [{\n   *           type: string,\n   *           variants: [{\n   *               name: string,\n   *               fields: [{ name: string, layout: MoveTypeLayout }],\n   *           }]\n   *       }]\n   *   }\n   */\n  MoveTypeLayout: { input: any; output: any; }\n  /**\n   * The signature of a concrete Move Type (a type with all its type parameters instantiated with concrete types, that contains no references), corresponding to the following recursive type:\n   *\n   * type MoveTypeSignature =\n   *     \"address\"\n   *   | \"bool\"\n   *   | \"u8\" | \"u16\" | ... | \"u256\"\n   *   | { vector: MoveTypeSignature }\n   *   | {\n   *       datatype: {\n   *         package: string,\n   *         module: string,\n   *         type: string,\n   *         typeParameters: [MoveTypeSignature],\n   *       }\n   *     }\n   */\n  MoveTypeSignature: { input: any; output: any; }\n  /**\n   * The shape of an abstract Move Type (a type that can contain free type parameters, and can optionally be taken by reference), corresponding to the following recursive type:\n   *\n   * type OpenMoveTypeSignature = {\n   *   ref: (\"&\" | \"&mut\")?,\n   *   body: OpenMoveTypeSignatureBody,\n   * }\n   *\n   * type OpenMoveTypeSignatureBody =\n   *     \"address\"\n   *   | \"bool\"\n   *   | \"u8\" | \"u16\" | ... | \"u256\"\n   *   | { vector: OpenMoveTypeSignatureBody }\n   *   | {\n   *       datatype {\n   *         package: string,\n   *         module: string,\n   *         type: string,\n   *         typeParameters: [OpenMoveTypeSignatureBody]\n   *       }\n   *     }\n   *   | { typeParameter: number }\n   */\n  OpenMoveTypeSignature: { input: any; output: any; }\n  /** String containing 32B hex-encoded address, with a leading \"0x\". Leading zeroes can be omitted on input but will always appear in outputs (SuiAddress in output is guaranteed to be 66 characters long). */\n  SuiAddress: { input: any; output: any; }\n  /**\n   * An unsigned integer that can hold values up to 2^53 - 1. This can be treated similarly to `Int`,\n   * but it is guaranteed to be non-negative, and it may be larger than 2^32 - 1.\n   */\n  UInt53: { input: any; output: any; }\n};\n\nexport type ActiveJwk = {\n  __typename?: 'ActiveJwk';\n  /** The JWK algorithm parameter, (RFC 7517, Section 4.4). */\n  alg: Scalars['String']['output'];\n  /** The JWK RSA public exponent, (RFC 7517, Section 9.3). */\n  e: Scalars['String']['output'];\n  /** The most recent epoch in which the JWK was validated. */\n  epoch?: Maybe<Epoch>;\n  /** The string (Issuing Authority) that identifies the OIDC provider. */\n  iss: Scalars['String']['output'];\n  /** The string (Key ID) that identifies the JWK among a set of JWKs, (RFC 7517, Section 4.5). */\n  kid: Scalars['String']['output'];\n  /** The JWK key type parameter, (RFC 7517, Section 4.1). */\n  kty: Scalars['String']['output'];\n  /** The JWK RSA modulus, (RFC 7517, Section 9.3). */\n  n: Scalars['String']['output'];\n};\n\nexport type ActiveJwkConnection = {\n  __typename?: 'ActiveJwkConnection';\n  /** A list of edges. */\n  edges: Array<ActiveJwkEdge>;\n  /** A list of nodes. */\n  nodes: Array<ActiveJwk>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type ActiveJwkEdge = {\n  __typename?: 'ActiveJwkEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: ActiveJwk;\n};\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type Address = IOwner & {\n  __typename?: 'Address';\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Total balance of all coins with marker type owned by this address. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this address. */\n  balances: BalanceConnection;\n  /**\n   * The coin objects for this address.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /** The domain explicitly configured as the default domain pointing to this address. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** Objects owned by this address, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this address. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The SuinsRegistration NFTs owned by this address. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  /**\n   * Similar behavior to the `transactionBlocks` in Query but supporting the additional\n   * `AddressTransactionBlockRelationship` filter, which defaults to `SENT`.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  transactionBlocks: TransactionBlockConnection;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The 32-byte address that is an account address (corresponding to a public key). */\nexport type AddressTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  relation?: InputMaybe<AddressTransactionBlockRelationship>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type AddressConnection = {\n  __typename?: 'AddressConnection';\n  /** A list of edges. */\n  edges: Array<AddressEdge>;\n  /** A list of nodes. */\n  nodes: Array<Address>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type AddressEdge = {\n  __typename?: 'AddressEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Address;\n};\n\n/**\n * An address-owned object is owned by a specific 32-byte address that is\n * either an account address (derived from a particular signature scheme) or\n * an object ID. An address-owned object is accessible only to its owner and no others.\n */\nexport type AddressOwner = {\n  __typename?: 'AddressOwner';\n  owner?: Maybe<Owner>;\n};\n\n/** The possible relationship types for a transaction block: sent, or received. */\nexport enum AddressTransactionBlockRelationship {\n  /**\n   * Transactions that this address was involved in, either as the sender, sponsor, or as the\n   * owner of some object that was created, modified or transfered.\n   */\n  Affected = 'AFFECTED',\n  /** Transactions this address has sent. */\n  Sent = 'SENT'\n}\n\n/** System transaction for creating the on-chain state used by zkLogin. */\nexport type AuthenticatorStateCreateTransaction = {\n  __typename?: 'AuthenticatorStateCreateTransaction';\n  /** A workaround to define an empty variant of a GraphQL union. */\n  _?: Maybe<Scalars['Boolean']['output']>;\n};\n\nexport type AuthenticatorStateExpireTransaction = {\n  __typename?: 'AuthenticatorStateExpireTransaction';\n  /** The initial version that the AuthenticatorStateUpdate was shared at. */\n  authenticatorObjInitialSharedVersion: Scalars['UInt53']['output'];\n  /** Expire JWKs that have a lower epoch than this. */\n  minEpoch?: Maybe<Epoch>;\n};\n\n/** System transaction for updating the on-chain state used by zkLogin. */\nexport type AuthenticatorStateUpdateTransaction = {\n  __typename?: 'AuthenticatorStateUpdateTransaction';\n  /** The initial version of the authenticator object that it was shared at. */\n  authenticatorObjInitialSharedVersion: Scalars['UInt53']['output'];\n  /** Epoch of the authenticator state update transaction. */\n  epoch?: Maybe<Epoch>;\n  /** Newly active JWKs (JSON Web Keys). */\n  newActiveJwks: ActiveJwkConnection;\n  /** Consensus round of the authenticator state update. */\n  round: Scalars['UInt53']['output'];\n};\n\n\n/** System transaction for updating the on-chain state used by zkLogin. */\nexport type AuthenticatorStateUpdateTransactionNewActiveJwksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Range of checkpoints that the RPC is guaranteed to produce a consistent response for. */\nexport type AvailableRange = {\n  __typename?: 'AvailableRange';\n  first?: Maybe<Checkpoint>;\n  last?: Maybe<Checkpoint>;\n};\n\n/** The total balance for a particular coin type. */\nexport type Balance = {\n  __typename?: 'Balance';\n  /** How many coins of this type constitute the balance */\n  coinObjectCount?: Maybe<Scalars['UInt53']['output']>;\n  /** Coin type for the balance, such as 0x2::sui::SUI */\n  coinType: MoveType;\n  /** Total balance across all coin objects of the coin type */\n  totalBalance?: Maybe<Scalars['BigInt']['output']>;\n};\n\n/** Effects to the balance (sum of coin values per coin type) owned by an address or object. */\nexport type BalanceChange = {\n  __typename?: 'BalanceChange';\n  /** The signed balance change. */\n  amount?: Maybe<Scalars['BigInt']['output']>;\n  /** The inner type of the coin whose balance has changed (e.g. `0x2::sui::SUI`). */\n  coinType?: Maybe<MoveType>;\n  /** The address or object whose balance has changed. */\n  owner?: Maybe<Owner>;\n};\n\nexport type BalanceChangeConnection = {\n  __typename?: 'BalanceChangeConnection';\n  /** A list of edges. */\n  edges: Array<BalanceChangeEdge>;\n  /** A list of nodes. */\n  nodes: Array<BalanceChange>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type BalanceChangeEdge = {\n  __typename?: 'BalanceChangeEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: BalanceChange;\n};\n\nexport type BalanceConnection = {\n  __typename?: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<BalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<Balance>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type BalanceEdge = {\n  __typename?: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Balance;\n};\n\nexport type BridgeCommitteeInitTransaction = {\n  __typename?: 'BridgeCommitteeInitTransaction';\n  bridgeObjInitialSharedVersion: Scalars['UInt53']['output'];\n};\n\nexport type BridgeStateCreateTransaction = {\n  __typename?: 'BridgeStateCreateTransaction';\n  chainId: Scalars['String']['output'];\n};\n\n/**\n * A system transaction that updates epoch information on-chain (increments the current epoch).\n * Executed by the system once per epoch, without using gas. Epoch change transactions cannot be\n * submitted by users, because validators will refuse to sign them.\n *\n * This transaction kind is deprecated in favour of `EndOfEpochTransaction`.\n */\nexport type ChangeEpochTransaction = {\n  __typename?: 'ChangeEpochTransaction';\n  /** The total amount of gas charged for computation during the previous epoch (in MIST). */\n  computationCharge: Scalars['BigInt']['output'];\n  /** The next (to become) epoch. */\n  epoch?: Maybe<Epoch>;\n  /**\n   * The total gas retained from storage fees, that will not be returned by storage rebates when\n   * the relevant objects are cleaned up (in MIST).\n   */\n  nonRefundableStorageFee: Scalars['BigInt']['output'];\n  /** The protocol version in effect in the new epoch. */\n  protocolVersion: Scalars['UInt53']['output'];\n  /** Time at which the next epoch will start. */\n  startTimestamp: Scalars['DateTime']['output'];\n  /** The total amount of gas charged for storage during the previous epoch (in MIST). */\n  storageCharge: Scalars['BigInt']['output'];\n  /** The SUI returned to transaction senders for cleaning up objects (in MIST). */\n  storageRebate: Scalars['BigInt']['output'];\n  /**\n   * System packages (specifically framework and move stdlib) that are written before the new\n   * epoch starts, to upgrade them on-chain. Validators write these packages out when running the\n   * transaction.\n   */\n  systemPackages: MovePackageConnection;\n};\n\n\n/**\n * A system transaction that updates epoch information on-chain (increments the current epoch).\n * Executed by the system once per epoch, without using gas. Epoch change transactions cannot be\n * submitted by users, because validators will refuse to sign them.\n *\n * This transaction kind is deprecated in favour of `EndOfEpochTransaction`.\n */\nexport type ChangeEpochTransactionSystemPackagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/**\n * Checkpoints contain finalized transactions and are used for node synchronization\n * and global transaction ordering.\n */\nexport type Checkpoint = {\n  __typename?: 'Checkpoint';\n  /** The Base64 serialized BCS bytes of CheckpointSummary for this checkpoint. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * A 32-byte hash that uniquely identifies the checkpoint contents, encoded in Base58. This\n   * hash can be used to verify checkpoint contents by checking signatures against the committee,\n   * Hashing contents to match digest, and checking that the previous checkpoint digest matches.\n   */\n  digest: Scalars['String']['output'];\n  /** The epoch this checkpoint is part of. */\n  epoch?: Maybe<Epoch>;\n  /** The total number of transaction blocks in the network by the end of this checkpoint. */\n  networkTotalTransactions?: Maybe<Scalars['UInt53']['output']>;\n  /** The digest of the checkpoint at the previous sequence number. */\n  previousCheckpointDigest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The computation cost, storage cost, storage rebate, and non-refundable storage fee\n   * accumulated during this epoch, up to and including this checkpoint. These values increase\n   * monotonically across checkpoints in the same epoch, and reset on epoch boundaries.\n   */\n  rollingGasSummary?: Maybe<GasCostSummary>;\n  /**\n   * This checkpoint's position in the total order of finalized checkpoints, agreed upon by\n   * consensus.\n   */\n  sequenceNumber: Scalars['UInt53']['output'];\n  /**\n   * The timestamp at which the checkpoint is agreed to have happened according to consensus.\n   * Transactions that access time in this checkpoint will observe this timestamp.\n   */\n  timestamp: Scalars['DateTime']['output'];\n  /**\n   * Transactions in this checkpoint.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range consists of all transactions in this checkpoint.\n   */\n  transactionBlocks: TransactionBlockConnection;\n  /**\n   * This is an aggregation of signatures from a quorum of validators for the checkpoint\n   * proposal.\n   */\n  validatorSignatures: Scalars['Base64']['output'];\n};\n\n\n/**\n * Checkpoints contain finalized transactions and are used for node synchronization\n * and global transaction ordering.\n */\nexport type CheckpointTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type CheckpointConnection = {\n  __typename?: 'CheckpointConnection';\n  /** A list of edges. */\n  edges: Array<CheckpointEdge>;\n  /** A list of nodes. */\n  nodes: Array<Checkpoint>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type CheckpointEdge = {\n  __typename?: 'CheckpointEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Checkpoint;\n};\n\n/** Filter either by the digest, or the sequence number, or neither, to get the latest checkpoint. */\nexport type CheckpointId = {\n  digest?: InputMaybe<Scalars['String']['input']>;\n  sequenceNumber?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n/** Some 0x2::coin::Coin Move object. */\nexport type Coin = IMoveObject & IObject & IOwner & {\n  __typename?: 'Coin';\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Total balance of all coins with marker type owned by this object. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object. */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /** Balance of this coin object. */\n  coinBalance?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The coin objects for this object.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /**\n   * Displays the contents of the Move object in a JSON string and through GraphQL types. Also\n   * provides the flat representation of the type signature, and the BCS of the corresponding\n   * data.\n   */\n  contents?: Maybe<MoveValue>;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the object's contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The set of named templates defined on-chain for the type of this object, to be handled\n   * off-chain. The server substitutes data from the object into these templates to generate a\n   * display string per template.\n   */\n  display?: Maybe<Array<DisplayEntry>>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /**\n   * Determines whether a transaction can transfer this object, using the TransferObjects\n   * transaction command or `sui::transfer::public_transfer`, both of which require the object to\n   * have the `key` and `store` abilities.\n   */\n  hasPublicTransfer: Scalars['Boolean']['output'];\n  /** Objects owned by this object, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The owner type of this object: Immutable, Shared, Parent, Address */\n  owner?: Maybe<ObjectOwner>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that sent objects to this object.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this object. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Some 0x2::coin::Coin Move object. */\nexport type CoinSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type CoinConnection = {\n  __typename?: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<CoinEdge>;\n  /** A list of nodes. */\n  nodes: Array<Coin>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\nexport type CoinDenyListStateCreateTransaction = {\n  __typename?: 'CoinDenyListStateCreateTransaction';\n  /** A workaround to define an empty variant of a GraphQL union. */\n  _?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** An edge in a connection. */\nexport type CoinEdge = {\n  __typename?: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Coin;\n};\n\n/** The metadata for a coin type. */\nexport type CoinMetadata = IMoveObject & IObject & IOwner & {\n  __typename?: 'CoinMetadata';\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Total balance of all coins with marker type owned by this object. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object. */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * The coin objects for this object.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /**\n   * Displays the contents of the Move object in a JSON string and through GraphQL types. Also\n   * provides the flat representation of the type signature, and the BCS of the corresponding\n   * data.\n   */\n  contents?: Maybe<MoveValue>;\n  /** The number of decimal places used to represent the token. */\n  decimals?: Maybe<Scalars['Int']['output']>;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** Optional description of the token, provided by the creator of the token. */\n  description?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the object's contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The set of named templates defined on-chain for the type of this object, to be handled\n   * off-chain. The server substitutes data from the object into these templates to generate a\n   * display string per template.\n   */\n  display?: Maybe<Array<DisplayEntry>>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /**\n   * Determines whether a transaction can transfer this object, using the TransferObjects\n   * transaction command or `sui::transfer::public_transfer`, both of which require the object to\n   * have the `key` and `store` abilities.\n   */\n  hasPublicTransfer: Scalars['Boolean']['output'];\n  iconUrl?: Maybe<Scalars['String']['output']>;\n  /** Full, official name of the token. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** Objects owned by this object, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The owner type of this object: Immutable, Shared, Parent, Address */\n  owner?: Maybe<ObjectOwner>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that sent objects to this object.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this object. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  /** The overall quantity of tokens that will be issued. */\n  supply?: Maybe<Scalars['BigInt']['output']>;\n  /** The token's identifying abbreviation. */\n  symbol?: Maybe<Scalars['String']['output']>;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The metadata for a coin type. */\nexport type CoinMetadataSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Same as AddressOwner, but the object is versioned by consensus. */\nexport type ConsensusAddressOwner = {\n  __typename?: 'ConsensusAddressOwner';\n  owner?: Maybe<Owner>;\n  startVersion: Scalars['UInt53']['output'];\n};\n\n/**\n * System transaction that runs at the beginning of a checkpoint, and is responsible for setting\n * the current value of the clock, based on the timestamp from consensus.\n */\nexport type ConsensusCommitPrologueTransaction = {\n  __typename?: 'ConsensusCommitPrologueTransaction';\n  /** Unix timestamp from consensus. */\n  commitTimestamp: Scalars['DateTime']['output'];\n  /**\n   * Digest of consensus output, encoded as a Base58 string (only available from V2 of the\n   * transaction).\n   */\n  consensusCommitDigest?: Maybe<Scalars['String']['output']>;\n  /** Epoch of the commit prologue transaction. */\n  epoch?: Maybe<Epoch>;\n  /** Consensus round of the commit. */\n  round: Scalars['UInt53']['output'];\n};\n\nexport type DependencyConnection = {\n  __typename?: 'DependencyConnection';\n  /** A list of edges. */\n  edges: Array<DependencyEdge>;\n  /** A list of nodes. */\n  nodes: Array<TransactionBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type DependencyEdge = {\n  __typename?: 'DependencyEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node?: Maybe<TransactionBlock>;\n};\n\n/**\n * The set of named templates defined on-chain for the type of this object,\n * to be handled off-chain. The server substitutes data from the object\n * into these templates to generate a display string per template.\n */\nexport type DisplayEntry = {\n  __typename?: 'DisplayEntry';\n  /** An error string describing why the template could not be rendered. */\n  error?: Maybe<Scalars['String']['output']>;\n  /** The identifier for a particular template string of the Display object. */\n  key: Scalars['String']['output'];\n  /** The template string for the key with placeholder values substituted. */\n  value?: Maybe<Scalars['String']['output']>;\n};\n\nexport enum DomainFormat {\n  At = 'AT',\n  Dot = 'DOT'\n}\n\nexport type DryRunEffect = {\n  __typename?: 'DryRunEffect';\n  /** Changes made to arguments that were mutably borrowed by each command in this transaction. */\n  mutatedReferences?: Maybe<Array<DryRunMutation>>;\n  /** Return results of each command in this transaction. */\n  returnValues?: Maybe<Array<DryRunReturn>>;\n};\n\nexport type DryRunMutation = {\n  __typename?: 'DryRunMutation';\n  bcs: Scalars['Base64']['output'];\n  input: TransactionArgument;\n  type: MoveType;\n};\n\nexport type DryRunResult = {\n  __typename?: 'DryRunResult';\n  /** The error that occurred during dry run execution, if any. */\n  error?: Maybe<Scalars['String']['output']>;\n  /**\n   * The intermediate results for each command of the dry run execution, including\n   * contents of mutated references and return values.\n   */\n  results?: Maybe<Array<DryRunEffect>>;\n  /** The transaction block representing the dry run execution. */\n  transaction?: Maybe<TransactionBlock>;\n};\n\nexport type DryRunReturn = {\n  __typename?: 'DryRunReturn';\n  bcs: Scalars['Base64']['output'];\n  type: MoveType;\n};\n\n/**\n * Dynamic fields are heterogeneous fields that can be added or removed at runtime,\n * and can have arbitrary user-assigned names. There are two sub-types of dynamic\n * fields:\n *\n * 1) Dynamic Fields can store any value that has the `store` ability, however an object\n * stored in this kind of field will be considered wrapped and will not be accessible\n * directly via its ID by external tools (explorers, wallets, etc) accessing storage.\n * 2) Dynamic Object Fields values must be Sui objects (have the `key` and `store`\n * abilities, and id: UID as the first field), but will still be directly accessible off-chain\n * via their object ID after being attached.\n */\nexport type DynamicField = {\n  __typename?: 'DynamicField';\n  /**\n   * The string type, data, and serialized value of the DynamicField's 'name' field.\n   * This field is used to uniquely identify a child of the parent object.\n   */\n  name?: Maybe<MoveValue>;\n  /**\n   * The returned dynamic field is an object if its return type is `MoveObject`,\n   * in which case it is also accessible off-chain via its address. Its contents\n   * will be from the latest version that is at most equal to its parent object's\n   * version\n   */\n  value?: Maybe<DynamicFieldValue>;\n};\n\nexport type DynamicFieldConnection = {\n  __typename?: 'DynamicFieldConnection';\n  /** A list of edges. */\n  edges: Array<DynamicFieldEdge>;\n  /** A list of nodes. */\n  nodes: Array<DynamicField>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type DynamicFieldEdge = {\n  __typename?: 'DynamicFieldEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: DynamicField;\n};\n\nexport type DynamicFieldName = {\n  /** The Base64 encoded bcs serialization of the DynamicField's 'name' field. */\n  bcs: Scalars['Base64']['input'];\n  /**\n   * The string type of the DynamicField's 'name' field.\n   * A string representation of a Move primitive like 'u64', or a struct type like '0x2::kiosk::Listing'\n   */\n  type: Scalars['String']['input'];\n};\n\nexport type DynamicFieldValue = MoveObject | MoveValue;\n\n/**\n * System transaction that supersedes `ChangeEpochTransaction` as the new way to run transactions\n * at the end of an epoch. Behaves similarly to `ChangeEpochTransaction` but can accommodate other\n * optional transactions to run at the end of the epoch.\n */\nexport type EndOfEpochTransaction = {\n  __typename?: 'EndOfEpochTransaction';\n  /** The list of system transactions that are allowed to run at the end of the epoch. */\n  transactions: EndOfEpochTransactionKindConnection;\n};\n\n\n/**\n * System transaction that supersedes `ChangeEpochTransaction` as the new way to run transactions\n * at the end of an epoch. Behaves similarly to `ChangeEpochTransaction` but can accommodate other\n * optional transactions to run at the end of the epoch.\n */\nexport type EndOfEpochTransactionTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type EndOfEpochTransactionKind = AuthenticatorStateCreateTransaction | AuthenticatorStateExpireTransaction | BridgeCommitteeInitTransaction | BridgeStateCreateTransaction | ChangeEpochTransaction | CoinDenyListStateCreateTransaction | RandomnessStateCreateTransaction | StoreExecutionTimeObservationsTransaction;\n\nexport type EndOfEpochTransactionKindConnection = {\n  __typename?: 'EndOfEpochTransactionKindConnection';\n  /** A list of edges. */\n  edges: Array<EndOfEpochTransactionKindEdge>;\n  /** A list of nodes. */\n  nodes: Array<EndOfEpochTransactionKind>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type EndOfEpochTransactionKindEdge = {\n  __typename?: 'EndOfEpochTransactionKindEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: EndOfEpochTransactionKind;\n};\n\n/**\n * Operation of the Sui network is temporally partitioned into non-overlapping epochs,\n * and the network aims to keep epochs roughly the same duration as each other.\n * During a particular epoch the following data is fixed:\n *\n * - the protocol version\n * - the reference gas price\n * - the set of participating validators\n */\nexport type Epoch = {\n  __typename?: 'Epoch';\n  /** The epoch's corresponding checkpoints. */\n  checkpoints: CheckpointConnection;\n  /** The epoch's ending timestamp. */\n  endTimestamp?: Maybe<Scalars['DateTime']['output']>;\n  /** The epoch's id as a sequence number that starts at 0 and is incremented by one at every epoch change. */\n  epochId: Scalars['UInt53']['output'];\n  /** The storage fees paid for transactions executed during the epoch. */\n  fundInflow?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The storage fee rebates paid to users who deleted the data associated with past\n   * transactions.\n   */\n  fundOutflow?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The storage fund available in this epoch.\n   * This fund is used to redistribute storage fees from past transactions\n   * to future validators.\n   */\n  fundSize?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * A commitment by the committee at the end of epoch on the contents of the live object set at\n   * that time. This can be used to verify state snapshots.\n   */\n  liveObjectSetDigest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The difference between the fund inflow and outflow, representing\n   * the net amount of storage fees accumulated in this epoch.\n   */\n  netInflow?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The epoch's corresponding protocol configuration, including the feature flags and the\n   * configuration options.\n   */\n  protocolConfigs: ProtocolConfigs;\n  /** The minimum gas price that a quorum of validators are guaranteed to sign a transaction for. */\n  referenceGasPrice?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Information about whether this epoch was started in safe mode, which happens if the full epoch\n   * change logic fails for some reason.\n   */\n  safeMode?: Maybe<SafeMode>;\n  /** The epoch's starting timestamp. */\n  startTimestamp: Scalars['DateTime']['output'];\n  /**\n   * SUI set aside to account for objects stored on-chain, at the start of the epoch.\n   * This is also used for storage rebates.\n   */\n  storageFund?: Maybe<StorageFund>;\n  /** Details of the system that are decided during genesis. */\n  systemParameters?: Maybe<SystemParameters>;\n  /** Parameters related to the subsidy that supplements staking rewards */\n  systemStakeSubsidy?: Maybe<StakeSubsidy>;\n  /**\n   * The value of the `version` field of `0x5`, the `0x3::sui::SuiSystemState` object.  This\n   * version changes whenever the fields contained in the system state object (held in a dynamic\n   * field attached to `0x5`) change.\n   */\n  systemStateVersion?: Maybe<Scalars['UInt53']['output']>;\n  /** The total number of checkpoints in this epoch. */\n  totalCheckpoints?: Maybe<Scalars['UInt53']['output']>;\n  /** The total amount of gas fees (in MIST) that were paid in this epoch. */\n  totalGasFees?: Maybe<Scalars['BigInt']['output']>;\n  /** The total MIST rewarded as stake. */\n  totalStakeRewards?: Maybe<Scalars['BigInt']['output']>;\n  /** The amount added to total gas fees to make up the total stake rewards. */\n  totalStakeSubsidies?: Maybe<Scalars['BigInt']['output']>;\n  /** The total number of transaction blocks in this epoch. */\n  totalTransactions?: Maybe<Scalars['UInt53']['output']>;\n  /**\n   * The epoch's corresponding transaction blocks.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range consists of all transactions in this epoch.\n   */\n  transactionBlocks: TransactionBlockConnection;\n  /** Validator related properties, including the active validators. */\n  validatorSet?: Maybe<ValidatorSet>;\n};\n\n\n/**\n * Operation of the Sui network is temporally partitioned into non-overlapping epochs,\n * and the network aims to keep epochs roughly the same duration as each other.\n * During a particular epoch the following data is fixed:\n *\n * - the protocol version\n * - the reference gas price\n * - the set of participating validators\n */\nexport type EpochCheckpointsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Operation of the Sui network is temporally partitioned into non-overlapping epochs,\n * and the network aims to keep epochs roughly the same duration as each other.\n * During a particular epoch the following data is fixed:\n *\n * - the protocol version\n * - the reference gas price\n * - the set of participating validators\n */\nexport type EpochTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type EpochConnection = {\n  __typename?: 'EpochConnection';\n  /** A list of edges. */\n  edges: Array<EpochEdge>;\n  /** A list of nodes. */\n  nodes: Array<Epoch>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type EpochEdge = {\n  __typename?: 'EpochEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Epoch;\n};\n\nexport type Event = {\n  __typename?: 'Event';\n  /** The Base64 encoded BCS serialized bytes of the event. */\n  bcs: Scalars['Base64']['output'];\n  /** The event's contents as a Move value. */\n  contents: MoveValue;\n  /** Address of the sender of the event */\n  sender?: Maybe<Address>;\n  /**\n   * The Move module containing some function that when called by\n   * a programmable transaction block (PTB) emitted this event.\n   * For example, if a PTB invokes A::m1::foo, which internally\n   * calls A::m2::emit_event to emit an event,\n   * the sending module would be A::m1.\n   */\n  sendingModule?: Maybe<MoveModule>;\n  /** UTC timestamp in milliseconds since epoch (1/1/1970) */\n  timestamp?: Maybe<Scalars['DateTime']['output']>;\n  /**\n   * The transaction block that emitted this event. This information is only available for\n   * events from indexed transactions, and not from transactions that have just been executed or\n   * dry-run.\n   */\n  transactionBlock?: Maybe<TransactionBlock>;\n};\n\nexport type EventConnection = {\n  __typename?: 'EventConnection';\n  /** A list of edges. */\n  edges: Array<EventEdge>;\n  /** A list of nodes. */\n  nodes: Array<Event>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type EventEdge = {\n  __typename?: 'EventEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Event;\n};\n\nexport type EventFilter = {\n  /**\n   * Events emitted by a particular module. An event is emitted by a\n   * particular module if some function in the module is called by a\n   * PTB and emits an event.\n   *\n   * Modules can be filtered by their package, or package::module.\n   * We currently do not support filtering by emitting module and event type\n   * at the same time so if both are provided in one filter, the query will error.\n   */\n  emittingModule?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * This field is used to specify the type of event emitted.\n   *\n   * Events can be filtered by their type's package, package::module,\n   * or their fully qualified type name.\n   *\n   * Generic types can be queried by either the generic type name, e.g.\n   * `0x2::coin::Coin`, or by the full type name, such as\n   * `0x2::coin::Coin<0x2::sui::SUI>`.\n   */\n  eventType?: InputMaybe<Scalars['String']['input']>;\n  /** Filter down to events from transactions sent by this address. */\n  sender?: InputMaybe<Scalars['SuiAddress']['input']>;\n  /** Filter down to the events from this transaction (given by its transaction digest). */\n  transactionDigest?: InputMaybe<Scalars['String']['input']>;\n};\n\n/** The result of an execution, including errors that occurred during said execution. */\nexport type ExecutionResult = {\n  __typename?: 'ExecutionResult';\n  /**\n   * The effects of the executed transaction. Since the transaction was just executed\n   * and not indexed yet, fields including `balance_changes`, `timestamp` and `checkpoint`\n   * are not available.\n   */\n  effects: TransactionBlockEffects;\n  /** The errors field captures any errors that occurred during execution */\n  errors?: Maybe<Array<Scalars['String']['output']>>;\n};\n\n/** The execution status of this transaction block: success or failure. */\nexport enum ExecutionStatus {\n  /** The transaction block could not be executed */\n  Failure = 'FAILURE',\n  /** The transaction block was successfully executed */\n  Success = 'SUCCESS'\n}\n\n/**\n * Groups of features served by the RPC service.  The GraphQL Service can be configured to enable\n * or disable these features.\n */\nexport enum Feature {\n  /** Statistics about how the network was running (TPS, top packages, APY, etc) */\n  Analytics = 'ANALYTICS',\n  /** Coin metadata, per-address coin and balance information. */\n  Coins = 'COINS',\n  /** Querying an object's dynamic fields. */\n  DynamicFields = 'DYNAMIC_FIELDS',\n  /** Named packages service (utilizing dotmove package registry). */\n  MoveRegistry = 'MOVE_REGISTRY',\n  /** SuiNS name and reverse name look-up. */\n  NameService = 'NAME_SERVICE',\n  /** Transaction and Event subscriptions. */\n  Subscriptions = 'SUBSCRIPTIONS',\n  /**\n   * Aspects that affect the running of the system that are managed by the\n   * validators either directly, or through system transactions.\n   */\n  SystemState = 'SYSTEM_STATE'\n}\n\n/**\n * Access to the gas inputs, after they have been smashed into one coin. The gas coin can only be\n * used by reference, except for with `TransferObjectsTransaction` that can accept it by value.\n */\nexport type GasCoin = {\n  __typename?: 'GasCoin';\n  /** A workaround to define an empty variant of a GraphQL union. */\n  _?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** Breakdown of gas costs in effects. */\nexport type GasCostSummary = {\n  __typename?: 'GasCostSummary';\n  /** Gas paid for executing this transaction (in MIST). */\n  computationCost?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Part of storage cost that is not reclaimed when data created by this transaction is cleaned\n   * up (in MIST).\n   */\n  nonRefundableStorageFee?: Maybe<Scalars['BigInt']['output']>;\n  /** Gas paid for the data stored on-chain by this transaction (in MIST). */\n  storageCost?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Part of storage cost that can be reclaimed by cleaning up data created by this transaction\n   * (when objects are deleted or an object is modified, which is treated as a deletion followed\n   * by a creation) (in MIST).\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n};\n\n/** Effects related to gas (costs incurred and the identity of the smashed gas object returned). */\nexport type GasEffects = {\n  __typename?: 'GasEffects';\n  gasObject?: Maybe<Object>;\n  gasSummary?: Maybe<GasCostSummary>;\n};\n\n/** Configuration for this transaction's gas price and the coins used to pay for gas. */\nexport type GasInput = {\n  __typename?: 'GasInput';\n  /** The maximum number of gas units that can be expended by executing this transaction */\n  gasBudget?: Maybe<Scalars['BigInt']['output']>;\n  /** Objects used to pay for a transaction's execution and storage */\n  gasPayment: ObjectConnection;\n  /**\n   * An unsigned integer specifying the number of native tokens per gas unit this transaction\n   * will pay (in MIST).\n   */\n  gasPrice?: Maybe<Scalars['BigInt']['output']>;\n  /** Address of the owner of the gas object(s) used */\n  gasSponsor?: Maybe<Address>;\n};\n\n\n/** Configuration for this transaction's gas price and the coins used to pay for gas. */\nexport type GasInputGasPaymentArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** System transaction that initializes the network and writes the initial set of objects on-chain. */\nexport type GenesisTransaction = {\n  __typename?: 'GenesisTransaction';\n  /** Objects to be created during genesis. */\n  objects: ObjectConnection;\n};\n\n\n/** System transaction that initializes the network and writes the initial set of objects on-chain. */\nexport type GenesisTransactionObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/**\n * Interface implemented by all GraphQL types that represent a Move datatype (either structs or\n * enums). This interface is used to provide a way to access fields that are shared by both\n * structs and enums, e.g., the module that the datatype belongs to, the name of the datatype,\n * type parameters etc.\n */\nexport type IMoveDatatype = {\n  /** The abilities of the datatype. */\n  abilities?: Maybe<Array<MoveAbility>>;\n  /** The module that the datatype belongs to. */\n  module: MoveModule;\n  /** The name of the datatype. */\n  name: Scalars['String']['output'];\n  /** The type parameters of the datatype. */\n  typeParameters?: Maybe<Array<MoveStructTypeParameter>>;\n};\n\n/**\n * This interface is implemented by types that represent a Move object on-chain (A Move value whose\n * type has `key`).\n */\nexport type IMoveObject = {\n  /** Displays the contents of the Move object in a JSON string and through GraphQL types. Also provides the flat representation of the type signature, and the BCS of the corresponding data. */\n  contents?: Maybe<MoveValue>;\n  /** The set of named templates defined on-chain for the type of this object, to be handled off-chain. The server substitutes data from the object into these templates to generate a display string per template. */\n  display?: Maybe<Array<DisplayEntry>>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Ownertype.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values whose type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /** Determines whether a transaction can transfer this object, using the TransferObjects transaction command or `sui::transfer::public_transfer`, both of which require the object to have the `key` and `store` abilities. */\n  hasPublicTransfer: Scalars['Boolean']['output'];\n};\n\n\n/**\n * This interface is implemented by types that represent a Move object on-chain (A Move value whose\n * type has `key`).\n */\nexport type IMoveObjectDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * This interface is implemented by types that represent a Move object on-chain (A Move value whose\n * type has `key`).\n */\nexport type IMoveObjectDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * This interface is implemented by types that represent a Move object on-chain (A Move value whose\n * type has `key`).\n */\nexport type IMoveObjectDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n/**\n * Interface implemented by on-chain values that are addressable by an ID (also referred to as its\n * address). This includes Move objects and packages.\n */\nexport type IObject = {\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /** 32-byte hash that identifies the object's current contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The owner type of this object: Immutable, Shared, Parent, Address\n   * Immutable and Shared Objects do not have owners.\n   */\n  owner?: Maybe<ObjectOwner>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /** The transaction blocks that sent objects to this object. */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The current status of the object as read from the off-chain store. The possible states are: NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or system package upgrade transaction. LIVE, the version returned is the most recent for the object, and it is not deleted or wrapped at that version. HISTORICAL, the object was referenced at a specific version or checkpoint, so is fetched from historical tables and may not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or wrapped and only partial information can be loaded. */\n  status: ObjectKind;\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/**\n * Interface implemented by on-chain values that are addressable by an ID (also referred to as its\n * address). This includes Move objects and packages.\n */\nexport type IObjectReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwner = {\n  address: Scalars['SuiAddress']['output'];\n  /** Total balance of all coins with marker type owned by this object or address. If type is not supplied, it defaults to `0x2::sui::SUI`. */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object or address. */\n  balances: BalanceConnection;\n  /**\n   * The coin objects for this object or address.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /** The domain explicitly configured as the default domain pointing to this object or address. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** Objects owned by this object or address, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object or address. */\n  stakedSuis: StakedSuiConnection;\n  /** The SuinsRegistration NFTs owned by this object or address. These grant the owner the capability to manage the associated domain. */\n  suinsRegistrations: SuinsRegistrationConnection;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Interface implemented by GraphQL types representing entities that can own objects. Object owners\n * are identified by an address which can represent either the public key of an account or another\n * object. The same address can only refer to an account or an object, never both, but it is not\n * possible to know which up-front.\n */\nexport type IOwnerSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/**\n * An immutable object is an object that can't be mutated, transferred, or deleted.\n * Immutable objects have no owner, so anyone can use them.\n */\nexport type Immutable = {\n  __typename?: 'Immutable';\n  _?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** One of the input objects or primitive values to the programmable transaction block. */\nexport type Input = {\n  __typename?: 'Input';\n  /** Index of the programmable transaction block input (0-indexed). */\n  ix: Scalars['Int']['output'];\n};\n\n/** Information used by a package to link to a specific version of its dependency. */\nexport type Linkage = {\n  __typename?: 'Linkage';\n  /** The ID on-chain of the first version of the dependency. */\n  originalId: Scalars['SuiAddress']['output'];\n  /** The ID on-chain of the version of the dependency that this package depends on. */\n  upgradedId: Scalars['SuiAddress']['output'];\n  /** The version of the dependency that this package depends on. */\n  version: Scalars['UInt53']['output'];\n};\n\n/** Create a vector (possibly empty). */\nexport type MakeMoveVecTransaction = {\n  __typename?: 'MakeMoveVecTransaction';\n  /** The values to pack into the vector, all of the same type. */\n  elements: Array<TransactionArgument>;\n  /** If the elements are not objects, or the vector is empty, a type must be supplied. */\n  type?: Maybe<MoveType>;\n};\n\n/** Merges `coins` into the first `coin` (produces no results). */\nexport type MergeCoinsTransaction = {\n  __typename?: 'MergeCoinsTransaction';\n  /** The coin to merge into. */\n  coin: TransactionArgument;\n  /** The coins to be merged. */\n  coins: Array<TransactionArgument>;\n};\n\n/** Abilities are keywords in Sui Move that define how types behave at the compiler level. */\nexport enum MoveAbility {\n  /** Enables values to be copied. */\n  Copy = 'COPY',\n  /** Enables values to be popped/dropped. */\n  Drop = 'DROP',\n  /** Enables values to be held directly in global storage. */\n  Key = 'KEY',\n  /** Enables values to be held inside a struct in global storage. */\n  Store = 'STORE'\n}\n\n/** A call to either an entry or a public Move function. */\nexport type MoveCallTransaction = {\n  __typename?: 'MoveCallTransaction';\n  /** The actual function parameters passed in for this move call. */\n  arguments: Array<TransactionArgument>;\n  /** The function being called, resolved. */\n  function?: Maybe<MoveFunction>;\n  /** The name of the function being called. */\n  functionName: Scalars['String']['output'];\n  /** The name of the module the function being called is defined in. */\n  module: Scalars['String']['output'];\n  /** The storage ID of the package the function being called is defined in. */\n  package: Scalars['SuiAddress']['output'];\n  /** The actual type parameters passed in for this move call. */\n  typeArguments: Array<MoveType>;\n};\n\n/**\n * The generic representation of a Move datatype (either a struct or an enum) which exposes common\n * fields and information (module, name, abilities, type parameters etc.) that is shared across\n * them.\n */\nexport type MoveDatatype = IMoveDatatype & {\n  __typename?: 'MoveDatatype';\n  abilities?: Maybe<Array<MoveAbility>>;\n  asMoveEnum?: Maybe<MoveEnum>;\n  asMoveStruct?: Maybe<MoveStruct>;\n  module: MoveModule;\n  name: Scalars['String']['output'];\n  typeParameters?: Maybe<Array<MoveStructTypeParameter>>;\n};\n\nexport type MoveDatatypeConnection = {\n  __typename?: 'MoveDatatypeConnection';\n  /** A list of edges. */\n  edges: Array<MoveDatatypeEdge>;\n  /** A list of nodes. */\n  nodes: Array<MoveDatatype>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MoveDatatypeEdge = {\n  __typename?: 'MoveDatatypeEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MoveDatatype;\n};\n\n/** Description of an enum type, defined in a Move module. */\nexport type MoveEnum = IMoveDatatype & {\n  __typename?: 'MoveEnum';\n  /** The enum's abilities. */\n  abilities?: Maybe<Array<MoveAbility>>;\n  /** The module this enum was originally defined in. */\n  module: MoveModule;\n  /** The enum's (unqualified) type name. */\n  name: Scalars['String']['output'];\n  /**\n   * Constraints on the enum's formal type parameters.  Move bytecode does not name type\n   * parameters, so when they are referenced (e.g. in field types) they are identified by their\n   * index in this list.\n   */\n  typeParameters?: Maybe<Array<MoveStructTypeParameter>>;\n  /**\n   * The names and types of the enum's fields.  Field types reference type parameters, by their\n   * index in the defining enum's `typeParameters` list.\n   */\n  variants?: Maybe<Array<MoveEnumVariant>>;\n};\n\nexport type MoveEnumConnection = {\n  __typename?: 'MoveEnumConnection';\n  /** A list of edges. */\n  edges: Array<MoveEnumEdge>;\n  /** A list of nodes. */\n  nodes: Array<MoveEnum>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MoveEnumEdge = {\n  __typename?: 'MoveEnumEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MoveEnum;\n};\n\nexport type MoveEnumVariant = {\n  __typename?: 'MoveEnumVariant';\n  /**\n   * The names and types of the variant's fields.  Field types reference type parameters, by their\n   * index in the defining enum's `typeParameters` list.\n   */\n  fields?: Maybe<Array<MoveField>>;\n  /** The name of the variant */\n  name: Scalars['String']['output'];\n};\n\n/** Information for a particular field on a Move struct. */\nexport type MoveField = {\n  __typename?: 'MoveField';\n  name: Scalars['String']['output'];\n  type?: Maybe<OpenMoveType>;\n};\n\n/** Signature of a function, defined in a Move module. */\nexport type MoveFunction = {\n  __typename?: 'MoveFunction';\n  /** Whether the function has the `entry` modifier or not. */\n  isEntry?: Maybe<Scalars['Boolean']['output']>;\n  /** The module this function was defined in. */\n  module: MoveModule;\n  /** The function's (unqualified) name. */\n  name: Scalars['String']['output'];\n  /**\n   * The function's parameter types.  These types can reference type parameters introduce by this\n   * function (see `typeParameters`).\n   */\n  parameters?: Maybe<Array<OpenMoveType>>;\n  /**\n   * The function's return types.  There can be multiple because functions in Move can return\n   * multiple values.  These types can reference type parameters introduced by this function (see\n   * `typeParameters`).\n   */\n  return?: Maybe<Array<OpenMoveType>>;\n  /**\n   * Constraints on the function's formal type parameters.  Move bytecode does not name type\n   * parameters, so when they are referenced (e.g. in parameter and return types) they are\n   * identified by their index in this list.\n   */\n  typeParameters?: Maybe<Array<MoveFunctionTypeParameter>>;\n  /** The function's visibility: `public`, `public(friend)`, or `private`. */\n  visibility?: Maybe<MoveVisibility>;\n};\n\nexport type MoveFunctionConnection = {\n  __typename?: 'MoveFunctionConnection';\n  /** A list of edges. */\n  edges: Array<MoveFunctionEdge>;\n  /** A list of nodes. */\n  nodes: Array<MoveFunction>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MoveFunctionEdge = {\n  __typename?: 'MoveFunctionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MoveFunction;\n};\n\nexport type MoveFunctionTypeParameter = {\n  __typename?: 'MoveFunctionTypeParameter';\n  constraints: Array<MoveAbility>;\n};\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModule = {\n  __typename?: 'MoveModule';\n  /** The Base64 encoded bcs serialization of the module. */\n  bytes?: Maybe<Scalars['Base64']['output']>;\n  /** Look-up the definition of a datatype (struct or enum) defined in this module, by its name. */\n  datatype?: Maybe<MoveDatatype>;\n  /** Iterate through the datatypes (enmums and structs) defined in this module. */\n  datatypes?: Maybe<MoveDatatypeConnection>;\n  /** Textual representation of the module's bytecode. */\n  disassembly?: Maybe<Scalars['String']['output']>;\n  /** Look-up the definition of a enum defined in this module, by its name. */\n  enum?: Maybe<MoveEnum>;\n  /** Iterate through the enums defined in this module. */\n  enums?: Maybe<MoveEnumConnection>;\n  /** Format version of this module's bytecode. */\n  fileFormatVersion: Scalars['Int']['output'];\n  /**\n   * Modules that this module considers friends (these modules can access `public(friend)`\n   * functions from this module).\n   */\n  friends: MoveModuleConnection;\n  /** Look-up the signature of a function defined in this module, by its name. */\n  function?: Maybe<MoveFunction>;\n  /** Iterate through the signatures of functions defined in this module. */\n  functions?: Maybe<MoveFunctionConnection>;\n  /** The module's (unqualified) name. */\n  name: Scalars['String']['output'];\n  /** The package that this Move module was defined in */\n  package: MovePackage;\n  /** Look-up the definition of a struct defined in this module, by its name. */\n  struct?: Maybe<MoveStruct>;\n  /** Iterate through the structs defined in this module. */\n  structs?: Maybe<MoveStructConnection>;\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleDatatypeArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleDatatypesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleEnumArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleEnumsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleFriendsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleFunctionArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleFunctionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleStructArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/**\n * Represents a module in Move, a library that defines struct types\n * and functions that operate on these types.\n */\nexport type MoveModuleStructsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type MoveModuleConnection = {\n  __typename?: 'MoveModuleConnection';\n  /** A list of edges. */\n  edges: Array<MoveModuleEdge>;\n  /** A list of nodes. */\n  nodes: Array<MoveModule>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MoveModuleEdge = {\n  __typename?: 'MoveModuleEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MoveModule;\n};\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObject = IMoveObject & IObject & IOwner & {\n  __typename?: 'MoveObject';\n  address: Scalars['SuiAddress']['output'];\n  /** Attempts to convert the Move object into a `0x2::coin::Coin`. */\n  asCoin?: Maybe<Coin>;\n  /** Attempts to convert the Move object into a `0x2::coin::CoinMetadata`. */\n  asCoinMetadata?: Maybe<CoinMetadata>;\n  /** Attempts to convert the Move object into a `0x3::staking_pool::StakedSui`. */\n  asStakedSui?: Maybe<StakedSui>;\n  /** Attempts to convert the Move object into a `SuinsRegistration` object. */\n  asSuinsRegistration?: Maybe<SuinsRegistration>;\n  /**\n   * Total balance of all coins with marker type owned by this object. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object. */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * The coin objects for this object.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /**\n   * Displays the contents of the Move object in a JSON string and through GraphQL types. Also\n   * provides the flat representation of the type signature, and the BCS of the corresponding\n   * data.\n   */\n  contents?: Maybe<MoveValue>;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the object's contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The set of named templates defined on-chain for the type of this object, to be handled\n   * off-chain. The server substitutes data from the object into these templates to generate a\n   * display string per template.\n   */\n  display?: Maybe<Array<DisplayEntry>>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /**\n   * Determines whether a transaction can transfer this object, using the TransferObjects\n   * transaction command or `sui::transfer::public_transfer`, both of which require the object to\n   * have the `key` and `store` abilities.\n   */\n  hasPublicTransfer: Scalars['Boolean']['output'];\n  /** Objects owned by this object, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The owner type of this object: Immutable, Shared, Parent, Address */\n  owner?: Maybe<ObjectOwner>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that sent objects to this object.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this object. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * The representation of an object as a Move Object, which exposes additional information\n * (content, module that governs it, version, is transferrable, etc.) about this object.\n */\nexport type MoveObjectSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type MoveObjectConnection = {\n  __typename?: 'MoveObjectConnection';\n  /** A list of edges. */\n  edges: Array<MoveObjectEdge>;\n  /** A list of nodes. */\n  nodes: Array<MoveObject>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MoveObjectEdge = {\n  __typename?: 'MoveObjectEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MoveObject;\n};\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackage = IObject & IOwner & {\n  __typename?: 'MovePackage';\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Total balance of all coins with marker type owned by this package. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   *\n   * Note that coins owned by a package are inaccessible, because packages are immutable and\n   * cannot be owned by an address.\n   */\n  balance?: Maybe<Balance>;\n  /**\n   * The balances of all coin types owned by this package.\n   *\n   * Note that coins owned by a package are inaccessible, because packages are immutable and\n   * cannot be owned by an address.\n   */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the package's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * The coin objects owned by this package.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   *\n   * Note that coins owned by a package are inaccessible, because packages are immutable and\n   * cannot be owned by an address.\n   */\n  coins: CoinConnection;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the package's contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * Fetch the latest version of this package (the package with the highest `version` that shares\n   * this packages's original ID)\n   */\n  latestPackage: MovePackage;\n  /** The transitive dependencies of this package. */\n  linkage?: Maybe<Array<Linkage>>;\n  /**\n   * A representation of the module called `name` in this package, including the\n   * structs and functions it defines.\n   */\n  module?: Maybe<MoveModule>;\n  /**\n   * BCS representation of the package's modules.  Modules appear as a sequence of pairs (module\n   * name, followed by module bytes), in alphabetic order by module name.\n   */\n  moduleBcs?: Maybe<Scalars['Base64']['output']>;\n  /** Paginate through the MoveModules defined in this package. */\n  modules?: Maybe<MoveModuleConnection>;\n  /**\n   * Objects owned by this package, optionally `filter`-ed.\n   *\n   * Note that objects owned by a package are inaccessible, because packages are immutable and\n   * cannot be owned by an address.\n   */\n  objects: MoveObjectConnection;\n  /**\n   * The owner type of this object: Immutable, Shared, Parent, Address\n   * Packages are always Immutable.\n   */\n  owner?: Maybe<ObjectOwner>;\n  /**\n   * Fetch another version of this package (the package that shares this package's original ID,\n   * but has the specified `version`).\n   */\n  packageAtVersion?: Maybe<MovePackage>;\n  /** BCS representation of the package itself, as a MovePackage. */\n  packageBcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * Fetch all versions of this package (packages that share this package's original ID),\n   * optionally bounding the versions exclusively from below with `afterVersion`, or from above\n   * with `beforeVersion`.\n   */\n  packageVersions: MovePackageConnection;\n  /** The transaction block that published or upgraded this package. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that sent objects to this package.\n   *\n   * Note that objects that have been sent to a package become inaccessible.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /**\n   * The `0x3::staking_pool::StakedSui` objects owned by this package.\n   *\n   * Note that objects owned by a package are inaccessible, because packages are immutable and\n   * cannot be owned by an address.\n   */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   *\n   * Note that packages cannot be deleted or mutated, so this number is provided purely for\n   * reference.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this package. These grant the owner the capability to\n   * manage the associated domain.\n   *\n   * Note that objects owned by a package are inaccessible, because packages are immutable and\n   * cannot be owned by an address.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  /** The (previous) versions of this package that introduced its types. */\n  typeOrigins?: Maybe<Array<TypeOrigin>>;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageModuleArgs = {\n  name: Scalars['String']['input'];\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageModulesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackagePackageAtVersionArgs = {\n  version: Scalars['Int']['input'];\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackagePackageVersionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<MovePackageVersionFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A MovePackage is a kind of Move object that represents code that has been published on chain.\n * It exposes information about its modules, type definitions, functions, and dependencies.\n */\nexport type MovePackageSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Filter for paginating `MovePackage`s that were created within a range of checkpoints. */\nexport type MovePackageCheckpointFilter = {\n  /**\n   * Fetch packages that were published strictly after this checkpoint. Omitting this fetches\n   * packages published since genesis.\n   */\n  afterCheckpoint?: InputMaybe<Scalars['UInt53']['input']>;\n  /**\n   * Fetch packages that were published strictly before this checkpoint. Omitting this fetches\n   * packages published up to the latest checkpoint (inclusive).\n   */\n  beforeCheckpoint?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\nexport type MovePackageConnection = {\n  __typename?: 'MovePackageConnection';\n  /** A list of edges. */\n  edges: Array<MovePackageEdge>;\n  /** A list of nodes. */\n  nodes: Array<MovePackage>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MovePackageEdge = {\n  __typename?: 'MovePackageEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MovePackage;\n};\n\n/** Filter for paginating versions of a given `MovePackage`. */\nexport type MovePackageVersionFilter = {\n  /**\n   * Fetch versions of this package that are strictly newer than this version. Omitting this\n   * fetches versions since the original version.\n   */\n  afterVersion?: InputMaybe<Scalars['UInt53']['input']>;\n  /**\n   * Fetch versions of this package that are strictly older than this version. Omitting this\n   * fetches versions up to the latest version (inclusive).\n   */\n  beforeVersion?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n/** Description of a struct type, defined in a Move module. */\nexport type MoveStruct = IMoveDatatype & {\n  __typename?: 'MoveStruct';\n  /** Abilities this struct has. */\n  abilities?: Maybe<Array<MoveAbility>>;\n  /**\n   * The names and types of the struct's fields.  Field types reference type parameters, by their\n   * index in the defining struct's `typeParameters` list.\n   */\n  fields?: Maybe<Array<MoveField>>;\n  /** The module this struct was originally defined in. */\n  module: MoveModule;\n  /** The struct's (unqualified) type name. */\n  name: Scalars['String']['output'];\n  /**\n   * Constraints on the struct's formal type parameters.  Move bytecode does not name type\n   * parameters, so when they are referenced (e.g. in field types) they are identified by their\n   * index in this list.\n   */\n  typeParameters?: Maybe<Array<MoveStructTypeParameter>>;\n};\n\nexport type MoveStructConnection = {\n  __typename?: 'MoveStructConnection';\n  /** A list of edges. */\n  edges: Array<MoveStructEdge>;\n  /** A list of nodes. */\n  nodes: Array<MoveStruct>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MoveStructEdge = {\n  __typename?: 'MoveStructEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: MoveStruct;\n};\n\nexport type MoveStructTypeParameter = {\n  __typename?: 'MoveStructTypeParameter';\n  constraints: Array<MoveAbility>;\n  isPhantom: Scalars['Boolean']['output'];\n};\n\n/** Represents concrete types (no type parameters, no references). */\nexport type MoveType = {\n  __typename?: 'MoveType';\n  /** The abilities this concrete type has. Returns no abilities if the type is invalid. */\n  abilities?: Maybe<Array<MoveAbility>>;\n  /**\n   * Structured representation of the \"shape\" of values that match this type. May return no\n   * layout if the type is invalid.\n   */\n  layout?: Maybe<Scalars['MoveTypeLayout']['output']>;\n  /** Flat representation of the type signature, as a displayable string. */\n  repr: Scalars['String']['output'];\n  /** Structured representation of the type signature. */\n  signature: Scalars['MoveTypeSignature']['output'];\n};\n\nexport type MoveValue = {\n  __typename?: 'MoveValue';\n  /** The BCS representation of this value, Base64 encoded. */\n  bcs: Scalars['Base64']['output'];\n  /** Structured contents of a Move value. */\n  data: Scalars['MoveData']['output'];\n  /**\n   * Representation of a Move value in JSON, where:\n   *\n   * - Addresses, IDs, and UIDs are represented in canonical form, as JSON strings.\n   * - Bools are represented by JSON boolean literals.\n   * - u8, u16, and u32 are represented as JSON numbers.\n   * - u64, u128, and u256 are represented as JSON strings.\n   * - Vectors are represented by JSON arrays.\n   * - Structs are represented by JSON objects.\n   * - Empty optional values are represented by `null`.\n   *\n   * This form is offered as a less verbose convenience in cases where the layout of the type is\n   * known by the client.\n   */\n  json: Scalars['JSON']['output'];\n  /** The value's Move type. */\n  type: MoveType;\n};\n\n/**\n * The visibility modifier describes which modules can access this module member.\n * By default, a module member can be called only within the same module.\n */\nexport enum MoveVisibility {\n  /**\n   * A friend member can be accessed in the module it is defined in and any other module in\n   * its package that is explicitly specified in its friend list.\n   */\n  Friend = 'FRIEND',\n  /** A private member can be accessed in the module it is defined in. */\n  Private = 'PRIVATE',\n  /** A public member can be accessed by any module. */\n  Public = 'PUBLIC'\n}\n\n/** Mutations are used to write to the Sui network. */\nexport type Mutation = {\n  __typename?: 'Mutation';\n  /**\n   * Execute a transaction, committing its effects on chain.\n   *\n   * - `txBytes` is a `TransactionData` struct that has been BCS-encoded and then Base64-encoded.\n   * - `signatures` are a list of `flag || signature || pubkey` bytes, Base64-encoded.\n   *\n   * Waits until the transaction has reached finality on chain to return its transaction digest,\n   * or returns the error that prevented finality if that was not possible. A transaction is\n   * final when its effects are guaranteed on chain (it cannot be revoked).\n   *\n   * There may be a delay between transaction finality and when GraphQL requests (including the\n   * request that issued the transaction) reflect its effects. As a result, queries that depend\n   * on indexing the state of the chain (e.g. contents of output objects, address-level balance\n   * information at the time of the transaction), must wait for indexing to catch up by polling\n   * for the transaction digest using `Query.transactionBlock`.\n   */\n  executeTransactionBlock: ExecutionResult;\n};\n\n\n/** Mutations are used to write to the Sui network. */\nexport type MutationExecuteTransactionBlockArgs = {\n  signatures: Array<Scalars['String']['input']>;\n  txBytes: Scalars['String']['input'];\n};\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type Object = IObject & IOwner & {\n  __typename?: 'Object';\n  address: Scalars['SuiAddress']['output'];\n  /** Attempts to convert the object into a MoveObject */\n  asMoveObject?: Maybe<MoveObject>;\n  /** Attempts to convert the object into a MovePackage */\n  asMovePackage?: Maybe<MovePackage>;\n  /**\n   * Total balance of all coins with marker type owned by this object. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object. */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * The coin objects for this object.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the object's current contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The set of named templates defined on-chain for the type of this object, to be handled\n   * off-chain. The server substitutes data from the object into these templates to generate a\n   * display string per template.\n   */\n  display?: Maybe<Array<DisplayEntry>>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /** Objects owned by this object, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /**\n   * The owner type of this object: Immutable, Shared, Parent, Address\n   * Immutable and Shared Objects do not have owners.\n   */\n  owner?: Maybe<ObjectOwner>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that sent objects to this object.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this object. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An object in Sui is a package (set of Move bytecode modules) or object (typed data structure\n * with fields) with additional metadata detailing its id, version, transaction digest, owner\n * field indicating how this object can be accessed.\n */\nexport type ObjectSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Effect on an individual Object (keyed by its ID). */\nexport type ObjectChange = {\n  __typename?: 'ObjectChange';\n  /** The address of the object that has changed. */\n  address: Scalars['SuiAddress']['output'];\n  /** Whether the ID was created in this transaction. */\n  idCreated?: Maybe<Scalars['Boolean']['output']>;\n  /** Whether the ID was deleted in this transaction. */\n  idDeleted?: Maybe<Scalars['Boolean']['output']>;\n  /** The contents of the object immediately before the transaction. */\n  inputState?: Maybe<Object>;\n  /** The contents of the object immediately after the transaction. */\n  outputState?: Maybe<Object>;\n};\n\nexport type ObjectChangeConnection = {\n  __typename?: 'ObjectChangeConnection';\n  /** A list of edges. */\n  edges: Array<ObjectChangeEdge>;\n  /** A list of nodes. */\n  nodes: Array<ObjectChange>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type ObjectChangeEdge = {\n  __typename?: 'ObjectChangeEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: ObjectChange;\n};\n\nexport type ObjectConnection = {\n  __typename?: 'ObjectConnection';\n  /** A list of edges. */\n  edges: Array<ObjectEdge>;\n  /** A list of nodes. */\n  nodes: Array<Object>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type ObjectEdge = {\n  __typename?: 'ObjectEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Object;\n};\n\n/**\n * Constrains the set of objects returned. All filters are optional, and the resulting set of\n * objects are ones whose\n *\n * - Type matches the `type` filter,\n * - AND, whose owner matches the `owner` filter,\n * - AND, whose ID is in `objectIds`.\n */\nexport type ObjectFilter = {\n  /** Filter for live objects by their IDs. */\n  objectIds?: InputMaybe<Array<Scalars['SuiAddress']['input']>>;\n  /** Filter for live objects by their current owners. */\n  owner?: InputMaybe<Scalars['SuiAddress']['input']>;\n  /**\n   * Filter objects by their type's `package`, `package::module`, or their fully qualified type\n   * name.\n   *\n   * Generic types can be queried by either the generic type name, e.g. `0x2::coin::Coin`, or by\n   * the full type name, such as `0x2::coin::Coin<0x2::sui::SUI>`.\n   */\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\nexport type ObjectKey = {\n  objectId: Scalars['SuiAddress']['input'];\n  version: Scalars['UInt53']['input'];\n};\n\nexport enum ObjectKind {\n  /** The object is fetched from the index. */\n  Indexed = 'INDEXED',\n  /**\n   * The object is loaded from serialized data, such as the contents of a transaction that hasn't\n   * been indexed yet.\n   */\n  NotIndexed = 'NOT_INDEXED'\n}\n\n/** The object's owner type: Immutable, Shared, Parent, Address, or ConsensusAddress. */\nexport type ObjectOwner = AddressOwner | ConsensusAddressOwner | Immutable | Parent | Shared;\n\nexport type ObjectRef = {\n  /** ID of the object. */\n  address: Scalars['SuiAddress']['input'];\n  /** Digest of the object. */\n  digest: Scalars['String']['input'];\n  /** Version or sequence number of the object. */\n  version: Scalars['UInt53']['input'];\n};\n\n/**\n * Represents types that could contain references or free type parameters.  Such types can appear\n * as function parameters, in fields of structs, or as actual type parameter.\n */\nexport type OpenMoveType = {\n  __typename?: 'OpenMoveType';\n  /** Flat representation of the type signature, as a displayable string. */\n  repr: Scalars['String']['output'];\n  /** Structured representation of the type signature. */\n  signature: Scalars['OpenMoveTypeSignature']['output'];\n};\n\n/** A Move object, either immutable, or owned mutable. */\nexport type OwnedOrImmutable = {\n  __typename?: 'OwnedOrImmutable';\n  /** ID of the object being read. */\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * 32-byte hash that identifies the object's contents at this version, encoded as a Base58\n   * string.\n   */\n  digest: Scalars['String']['output'];\n  /** The object at this version.  May not be available due to pruning. */\n  object?: Maybe<Object>;\n  /** Version of the object being read. */\n  version: Scalars['UInt53']['output'];\n};\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type Owner = IOwner & {\n  __typename?: 'Owner';\n  address: Scalars['SuiAddress']['output'];\n  asAddress?: Maybe<Address>;\n  asObject?: Maybe<Object>;\n  /**\n   * Total balance of all coins with marker type owned by this object or address. If type is not\n   * supplied, it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object or address. */\n  balances: BalanceConnection;\n  /**\n   * The coin objects for this object or address.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /** The domain explicitly configured as the default domain pointing to this object or address. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * This field exists as a convenience when accessing a dynamic field on a wrapped object.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * This field exists as a convenience when accessing a dynamic field on a wrapped object.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * This field exists as a convenience when accessing a dynamic field on a wrapped object.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /** Objects owned by this object or address, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object or address. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The SuinsRegistration NFTs owned by this object or address. These grant the owner the\n   * capability to manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * An Owner is an entity that can own an object. Each Owner is identified by a SuiAddress which\n * represents either an Address (corresponding to a public key of an account) or an Object, but\n * never both (it is not known up-front whether a given Owner is an Address or an Object).\n */\nexport type OwnerSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/** Information about pagination in a connection */\nexport type PageInfo = {\n  __typename?: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']['output']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean']['output'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean']['output'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']['output']>;\n};\n\n/**\n * If the object's owner is a Parent, this object is part of a dynamic field (it is the value of\n * the dynamic field, or the intermediate Field object itself), and it is owned by another object.\n *\n * Although its owner is guaranteed to be an object, it is exposed as an Owner, as the parent\n * object could be wrapped and therefore not directly accessible.\n */\nexport type Parent = {\n  __typename?: 'Parent';\n  parent?: Maybe<Owner>;\n};\n\n/** A single transaction, or command, in the programmable transaction block. */\nexport type ProgrammableTransaction = MakeMoveVecTransaction | MergeCoinsTransaction | MoveCallTransaction | PublishTransaction | SplitCoinsTransaction | TransferObjectsTransaction | UpgradeTransaction;\n\n/**\n * A user transaction that allows the interleaving of native commands (like transfer, split coins,\n * merge coins, etc) and move calls, executed atomically.\n */\nexport type ProgrammableTransactionBlock = {\n  __typename?: 'ProgrammableTransactionBlock';\n  /** Input objects or primitive values. */\n  inputs: TransactionInputConnection;\n  /** The transaction commands, executed sequentially. */\n  transactions: ProgrammableTransactionConnection;\n};\n\n\n/**\n * A user transaction that allows the interleaving of native commands (like transfer, split coins,\n * merge coins, etc) and move calls, executed atomically.\n */\nexport type ProgrammableTransactionBlockInputsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/**\n * A user transaction that allows the interleaving of native commands (like transfer, split coins,\n * merge coins, etc) and move calls, executed atomically.\n */\nexport type ProgrammableTransactionBlockTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type ProgrammableTransactionConnection = {\n  __typename?: 'ProgrammableTransactionConnection';\n  /** A list of edges. */\n  edges: Array<ProgrammableTransactionEdge>;\n  /** A list of nodes. */\n  nodes: Array<ProgrammableTransaction>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type ProgrammableTransactionEdge = {\n  __typename?: 'ProgrammableTransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: ProgrammableTransaction;\n};\n\n/** A single protocol configuration value. */\nexport type ProtocolConfigAttr = {\n  __typename?: 'ProtocolConfigAttr';\n  key: Scalars['String']['output'];\n  value?: Maybe<Scalars['String']['output']>;\n};\n\n/** Whether or not a single feature is enabled in the protocol config. */\nexport type ProtocolConfigFeatureFlag = {\n  __typename?: 'ProtocolConfigFeatureFlag';\n  key: Scalars['String']['output'];\n  value: Scalars['Boolean']['output'];\n};\n\n/**\n * Constants that control how the chain operates.\n *\n * These can only change during protocol upgrades which happen on epoch boundaries.\n */\nexport type ProtocolConfigs = {\n  __typename?: 'ProtocolConfigs';\n  /** Query for the value of the configuration with name `key`. */\n  config?: Maybe<ProtocolConfigAttr>;\n  /**\n   * List all available configurations and their values.  These configurations can take any value\n   * (but they will all be represented in string form), and do not include feature flags.\n   */\n  configs: Array<ProtocolConfigAttr>;\n  /** Query for the state of the feature flag with name `key`. */\n  featureFlag?: Maybe<ProtocolConfigFeatureFlag>;\n  /**\n   * List all available feature flags and their values.  Feature flags are a form of boolean\n   * configuration that are usually used to gate features while they are in development.  Once a\n   * flag has been enabled, it is rare for it to be disabled.\n   */\n  featureFlags: Array<ProtocolConfigFeatureFlag>;\n  /**\n   * The protocol is not required to change on every epoch boundary, so the protocol version\n   * tracks which change to the protocol these configs are from.\n   */\n  protocolVersion: Scalars['UInt53']['output'];\n};\n\n\n/**\n * Constants that control how the chain operates.\n *\n * These can only change during protocol upgrades which happen on epoch boundaries.\n */\nexport type ProtocolConfigsConfigArgs = {\n  key: Scalars['String']['input'];\n};\n\n\n/**\n * Constants that control how the chain operates.\n *\n * These can only change during protocol upgrades which happen on epoch boundaries.\n */\nexport type ProtocolConfigsFeatureFlagArgs = {\n  key: Scalars['String']['input'];\n};\n\n/** Publishes a Move Package. */\nexport type PublishTransaction = {\n  __typename?: 'PublishTransaction';\n  /** IDs of the transitive dependencies of the package to be published. */\n  dependencies: Array<Scalars['SuiAddress']['output']>;\n  /** Bytecode for the modules to be published, BCS serialized and Base64 encoded. */\n  modules: Array<Scalars['Base64']['output']>;\n};\n\n/** BCS encoded primitive value (not an object or Move struct). */\nexport type Pure = {\n  __typename?: 'Pure';\n  /** BCS serialized and Base64 encoded primitive value. */\n  bytes: Scalars['Base64']['output'];\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  /** Look-up an Account by its SuiAddress. */\n  address?: Maybe<Address>;\n  /**\n   * Range of checkpoints that the RPC has data available for (for data\n   * that can be tied to a particular checkpoint).\n   */\n  availableRange: AvailableRange;\n  /**\n   * First four bytes of the network's genesis checkpoint digest (uniquely identifies the\n   * network).\n   */\n  chainIdentifier: Scalars['String']['output'];\n  /**\n   * Fetch checkpoint information by sequence number or digest (defaults to the latest available\n   * checkpoint).\n   */\n  checkpoint?: Maybe<Checkpoint>;\n  /** The checkpoints that exist in the network. */\n  checkpoints: CheckpointConnection;\n  /**\n   * The coin metadata associated with the given coin type. Note that if the latest version of\n   * the coin's metadata is wrapped or deleted, it will not be found.\n   */\n  coinMetadata?: Maybe<CoinMetadata>;\n  /**\n   * The coin objects that exist in the network.\n   *\n   * The type field is a string of the inner type of the coin by which to filter (e.g.\n   * `0x2::sui::SUI`). If no type is provided, it will default to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /**\n   * Simulate running a transaction to inspect its effects without\n   * committing to them on-chain.\n   *\n   * `txBytes` either a `TransactionData` struct or a `TransactionKind`\n   * struct, BCS-encoded and then Base64-encoded.  The expected\n   * type is controlled by the presence or absence of `txMeta`: If\n   * present, `txBytes` is assumed to be a `TransactionKind`, if\n   * absent, then `TransactionData`.\n   *\n   * `txMeta` the data that is missing from a `TransactionKind` to make\n   * a `TransactionData` (sender address and gas information).  All\n   * its fields are nullable.\n   *\n   * `skipChecks` optional flag to disable the usual verification\n   * checks that prevent access to objects that are owned by\n   * addresses other than the sender, and calling non-public,\n   * non-entry functions, and some other checks.  Defaults to false.\n   */\n  dryRunTransactionBlock: DryRunResult;\n  /** Fetch epoch information by ID (defaults to the latest epoch). */\n  epoch?: Maybe<Epoch>;\n  epochs: EpochConnection;\n  /**\n   * Query events that are emitted in the network.\n   * We currently do not support filtering by emitting module and event type\n   * at the same time so if both are provided in one filter, the query will error.\n   */\n  events: EventConnection;\n  /**\n   * The latest version of the package at `address`.\n   *\n   * This corresponds to the package with the highest `version` that shares its original ID with\n   * the package at `address`.\n   */\n  latestPackage?: Maybe<MovePackage>;\n  /** Fetch a list of objects by their IDs and versions. */\n  multiGetObjects: Array<Maybe<Object>>;\n  /**\n   * The object corresponding to the given address at the (optionally) given version.\n   * When no version is given, the latest version is returned.\n   */\n  object?: Maybe<Object>;\n  /** The objects that exist in the network. */\n  objects: ObjectConnection;\n  /**\n   * Look up an Owner by its SuiAddress.\n   *\n   * `rootVersion` represents the version of the root object in some nested chain of dynamic\n   * fields. It allows consistent historical queries for the case of wrapped objects, which don't\n   * have a version. For example, if querying the dynamic field of a table wrapped in a parent\n   * object, passing the parent object's version here will ensure we get the dynamic field's\n   * state at the moment that parent's version was created.\n   *\n   * Also, if this Owner is an object itself, `rootVersion` will be used to bound its version\n   * from above when querying `Owner.asObject`. This can be used, for example, to get the\n   * contents of a dynamic object field when its parent was at `rootVersion`.\n   *\n   * If `rootVersion` is omitted, dynamic fields will be from a consistent snapshot of the Sui\n   * state at the latest checkpoint known to the GraphQL RPC. Similarly, `Owner.asObject` will\n   * return the object's version at the latest checkpoint.\n   */\n  owner?: Maybe<Owner>;\n  /**\n   * The package corresponding to the given address (at the optionally given version).\n   *\n   * When no version is given, the package is loaded directly from the address given. Otherwise,\n   * the address is translated before loading to point to the package whose original ID matches\n   * the package at `address`, but whose version is `version`. For non-system packages, this\n   * might result in a different address than `address` because different versions of a package,\n   * introduced by upgrades, exist at distinct addresses.\n   *\n   * Note that this interpretation of `version` is different from a historical object read (the\n   * interpretation of `version` for the `object` query).\n   */\n  package?: Maybe<MovePackage>;\n  /** Fetch a package by its name (using dot move service) */\n  packageByName?: Maybe<MovePackage>;\n  /**\n   * Fetch all versions of package at `address` (packages that share this package's original ID),\n   * optionally bounding the versions exclusively from below with `afterVersion`, or from above\n   * with `beforeVersion`.\n   */\n  packageVersions: MovePackageConnection;\n  /**\n   * The Move packages that exist in the network, optionally filtered to be strictly before\n   * `beforeCheckpoint` and/or strictly after `afterCheckpoint`.\n   *\n   * This query returns all versions of a given user package that appear between the specified\n   * checkpoints, but only records the latest versions of system packages.\n   */\n  packages: MovePackageConnection;\n  /**\n   * Fetch the protocol config by protocol version (defaults to the latest protocol\n   * version known to the GraphQL service).\n   */\n  protocolConfig: ProtocolConfigs;\n  /** Resolves a SuiNS `domain` name to an address, if it has been bound. */\n  resolveSuinsAddress?: Maybe<Address>;\n  /** Configuration for this RPC service */\n  serviceConfig: ServiceConfig;\n  /** Fetch a transaction block by its transaction digest. */\n  transactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that exist in the network.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  transactionBlocks: TransactionBlockConnection;\n  /**\n   * Fetch a structured representation of a concrete type, including its layout information.\n   * Fails if the type is malformed.\n   */\n  type: MoveType;\n  /** Fetch a type that includes dot move service names in it. */\n  typeByName: MoveType;\n  /**\n   * Verify a zkLogin signature based on the provided transaction or personal message\n   * based on current epoch, chain id, and latest JWKs fetched on-chain. If the\n   * signature is valid, the function returns a `ZkLoginVerifyResult` with success as\n   * true and an empty list of errors. If the signature is invalid, the function returns\n   * a `ZkLoginVerifyResult` with success as false with a list of errors.\n   *\n   * - `bytes` is either the personal message in raw bytes or transaction data bytes in\n   * BCS-encoded and then Base64-encoded.\n   * - `signature` is a serialized zkLogin signature that is Base64-encoded.\n   * - `intentScope` is an enum that specifies the intent scope to be used to parse bytes.\n   * - `author` is the address of the signer of the transaction or personal msg.\n   */\n  verifyZkloginSignature: ZkLoginVerifyResult;\n};\n\n\nexport type QueryAddressArgs = {\n  address: Scalars['SuiAddress']['input'];\n};\n\n\nexport type QueryCheckpointArgs = {\n  id?: InputMaybe<CheckpointId>;\n};\n\n\nexport type QueryCheckpointsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryCoinMetadataArgs = {\n  coinType: Scalars['String']['input'];\n};\n\n\nexport type QueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\nexport type QueryDryRunTransactionBlockArgs = {\n  skipChecks?: InputMaybe<Scalars['Boolean']['input']>;\n  txBytes: Scalars['String']['input'];\n  txMeta?: InputMaybe<TransactionMetadata>;\n};\n\n\nexport type QueryEpochArgs = {\n  id?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n\nexport type QueryEpochsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryEventsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<EventFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryLatestPackageArgs = {\n  address: Scalars['SuiAddress']['input'];\n};\n\n\nexport type QueryMultiGetObjectsArgs = {\n  keys: Array<ObjectKey>;\n};\n\n\nexport type QueryObjectArgs = {\n  address: Scalars['SuiAddress']['input'];\n  version?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n\nexport type QueryObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryOwnerArgs = {\n  address: Scalars['SuiAddress']['input'];\n  rootVersion?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n\nexport type QueryPackageArgs = {\n  address: Scalars['SuiAddress']['input'];\n  version?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n\nexport type QueryPackageByNameArgs = {\n  name: Scalars['String']['input'];\n};\n\n\nexport type QueryPackageVersionsArgs = {\n  address: Scalars['SuiAddress']['input'];\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<MovePackageVersionFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryPackagesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<MovePackageCheckpointFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryProtocolConfigArgs = {\n  protocolVersion?: InputMaybe<Scalars['UInt53']['input']>;\n};\n\n\nexport type QueryResolveSuinsAddressArgs = {\n  domain: Scalars['String']['input'];\n};\n\n\nexport type QueryTransactionBlockArgs = {\n  digest: Scalars['String']['input'];\n};\n\n\nexport type QueryTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type QueryTypeArgs = {\n  type: Scalars['String']['input'];\n};\n\n\nexport type QueryTypeByNameArgs = {\n  name: Scalars['String']['input'];\n};\n\n\nexport type QueryVerifyZkloginSignatureArgs = {\n  author: Scalars['SuiAddress']['input'];\n  bytes: Scalars['Base64']['input'];\n  intentScope: ZkLoginIntentScope;\n  signature: Scalars['Base64']['input'];\n};\n\nexport type RandomnessStateCreateTransaction = {\n  __typename?: 'RandomnessStateCreateTransaction';\n  /** A workaround to define an empty variant of a GraphQL union. */\n  _?: Maybe<Scalars['Boolean']['output']>;\n};\n\n/** System transaction to update the source of on-chain randomness. */\nexport type RandomnessStateUpdateTransaction = {\n  __typename?: 'RandomnessStateUpdateTransaction';\n  /** Epoch of the randomness state update transaction. */\n  epoch?: Maybe<Epoch>;\n  /** Updated random bytes, encoded as Base64. */\n  randomBytes: Scalars['Base64']['output'];\n  /** The initial version the randomness object was shared at. */\n  randomnessObjInitialSharedVersion: Scalars['UInt53']['output'];\n  /** Randomness round of the update. */\n  randomnessRound: Scalars['UInt53']['output'];\n};\n\n/** A Move object that can be received in this transaction. */\nexport type Receiving = {\n  __typename?: 'Receiving';\n  /** ID of the object being read. */\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * 32-byte hash that identifies the object's contents at this version, encoded as a Base58\n   * string.\n   */\n  digest: Scalars['String']['output'];\n  /** The object at this version.  May not be available due to pruning. */\n  object?: Maybe<Object>;\n  /** Version of the object being read. */\n  version: Scalars['UInt53']['output'];\n};\n\n/** The result of another transaction command. */\nexport type Result = {\n  __typename?: 'Result';\n  /** The index of the previous command (0-indexed) that returned this result. */\n  cmd: Scalars['Int']['output'];\n  /**\n   * If the previous command returns multiple values, this is the index of the individual result\n   * among the multiple results from that command (also 0-indexed).\n   */\n  ix?: Maybe<Scalars['Int']['output']>;\n};\n\n/** Information about whether epoch changes are using safe mode. */\nexport type SafeMode = {\n  __typename?: 'SafeMode';\n  /**\n   * Whether safe mode was used for the last epoch change.  The system will retry a full epoch\n   * change on every epoch boundary and automatically reset this flag if so.\n   */\n  enabled?: Maybe<Scalars['Boolean']['output']>;\n  /**\n   * Accumulated fees for computation and cost that have not been added to the various reward\n   * pools, because the full epoch change did not happen.\n   */\n  gasSummary?: Maybe<GasCostSummary>;\n};\n\n/** The enabled features and service limits configured by the server. */\nexport type ServiceConfig = {\n  __typename?: 'ServiceConfig';\n  /** Default number of elements allowed on a single page of a connection. */\n  defaultPageSize: Scalars['Int']['output'];\n  /** List of all features that are enabled on this GraphQL service. */\n  enabledFeatures: Array<Feature>;\n  /** Check whether `feature` is enabled on this GraphQL service. */\n  isEnabled: Scalars['Boolean']['output'];\n  /**\n   * Maximum estimated cost of a database query used to serve a GraphQL request.  This is\n   * measured in the same units that the database uses in EXPLAIN queries.\n   */\n  maxDbQueryCost: Scalars['Int']['output'];\n  /** Maximum nesting allowed in struct fields when calculating the layout of a single Move Type. */\n  maxMoveValueDepth: Scalars['Int']['output'];\n  /** Maximum number of keys that can be passed to a `multiGetObjects` query. */\n  maxMultiGetObjectsKeys: Scalars['Int']['output'];\n  /**\n   * The maximum number of output nodes in a GraphQL response.\n   *\n   * Non-connection nodes have a count of 1, while connection nodes are counted as\n   * the specified 'first' or 'last' number of items, or the default_page_size\n   * as set by the server if those arguments are not set.\n   *\n   * Counts accumulate multiplicatively down the query tree. For example, if a query starts\n   * with a connection of first: 10 and has a field to a connection with last: 20, the count\n   * at the second level would be 200 nodes. This is then summed to the count of 10 nodes\n   * at the first level, for a total of 210 nodes.\n   */\n  maxOutputNodes: Scalars['Int']['output'];\n  /** Maximum number of elements allowed on a single page of a connection. */\n  maxPageSize: Scalars['Int']['output'];\n  /** The maximum depth a GraphQL query can be to be accepted by this service. */\n  maxQueryDepth: Scalars['Int']['output'];\n  /** The maximum number of nodes (field names) the service will accept in a single query. */\n  maxQueryNodes: Scalars['Int']['output'];\n  /**\n   * The maximum bytes allowed for the JSON object in the request body of a GraphQL query, for\n   * the read part of the query.\n   * In case of mutations or dryRunTransactionBlocks the txBytes and signatures are not\n   * included in this limit.\n   */\n  maxQueryPayloadSize: Scalars['Int']['output'];\n  /** Maximum number of candidates to scan when gathering a page of results. */\n  maxScanLimit: Scalars['Int']['output'];\n  /** Maximum number of transaction ids that can be passed to a `TransactionBlockFilter`. */\n  maxTransactionIds: Scalars['Int']['output'];\n  /**\n   * The maximum bytes allowed for the `txBytes` and `signatures` fields of the GraphQL mutation\n   * `executeTransactionBlock` node, or for the `txBytes` of a `dryRunTransactionBlock`.\n   *\n   * It is the value of the maximum transaction bytes (including the signatures) allowed by the\n   * protocol, plus the Base64 overhead (roughly 1/3 of the original string).\n   */\n  maxTransactionPayloadSize: Scalars['Int']['output'];\n  /** Maximum nesting allowed in type arguments in Move Types resolved by this service. */\n  maxTypeArgumentDepth: Scalars['Int']['output'];\n  /**\n   * Maximum number of type arguments passed into a generic instantiation of a Move Type resolved\n   * by this service.\n   */\n  maxTypeArgumentWidth: Scalars['Int']['output'];\n  /**\n   * Maximum number of structs that need to be processed when calculating the layout of a single\n   * Move Type.\n   */\n  maxTypeNodes: Scalars['Int']['output'];\n  /**\n   * Maximum time in milliseconds spent waiting for a response from fullnode after issuing a\n   * a transaction to execute. Note that the transaction may still succeed even in the case of a\n   * timeout. Transactions are idempotent, so a transaction that times out should be resubmitted\n   * until the network returns a definite response (success or failure, not timeout).\n   */\n  mutationTimeoutMs: Scalars['Int']['output'];\n  /** Maximum time in milliseconds that will be spent to serve one query request. */\n  requestTimeoutMs: Scalars['Int']['output'];\n};\n\n\n/** The enabled features and service limits configured by the server. */\nexport type ServiceConfigIsEnabledArgs = {\n  feature: Feature;\n};\n\n/**\n * A shared object is an object that is shared using the 0x2::transfer::share_object function.\n * Unlike owned objects, once an object is shared, it stays mutable and is accessible by anyone.\n */\nexport type Shared = {\n  __typename?: 'Shared';\n  initialSharedVersion: Scalars['UInt53']['output'];\n};\n\n/** A Move object that's shared. */\nexport type SharedInput = {\n  __typename?: 'SharedInput';\n  address: Scalars['SuiAddress']['output'];\n  /** The version that this this object was shared at. */\n  initialSharedVersion: Scalars['UInt53']['output'];\n  /**\n   * Controls whether the transaction block can reference the shared object as a mutable\n   * reference or by value. This has implications for scheduling: Transactions that just read\n   * shared objects at a certain version (mutable = false) can be executed concurrently, while\n   * transactions that write shared objects (mutable = true) must be executed serially with\n   * respect to each other.\n   */\n  mutable: Scalars['Boolean']['output'];\n};\n\n/** The transaction accpeted a shared object as input, but its execution was cancelled. */\nexport type SharedObjectCancelled = {\n  __typename?: 'SharedObjectCancelled';\n  /** ID of the shared object. */\n  address: Scalars['SuiAddress']['output'];\n  /** The assigned shared object version. It is a special version indicating transaction cancellation reason. */\n  version: Scalars['UInt53']['output'];\n};\n\n/**\n * The transaction accepted a shared object as input, but it was deleted before the transaction\n * executed.\n */\nexport type SharedObjectDelete = {\n  __typename?: 'SharedObjectDelete';\n  /** ID of the shared object. */\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Whether this transaction intended to use this shared object mutably or not. See\n   * `SharedInput.mutable` for further details.\n   */\n  mutable: Scalars['Boolean']['output'];\n  /**\n   * The version of the shared object that was assigned to this transaction during by consensus,\n   * during sequencing.\n   */\n  version: Scalars['UInt53']['output'];\n};\n\n/** The transaction accepted a shared object as input, but only to read it. */\nexport type SharedObjectRead = {\n  __typename?: 'SharedObjectRead';\n  /** ID of the object being read. */\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * 32-byte hash that identifies the object's contents at this version, encoded as a Base58\n   * string.\n   */\n  digest: Scalars['String']['output'];\n  /** The object at this version.  May not be available due to pruning. */\n  object?: Maybe<Object>;\n  /** Version of the object being read. */\n  version: Scalars['UInt53']['output'];\n};\n\n/**\n * Splits off coins with denominations in `amounts` from `coin`, returning multiple results (as\n * many as there are amounts.)\n */\nexport type SplitCoinsTransaction = {\n  __typename?: 'SplitCoinsTransaction';\n  /** The denominations to split off from the coin. */\n  amounts: Array<TransactionArgument>;\n  /** The coin to split. */\n  coin: TransactionArgument;\n};\n\n/** The stake's possible status: active, pending, or unstaked. */\nexport enum StakeStatus {\n  /** The stake object is active in a staking pool and it is generating rewards. */\n  Active = 'ACTIVE',\n  /** The stake awaits to join a staking pool in the next epoch. */\n  Pending = 'PENDING',\n  /** The stake is no longer active in any staking pool. */\n  Unstaked = 'UNSTAKED'\n}\n\n/** Parameters that control the distribution of the stake subsidy. */\nexport type StakeSubsidy = {\n  __typename?: 'StakeSubsidy';\n  /**\n   * SUI set aside for stake subsidies -- reduces over time as stake subsidies are paid out over\n   * time.\n   */\n  balance?: Maybe<Scalars['BigInt']['output']>;\n  /** Amount of stake subsidy deducted from the balance per distribution -- decays over time. */\n  currentDistributionAmount?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Percentage of the current distribution amount to deduct at the end of the current subsidy\n   * period, expressed in basis points.\n   */\n  decreaseRate?: Maybe<Scalars['Int']['output']>;\n  /**\n   * Number of times stake subsidies have been distributed subsidies are distributed with other\n   * staking rewards, at the end of the epoch.\n   */\n  distributionCounter?: Maybe<Scalars['Int']['output']>;\n  /**\n   * Maximum number of stake subsidy distributions that occur with the same distribution amount\n   * (before the amount is reduced).\n   */\n  periodLength?: Maybe<Scalars['Int']['output']>;\n};\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSui = IMoveObject & IObject & IOwner & {\n  __typename?: 'StakedSui';\n  /** The epoch at which this stake became active. */\n  activatedEpoch?: Maybe<Epoch>;\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Total balance of all coins with marker type owned by this object. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object. */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * The coin objects for this object.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /**\n   * Displays the contents of the Move object in a JSON string and through GraphQL types. Also\n   * provides the flat representation of the type signature, and the BCS of the corresponding\n   * data.\n   */\n  contents?: Maybe<MoveValue>;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the object's contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The set of named templates defined on-chain for the type of this object, to be handled\n   * off-chain. The server substitutes data from the object into these templates to generate a\n   * display string per template.\n   */\n  display?: Maybe<Array<DisplayEntry>>;\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /**\n   * The estimated reward for this stake object, calculated as:\n   *\n   * principal * (initial_stake_rate / current_stake_rate - 1.0)\n   *\n   * Or 0, if this value is negative, where:\n   *\n   * - `initial_stake_rate` is the stake rate at the epoch this stake was activated at.\n   * - `current_stake_rate` is the stake rate in the current epoch.\n   *\n   * This value is only available if the stake is active.\n   */\n  estimatedReward?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Determines whether a transaction can transfer this object, using the TransferObjects\n   * transaction command or `sui::transfer::public_transfer`, both of which require the object to\n   * have the `key` and `store` abilities.\n   */\n  hasPublicTransfer: Scalars['Boolean']['output'];\n  /** Objects owned by this object, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The owner type of this object: Immutable, Shared, Parent, Address */\n  owner?: Maybe<ObjectOwner>;\n  /** The object id of the validator staking pool this stake belongs to. */\n  poolId?: Maybe<Scalars['SuiAddress']['output']>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /** The SUI that was initially staked. */\n  principal?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The transaction blocks that sent objects to this object.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The epoch at which this object was requested to join a stake pool. */\n  requestedEpoch?: Maybe<Epoch>;\n  /** A stake can be pending, active, or unstaked */\n  stakeStatus: StakeStatus;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this object. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  version: Scalars['UInt53']['output'];\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** Represents a `0x3::staking_pool::StakedSui` Move object on-chain. */\nexport type StakedSuiSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type StakedSuiConnection = {\n  __typename?: 'StakedSuiConnection';\n  /** A list of edges. */\n  edges: Array<StakedSuiEdge>;\n  /** A list of nodes. */\n  nodes: Array<StakedSui>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type StakedSuiEdge = {\n  __typename?: 'StakedSuiEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: StakedSui;\n};\n\n/** SUI set aside to account for objects stored on-chain. */\nexport type StorageFund = {\n  __typename?: 'StorageFund';\n  /**\n   * The portion of the storage fund that will never be refunded through storage rebates.\n   *\n   * The system maintains an invariant that the sum of all storage fees into the storage fund is\n   * equal to the sum of of all storage rebates out, the total storage rebates remaining, and the\n   * non-refundable balance.\n   */\n  nonRefundableBalance?: Maybe<Scalars['BigInt']['output']>;\n  /** Sum of storage rebates of live objects on chain. */\n  totalObjectStorageRebates?: Maybe<Scalars['BigInt']['output']>;\n};\n\nexport type StoreExecutionTimeObservationsTransaction = {\n  __typename?: 'StoreExecutionTimeObservationsTransaction';\n  /** A workaround to define an empty variant of a GraphQL union. */\n  _?: Maybe<Scalars['Boolean']['output']>;\n};\n\nexport type SuinsRegistration = IMoveObject & IObject & IOwner & {\n  __typename?: 'SuinsRegistration';\n  address: Scalars['SuiAddress']['output'];\n  /**\n   * Total balance of all coins with marker type owned by this object. If type is not supplied,\n   * it defaults to `0x2::sui::SUI`.\n   */\n  balance?: Maybe<Balance>;\n  /** The balances of all coin types owned by this object. */\n  balances: BalanceConnection;\n  /** The Base64-encoded BCS serialization of the object's content. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * The coin objects for this object.\n   *\n   * `type` is a filter on the coin's type parameter, defaulting to `0x2::sui::SUI`.\n   */\n  coins: CoinConnection;\n  /**\n   * Displays the contents of the Move object in a JSON string and through GraphQL types. Also\n   * provides the flat representation of the type signature, and the BCS of the corresponding\n   * data.\n   */\n  contents?: Maybe<MoveValue>;\n  /** The domain explicitly configured as the default domain pointing to this object. */\n  defaultSuinsName?: Maybe<Scalars['String']['output']>;\n  /** 32-byte hash that identifies the object's contents, encoded as a Base58 string. */\n  digest?: Maybe<Scalars['String']['output']>;\n  /**\n   * The set of named templates defined on-chain for the type of this object, to be handled\n   * off-chain. The server substitutes data from the object into these templates to generate a\n   * display string per template.\n   */\n  display?: Maybe<Array<DisplayEntry>>;\n  /** Domain name of the SuinsRegistration object */\n  domain: Scalars['String']['output'];\n  /**\n   * Access a dynamic field on an object using its name. Names are arbitrary Move values whose\n   * type have `copy`, `drop`, and `store`, and are specified using their type, and their BCS\n   * contents, Base64 encoded.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicField?: Maybe<DynamicField>;\n  /**\n   * The dynamic fields and dynamic object fields on an object.\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicFields: DynamicFieldConnection;\n  /**\n   * Access a dynamic object field on an object using its name. Names are arbitrary Move values\n   * whose type have `copy`, `drop`, and `store`, and are specified using their type, and their\n   * BCS contents, Base64 encoded. The value of a dynamic object field can also be accessed\n   * off-chain directly via its address (e.g. using `Query.object`).\n   *\n   * Dynamic fields on wrapped objects can be accessed by using the same API under the Owner\n   * type.\n   */\n  dynamicObjectField?: Maybe<DynamicField>;\n  /**\n   * Determines whether a transaction can transfer this object, using the TransferObjects\n   * transaction command or `sui::transfer::public_transfer`, both of which require the object to\n   * have the `key` and `store` abilities.\n   */\n  hasPublicTransfer: Scalars['Boolean']['output'];\n  /** Objects owned by this object, optionally `filter`-ed. */\n  objects: MoveObjectConnection;\n  /** The owner type of this object: Immutable, Shared, Parent, Address */\n  owner?: Maybe<ObjectOwner>;\n  /** The transaction block that created this version of the object. */\n  previousTransactionBlock?: Maybe<TransactionBlock>;\n  /**\n   * The transaction blocks that sent objects to this object.\n   *\n   * `scanLimit` restricts the number of candidate transactions scanned when gathering a page of\n   * results. It is required for queries that apply more than two complex filters (on function,\n   * kind, sender, recipient, input object, changed object, or ids), and can be at most\n   * `serviceConfig.maxScanLimit`.\n   *\n   * When the scan limit is reached the page will be returned even if it has fewer than `first`\n   * results when paginating forward (`last` when paginating backwards). If there are more\n   * transactions to scan, `pageInfo.hasNextPage` (or `pageInfo.hasPreviousPage`) will be set to\n   * `true`, and `PageInfo.endCursor` (or `PageInfo.startCursor`) will be set to the last\n   * transaction that was scanned as opposed to the last (or first) transaction in the page.\n   *\n   * Requesting the next (or previous) page after this cursor will resume the search, scanning\n   * the next `scanLimit` many transactions in the direction of pagination, and so on until all\n   * transactions in the scanning range have been visited.\n   *\n   * By default, the scanning range includes all transactions known to GraphQL, but it can be\n   * restricted by the `after` and `before` cursors, and the `beforeCheckpoint`,\n   * `afterCheckpoint` and `atCheckpoint` filters.\n   */\n  receivedTransactionBlocks: TransactionBlockConnection;\n  /** The `0x3::staking_pool::StakedSui` objects owned by this object. */\n  stakedSuis: StakedSuiConnection;\n  /**\n   * The current status of the object as read from the off-chain store. The possible states are:\n   * NOT_INDEXED, the object is loaded from serialized data, such as the contents of a genesis or\n   * system package upgrade transaction. LIVE, the version returned is the most recent for the\n   * object, and it is not deleted or wrapped at that version. HISTORICAL, the object was\n   * referenced at a specific version or checkpoint, so is fetched from historical tables and may\n   * not be the latest version of the object. WRAPPED_OR_DELETED, the object is deleted or\n   * wrapped and only partial information can be loaded.\"\n   */\n  status: ObjectKind;\n  /**\n   * The amount of SUI we would rebate if this object gets deleted or mutated. This number is\n   * recalculated based on the present storage gas price.\n   */\n  storageRebate?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The SuinsRegistration NFTs owned by this object. These grant the owner the capability to\n   * manage the associated domain.\n   */\n  suinsRegistrations: SuinsRegistrationConnection;\n  version: Scalars['UInt53']['output'];\n};\n\n\nexport type SuinsRegistrationBalanceArgs = {\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\nexport type SuinsRegistrationBalancesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type SuinsRegistrationCoinsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n};\n\n\nexport type SuinsRegistrationDefaultSuinsNameArgs = {\n  format?: InputMaybe<DomainFormat>;\n};\n\n\nexport type SuinsRegistrationDynamicFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\nexport type SuinsRegistrationDynamicFieldsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type SuinsRegistrationDynamicObjectFieldArgs = {\n  name: DynamicFieldName;\n};\n\n\nexport type SuinsRegistrationObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type SuinsRegistrationReceivedTransactionBlocksArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<TransactionBlockFilter>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n  scanLimit?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type SuinsRegistrationStakedSuisArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\nexport type SuinsRegistrationSuinsRegistrationsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type SuinsRegistrationConnection = {\n  __typename?: 'SuinsRegistrationConnection';\n  /** A list of edges. */\n  edges: Array<SuinsRegistrationEdge>;\n  /** A list of nodes. */\n  nodes: Array<SuinsRegistration>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type SuinsRegistrationEdge = {\n  __typename?: 'SuinsRegistrationEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: SuinsRegistration;\n};\n\n/** Details of the system that are decided during genesis. */\nexport type SystemParameters = {\n  __typename?: 'SystemParameters';\n  /** Target duration of an epoch, in milliseconds. */\n  durationMs?: Maybe<Scalars['BigInt']['output']>;\n  /** The maximum number of active validators that the system supports. */\n  maxValidatorCount?: Maybe<Scalars['Int']['output']>;\n  /** The minimum number of active validators that the system supports. */\n  minValidatorCount?: Maybe<Scalars['Int']['output']>;\n  /** Minimum stake needed to become a new validator. */\n  minValidatorJoiningStake?: Maybe<Scalars['BigInt']['output']>;\n  /** The epoch at which stake subsidies start being paid out. */\n  stakeSubsidyStartEpoch?: Maybe<Scalars['UInt53']['output']>;\n  /**\n   * The number of epochs that a validator has to recover from having less than\n   * `validatorLowStakeThreshold` stake.\n   */\n  validatorLowStakeGracePeriod?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Validators with stake below this threshold will enter the grace period (see\n   * `validatorLowStakeGracePeriod`), after which they are removed from the active validator set.\n   */\n  validatorLowStakeThreshold?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * Validators with stake below this threshold will be removed from the active validator set\n   * at the next epoch boundary, without a grace period.\n   */\n  validatorVeryLowStakeThreshold?: Maybe<Scalars['BigInt']['output']>;\n};\n\n/** An argument to a programmable transaction command. */\nexport type TransactionArgument = GasCoin | Input | Result;\n\nexport type TransactionBlock = {\n  __typename?: 'TransactionBlock';\n  /** Serialized form of this transaction's `TransactionData`, BCS serialized and Base64 encoded. */\n  bcs?: Maybe<Scalars['Base64']['output']>;\n  /**\n   * A 32-byte hash that uniquely identifies the transaction block contents, encoded in Base58.\n   * This serves as a unique id for the block on chain.\n   */\n  digest?: Maybe<Scalars['String']['output']>;\n  /** The effects field captures the results to the chain of executing this transaction. */\n  effects?: Maybe<TransactionBlockEffects>;\n  /**\n   * This field is set by senders of a transaction block. It is an epoch reference that sets a\n   * deadline after which validators will no longer consider the transaction valid. By default,\n   * there is no deadline for when a transaction must execute.\n   */\n  expiration?: Maybe<Epoch>;\n  /**\n   * The gas input field provides information on what objects were used as gas as well as the\n   * owner of the gas object(s) and information on the gas price and budget.\n   *\n   * If the owner of the gas object(s) is not the same as the sender, the transaction block is a\n   * sponsored transaction block.\n   */\n  gasInput?: Maybe<GasInput>;\n  /**\n   * The type of this transaction as well as the commands and/or parameters comprising the\n   * transaction of this kind.\n   */\n  kind?: Maybe<TransactionBlockKind>;\n  /**\n   * The address corresponding to the public key that signed this transaction. System\n   * transactions do not have senders.\n   */\n  sender?: Maybe<Address>;\n  /**\n   * A list of all signatures, Base64-encoded, from senders, and potentially the gas owner if\n   * this is a sponsored transaction.\n   */\n  signatures?: Maybe<Array<Scalars['Base64']['output']>>;\n};\n\nexport type TransactionBlockConnection = {\n  __typename?: 'TransactionBlockConnection';\n  /** A list of edges. */\n  edges: Array<TransactionBlockEdge>;\n  /** A list of nodes. */\n  nodes: Array<TransactionBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type TransactionBlockEdge = {\n  __typename?: 'TransactionBlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: TransactionBlock;\n};\n\n/** The effects representing the result of executing a transaction block. */\nexport type TransactionBlockEffects = {\n  __typename?: 'TransactionBlockEffects';\n  /** The error code of the Move abort, populated if this transaction failed with a Move abort. */\n  abortCode?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The effect this transaction had on the balances (sum of coin values per coin type) of\n   * addresses and objects.\n   */\n  balanceChanges: BalanceChangeConnection;\n  /** Base64 encoded bcs serialization of the on-chain transaction effects. */\n  bcs: Scalars['Base64']['output'];\n  /** The checkpoint this transaction was finalized in. */\n  checkpoint?: Maybe<Checkpoint>;\n  /** Transactions whose outputs this transaction depends upon. */\n  dependencies: DependencyConnection;\n  /** The epoch this transaction was finalized in. */\n  epoch?: Maybe<Epoch>;\n  /**\n   * The reason for a transaction failure, if it did fail.\n   * If the error is a Move abort, the error message will be resolved to a human-readable form if\n   * possible, otherwise it will fall back to displaying the abort code and location.\n   */\n  errors?: Maybe<Scalars['String']['output']>;\n  /** Events emitted by this transaction block. */\n  events: EventConnection;\n  /** Effects to the gas object. */\n  gasEffects?: Maybe<GasEffects>;\n  /**\n   * The latest version of all objects (apart from packages) that have been created or modified\n   * by this transaction, immediately following this transaction.\n   */\n  lamportVersion: Scalars['UInt53']['output'];\n  /** The effect this transaction had on objects on-chain. */\n  objectChanges: ObjectChangeConnection;\n  /** Whether the transaction executed successfully or not. */\n  status?: Maybe<ExecutionStatus>;\n  /** Timestamp corresponding to the checkpoint this transaction was finalized in. */\n  timestamp?: Maybe<Scalars['DateTime']['output']>;\n  /** The transaction that ran to produce these effects. */\n  transactionBlock?: Maybe<TransactionBlock>;\n  /** Shared objects that are referenced by but not changed by this transaction. */\n  unchangedSharedObjects: UnchangedSharedObjectConnection;\n};\n\n\n/** The effects representing the result of executing a transaction block. */\nexport type TransactionBlockEffectsBalanceChangesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The effects representing the result of executing a transaction block. */\nexport type TransactionBlockEffectsDependenciesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The effects representing the result of executing a transaction block. */\nexport type TransactionBlockEffectsEventsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The effects representing the result of executing a transaction block. */\nexport type TransactionBlockEffectsObjectChangesArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n\n/** The effects representing the result of executing a transaction block. */\nexport type TransactionBlockEffectsUnchangedSharedObjectsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type TransactionBlockFilter = {\n  /**\n   * Limit to transactions that interacted with the given address. The address could be a\n   * sender, sponsor, or recipient of the transaction.\n   */\n  affectedAddress?: InputMaybe<Scalars['SuiAddress']['input']>;\n  /** Limit to transactions that occured strictly after the given checkpoint. */\n  afterCheckpoint?: InputMaybe<Scalars['UInt53']['input']>;\n  /** Limit to transactions in the given checkpoint. */\n  atCheckpoint?: InputMaybe<Scalars['UInt53']['input']>;\n  /** Limit to transaction that occured strictly before the given checkpoint. */\n  beforeCheckpoint?: InputMaybe<Scalars['UInt53']['input']>;\n  /**\n   * Limit to transactions that output a versioon of this object. NOTE: this input filter has\n   * been deprecated in favor of `affectedObject` which offers an easier to understand behavor.\n   *\n   * This filter will be removed with 1.36.0 (2024-10-14), or at least one release after\n   * `affectedObject` is introduced, whichever is later.\n   */\n  changedObject?: InputMaybe<Scalars['SuiAddress']['input']>;\n  /**\n   * Filter transactions by move function called. Calls can be filtered by the `package`,\n   * `package::module`, or the `package::module::name` of their function.\n   */\n  function?: InputMaybe<Scalars['String']['input']>;\n  /**\n   * Limit to transactions that accepted the given object as an input. NOTE: this input filter\n   * has been deprecated in favor of `affectedObject` which offers an easier to under behavior.\n   *\n   * This filter will be removed with 1.36.0 (2024-10-14), or at least one release after\n   * `affectedObject` is introduced, whichever is later.\n   */\n  inputObject?: InputMaybe<Scalars['SuiAddress']['input']>;\n  /** An input filter selecting for either system or programmable transactions. */\n  kind?: InputMaybe<TransactionBlockKindInput>;\n  /** Limit to transactions that were sent by the given address. */\n  sentAddress?: InputMaybe<Scalars['SuiAddress']['input']>;\n  /** Select transactions by their digest. */\n  transactionIds?: InputMaybe<Array<Scalars['String']['input']>>;\n};\n\n/** The kind of transaction block, either a programmable transaction or a system transaction. */\nexport type TransactionBlockKind = AuthenticatorStateUpdateTransaction | ChangeEpochTransaction | ConsensusCommitPrologueTransaction | EndOfEpochTransaction | GenesisTransaction | ProgrammableTransactionBlock | RandomnessStateUpdateTransaction;\n\n/** An input filter selecting for either system or programmable transactions. */\nexport enum TransactionBlockKindInput {\n  /** A user submitted transaction block. */\n  ProgrammableTx = 'PROGRAMMABLE_TX',\n  /**\n   * A system transaction can be one of several types of transactions.\n   * See [unions/transaction-block-kind] for more details.\n   */\n  SystemTx = 'SYSTEM_TX'\n}\n\nexport type TransactionInput = OwnedOrImmutable | Pure | Receiving | SharedInput;\n\nexport type TransactionInputConnection = {\n  __typename?: 'TransactionInputConnection';\n  /** A list of edges. */\n  edges: Array<TransactionInputEdge>;\n  /** A list of nodes. */\n  nodes: Array<TransactionInput>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type TransactionInputEdge = {\n  __typename?: 'TransactionInputEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: TransactionInput;\n};\n\n/**\n * The optional extra data a user can provide to a transaction dry run.\n * `sender` defaults to `0x0`. If `gasObjects` is not present, or is an empty list,\n * it is substituted with a mock Coin object, `gasPrice` defaults to the reference\n * gas price, `gasBudget` defaults to the max gas budget and `gasSponsor` defaults\n * to the sender.\n */\nexport type TransactionMetadata = {\n  gasBudget?: InputMaybe<Scalars['UInt53']['input']>;\n  gasObjects?: InputMaybe<Array<ObjectRef>>;\n  gasPrice?: InputMaybe<Scalars['UInt53']['input']>;\n  gasSponsor?: InputMaybe<Scalars['SuiAddress']['input']>;\n  sender?: InputMaybe<Scalars['SuiAddress']['input']>;\n};\n\n/**\n * Transfers `inputs` to `address`. All inputs must have the `store` ability (allows public\n * transfer) and must not be previously immutable or shared.\n */\nexport type TransferObjectsTransaction = {\n  __typename?: 'TransferObjectsTransaction';\n  /** The address to transfer to. */\n  address: TransactionArgument;\n  /** The objects to transfer. */\n  inputs: Array<TransactionArgument>;\n};\n\n/** Information about which previous versions of a package introduced its types. */\nexport type TypeOrigin = {\n  __typename?: 'TypeOrigin';\n  /** The storage ID of the package that first defined this type. */\n  definingId: Scalars['SuiAddress']['output'];\n  /** Module defining the type. */\n  module: Scalars['String']['output'];\n  /** Name of the struct. */\n  struct: Scalars['String']['output'];\n};\n\n/**\n * Details pertaining to shared objects that are referenced by but not changed by a transaction.\n * This information is considered part of the effects, because although the transaction specifies\n * the shared object as input, consensus must schedule it and pick the version that is actually\n * used.\n */\nexport type UnchangedSharedObject = SharedObjectCancelled | SharedObjectDelete | SharedObjectRead;\n\nexport type UnchangedSharedObjectConnection = {\n  __typename?: 'UnchangedSharedObjectConnection';\n  /** A list of edges. */\n  edges: Array<UnchangedSharedObjectEdge>;\n  /** A list of nodes. */\n  nodes: Array<UnchangedSharedObject>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type UnchangedSharedObjectEdge = {\n  __typename?: 'UnchangedSharedObjectEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: UnchangedSharedObject;\n};\n\n/** Upgrades a Move Package. */\nexport type UpgradeTransaction = {\n  __typename?: 'UpgradeTransaction';\n  /** ID of the package being upgraded. */\n  currentPackage: Scalars['SuiAddress']['output'];\n  /** IDs of the transitive dependencies of the package to be published. */\n  dependencies: Array<Scalars['SuiAddress']['output']>;\n  /** Bytecode for the modules to be published, BCS serialized and Base64 encoded. */\n  modules: Array<Scalars['Base64']['output']>;\n  /** The `UpgradeTicket` authorizing the upgrade. */\n  upgradeTicket: TransactionArgument;\n};\n\nexport type Validator = {\n  __typename?: 'Validator';\n  /** The validator's address. */\n  address: Address;\n  /**\n   * The APY of this validator in basis points.\n   * To get the APY in percentage, divide by 100.\n   */\n  apy?: Maybe<Scalars['Int']['output']>;\n  /**\n   * The number of epochs for which this validator has been below the\n   * low stake threshold.\n   */\n  atRisk?: Maybe<Scalars['UInt53']['output']>;\n  /** The fee charged by the validator for staking services. */\n  commissionRate?: Maybe<Scalars['Int']['output']>;\n  /** Validator's set of credentials such as public keys, network addresses and others. */\n  credentials?: Maybe<ValidatorCredentials>;\n  /** Validator's description. */\n  description?: Maybe<Scalars['String']['output']>;\n  /**\n   * The validator's current exchange object. The exchange rate is used to determine\n   * the amount of SUI tokens that each past SUI staker can withdraw in the future.\n   * @deprecated The exchange object is a wrapped object. Access its dynamic fields through the `exchangeRatesTable` query.\n   */\n  exchangeRates?: Maybe<MoveObject>;\n  /** Number of exchange rates in the table. */\n  exchangeRatesSize?: Maybe<Scalars['UInt53']['output']>;\n  /**\n   * A wrapped object containing the validator's exchange rates. This is a table from epoch\n   * number to `PoolTokenExchangeRate` value. The exchange rate is used to determine the amount\n   * of SUI tokens that each past SUI staker can withdraw in the future.\n   */\n  exchangeRatesTable?: Maybe<Owner>;\n  /** The reference gas price for this epoch. */\n  gasPrice?: Maybe<Scalars['BigInt']['output']>;\n  /** Validator's url containing their custom image. */\n  imageUrl?: Maybe<Scalars['String']['output']>;\n  /** Validator's name. */\n  name?: Maybe<Scalars['String']['output']>;\n  /** The proposed next epoch fee for the validator's staking services. */\n  nextEpochCommissionRate?: Maybe<Scalars['Int']['output']>;\n  /** Validator's set of credentials for the next epoch. */\n  nextEpochCredentials?: Maybe<ValidatorCredentials>;\n  /** The validator's gas price quote for the next epoch. */\n  nextEpochGasPrice?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The total number of SUI tokens in this pool plus\n   * the pending stake amount for this epoch.\n   */\n  nextEpochStake?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The validator's current valid `Cap` object. Validators can delegate\n   * the operation ability to another address. The address holding this `Cap` object\n   * can then update the reference gas price and tallying rule on behalf of the validator.\n   */\n  operationCap?: Maybe<MoveObject>;\n  /** Pending pool token withdrawn during the current epoch, emptied at epoch boundaries. */\n  pendingPoolTokenWithdraw?: Maybe<Scalars['BigInt']['output']>;\n  /** Pending stake amount for this epoch. */\n  pendingStake?: Maybe<Scalars['BigInt']['output']>;\n  /** Pending stake withdrawn during the current epoch, emptied at epoch boundaries. */\n  pendingTotalSuiWithdraw?: Maybe<Scalars['BigInt']['output']>;\n  /** Total number of pool tokens issued by the pool. */\n  poolTokenBalance?: Maybe<Scalars['BigInt']['output']>;\n  /** Validator's homepage URL. */\n  projectUrl?: Maybe<Scalars['String']['output']>;\n  /** The addresses of other validators this validator has reported. */\n  reportRecords: AddressConnection;\n  /** The epoch stake rewards will be added here at the end of each epoch. */\n  rewardsPool?: Maybe<Scalars['BigInt']['output']>;\n  /**\n   * The validator's current staking pool object, used to track the amount of stake\n   * and to compound staking rewards.\n   * @deprecated The staking pool is a wrapped object. Access its fields directly on the `Validator` type.\n   */\n  stakingPool?: Maybe<MoveObject>;\n  /** The epoch at which this pool became active. */\n  stakingPoolActivationEpoch?: Maybe<Scalars['UInt53']['output']>;\n  /** The ID of this validator's `0x3::staking_pool::StakingPool`. */\n  stakingPoolId: Scalars['SuiAddress']['output'];\n  /** The total number of SUI tokens in this pool. */\n  stakingPoolSuiBalance?: Maybe<Scalars['BigInt']['output']>;\n  /** The voting power of this validator in basis points (e.g., 100 = 1% voting power). */\n  votingPower?: Maybe<Scalars['Int']['output']>;\n};\n\n\nexport type ValidatorReportRecordsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\nexport type ValidatorConnection = {\n  __typename?: 'ValidatorConnection';\n  /** A list of edges. */\n  edges: Array<ValidatorEdge>;\n  /** A list of nodes. */\n  nodes: Array<Validator>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n};\n\n/** The credentials related fields associated with a validator. */\nexport type ValidatorCredentials = {\n  __typename?: 'ValidatorCredentials';\n  netAddress?: Maybe<Scalars['String']['output']>;\n  networkPubKey?: Maybe<Scalars['Base64']['output']>;\n  p2PAddress?: Maybe<Scalars['String']['output']>;\n  primaryAddress?: Maybe<Scalars['String']['output']>;\n  proofOfPossession?: Maybe<Scalars['Base64']['output']>;\n  protocolPubKey?: Maybe<Scalars['Base64']['output']>;\n  workerAddress?: Maybe<Scalars['String']['output']>;\n  workerPubKey?: Maybe<Scalars['Base64']['output']>;\n};\n\n/** An edge in a connection. */\nexport type ValidatorEdge = {\n  __typename?: 'ValidatorEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String']['output'];\n  /** The item at the end of the edge */\n  node: Validator;\n};\n\n/** Representation of `0x3::validator_set::ValidatorSet`. */\nexport type ValidatorSet = {\n  __typename?: 'ValidatorSet';\n  /** The current set of active validators. */\n  activeValidators: ValidatorConnection;\n  /** Object ID of the `Table` storing the inactive staking pools. */\n  inactivePoolsId?: Maybe<Scalars['SuiAddress']['output']>;\n  /** Size of the inactive pools `Table`. */\n  inactivePoolsSize?: Maybe<Scalars['Int']['output']>;\n  /** Object ID of the wrapped object `TableVec` storing the pending active validators. */\n  pendingActiveValidatorsId?: Maybe<Scalars['SuiAddress']['output']>;\n  /** Size of the pending active validators table. */\n  pendingActiveValidatorsSize?: Maybe<Scalars['Int']['output']>;\n  /**\n   * Validators that are pending removal from the active validator set, expressed as indices in\n   * to `activeValidators`.\n   */\n  pendingRemovals?: Maybe<Array<Scalars['Int']['output']>>;\n  /**\n   * Object ID of the `Table` storing the mapping from staking pool ids to the addresses\n   * of the corresponding validators. This is needed because a validator's address\n   * can potentially change but the object ID of its pool will not.\n   */\n  stakingPoolMappingsId?: Maybe<Scalars['SuiAddress']['output']>;\n  /** Size of the stake pool mappings `Table`. */\n  stakingPoolMappingsSize?: Maybe<Scalars['Int']['output']>;\n  /** Total amount of stake for all active validators at the beginning of the epoch. */\n  totalStake?: Maybe<Scalars['BigInt']['output']>;\n  /** Object ID of the `Table` storing the validator candidates. */\n  validatorCandidatesId?: Maybe<Scalars['SuiAddress']['output']>;\n  /** Size of the validator candidates `Table`. */\n  validatorCandidatesSize?: Maybe<Scalars['Int']['output']>;\n};\n\n\n/** Representation of `0x3::validator_set::ValidatorSet`. */\nexport type ValidatorSetActiveValidatorsArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  before?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  last?: InputMaybe<Scalars['Int']['input']>;\n};\n\n/**\n * An enum that specifies the intent scope to be used to parse the bytes for signature\n * verification.\n */\nexport enum ZkLoginIntentScope {\n  /** Indicates that the bytes are to be parsed as a personal message. */\n  PersonalMessage = 'PERSONAL_MESSAGE',\n  /** Indicates that the bytes are to be parsed as transaction data bytes. */\n  TransactionData = 'TRANSACTION_DATA'\n}\n\n/** The result of the zkLogin signature verification. */\nexport type ZkLoginVerifyResult = {\n  __typename?: 'ZkLoginVerifyResult';\n  /** The errors field captures any verification error */\n  errors: Array<Scalars['String']['output']>;\n  /** The boolean result of the verification. If true, errors should be empty. */\n  success: Scalars['Boolean']['output'];\n};\n\nexport type GetAllBalancesQueryVariables = Exact<{\n  owner: Scalars['SuiAddress']['input'];\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  cursor?: InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type GetAllBalancesQuery = { __typename?: 'Query', address?: { __typename?: 'Address', balances: { __typename?: 'BalanceConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ __typename?: 'Balance', coinObjectCount?: any | null, totalBalance?: any | null, coinType: { __typename?: 'MoveType', repr: string } }> } } | null };\n\nexport type GetBalanceQueryVariables = Exact<{\n  owner: Scalars['SuiAddress']['input'];\n  type?: InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type GetBalanceQuery = { __typename?: 'Query', address?: { __typename?: 'Address', balance?: { __typename?: 'Balance', coinObjectCount?: any | null, totalBalance?: any | null, coinType: { __typename?: 'MoveType', repr: string } } | null } | null };\n\nexport type GetCoinsQueryVariables = Exact<{\n  owner: Scalars['SuiAddress']['input'];\n  first?: InputMaybe<Scalars['Int']['input']>;\n  cursor?: InputMaybe<Scalars['String']['input']>;\n  type?: InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type GetCoinsQuery = { __typename?: 'Query', address?: { __typename?: 'Address', address: any, coins: { __typename?: 'CoinConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ __typename?: 'Coin', coinBalance?: any | null, address: any, version: any, digest?: string | null, owner?: { __typename: 'AddressOwner', owner?: { __typename?: 'Owner', asObject?: { __typename?: 'Object', address: any } | null, asAddress?: { __typename?: 'Address', address: any } | null } | null } | { __typename: 'ConsensusAddressOwner', startVersion: any, owner?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Immutable' } | { __typename: 'Parent', parent?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Shared', initialSharedVersion: any } | null, contents?: { __typename?: 'MoveValue', bcs: any, type: { __typename?: 'MoveType', repr: string } } | null }> } } | null };\n\nexport type GetDynamicFieldsQueryVariables = Exact<{\n  parentId: Scalars['SuiAddress']['input'];\n  first?: InputMaybe<Scalars['Int']['input']>;\n  cursor?: InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type GetDynamicFieldsQuery = { __typename?: 'Query', owner?: { __typename?: 'Owner', dynamicFields: { __typename?: 'DynamicFieldConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ __typename?: 'DynamicField', name?: { __typename?: 'MoveValue', bcs: any, type: { __typename?: 'MoveType', repr: string } } | null, value?: { __typename: 'MoveObject', contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | { __typename: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null }> } } | null };\n\nexport type GetReferenceGasPriceQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GetReferenceGasPriceQuery = { __typename?: 'Query', epoch?: { __typename?: 'Epoch', referenceGasPrice?: any | null } | null };\n\nexport type ResolveNameServiceNamesQueryVariables = Exact<{\n  address: Scalars['SuiAddress']['input'];\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  cursor?: InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type ResolveNameServiceNamesQuery = { __typename?: 'Query', address?: { __typename?: 'Address', suinsRegistrations: { __typename?: 'SuinsRegistrationConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ __typename?: 'SuinsRegistration', domain: string }> } } | null };\n\nexport type GetOwnedObjectsQueryVariables = Exact<{\n  owner: Scalars['SuiAddress']['input'];\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  cursor?: InputMaybe<Scalars['String']['input']>;\n  filter?: InputMaybe<ObjectFilter>;\n}>;\n\n\nexport type GetOwnedObjectsQuery = { __typename?: 'Query', address?: { __typename?: 'Address', objects: { __typename?: 'MoveObjectConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ __typename?: 'MoveObject', address: any, digest?: string | null, version: any, contents?: { __typename?: 'MoveValue', bcs: any, type: { __typename?: 'MoveType', repr: string } } | null, owner?: { __typename: 'AddressOwner', owner?: { __typename?: 'Owner', asObject?: { __typename?: 'Object', address: any } | null, asAddress?: { __typename?: 'Address', address: any } | null } | null } | { __typename: 'ConsensusAddressOwner', startVersion: any, owner?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Immutable' } | { __typename: 'Parent', parent?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Shared', initialSharedVersion: any } | null }> } } | null };\n\nexport type MultiGetObjectsQueryVariables = Exact<{\n  objectIds: Array<Scalars['SuiAddress']['input']> | Scalars['SuiAddress']['input'];\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  cursor?: InputMaybe<Scalars['String']['input']>;\n}>;\n\n\nexport type MultiGetObjectsQuery = { __typename?: 'Query', objects: { __typename?: 'ObjectConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null }, nodes: Array<{ __typename?: 'Object', address: any, digest?: string | null, version: any, asMoveObject?: { __typename?: 'MoveObject', contents?: { __typename?: 'MoveValue', bcs: any, type: { __typename?: 'MoveType', repr: string } } | null } | null, owner?: { __typename: 'AddressOwner', owner?: { __typename?: 'Owner', asObject?: { __typename?: 'Object', address: any } | null, asAddress?: { __typename?: 'Address', address: any } | null } | null } | { __typename: 'ConsensusAddressOwner', startVersion: any, owner?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Immutable' } | { __typename: 'Parent', parent?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Shared', initialSharedVersion: any } | null }> } };\n\nexport type Object_FieldsFragment = { __typename?: 'Object', address: any, digest?: string | null, version: any, asMoveObject?: { __typename?: 'MoveObject', contents?: { __typename?: 'MoveValue', bcs: any, type: { __typename?: 'MoveType', repr: string } } | null } | null, owner?: { __typename: 'AddressOwner', owner?: { __typename?: 'Owner', asObject?: { __typename?: 'Object', address: any } | null, asAddress?: { __typename?: 'Address', address: any } | null } | null } | { __typename: 'ConsensusAddressOwner', startVersion: any, owner?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Immutable' } | { __typename: 'Parent', parent?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Shared', initialSharedVersion: any } | null };\n\nexport type Move_Object_FieldsFragment = { __typename?: 'MoveObject', address: any, digest?: string | null, version: any, contents?: { __typename?: 'MoveValue', bcs: any, type: { __typename?: 'MoveType', repr: string } } | null, owner?: { __typename: 'AddressOwner', owner?: { __typename?: 'Owner', asObject?: { __typename?: 'Object', address: any } | null, asAddress?: { __typename?: 'Address', address: any } | null } | null } | { __typename: 'ConsensusAddressOwner', startVersion: any, owner?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Immutable' } | { __typename: 'Parent', parent?: { __typename?: 'Owner', address: any } | null } | { __typename: 'Shared', initialSharedVersion: any } | null };\n\ntype Object_Owner_Fields_AddressOwner_Fragment = { __typename: 'AddressOwner', owner?: { __typename?: 'Owner', asObject?: { __typename?: 'Object', address: any } | null, asAddress?: { __typename?: 'Address', address: any } | null } | null };\n\ntype Object_Owner_Fields_ConsensusAddressOwner_Fragment = { __typename: 'ConsensusAddressOwner', startVersion: any, owner?: { __typename?: 'Owner', address: any } | null };\n\ntype Object_Owner_Fields_Immutable_Fragment = { __typename: 'Immutable' };\n\ntype Object_Owner_Fields_Parent_Fragment = { __typename: 'Parent', parent?: { __typename?: 'Owner', address: any } | null };\n\ntype Object_Owner_Fields_Shared_Fragment = { __typename: 'Shared', initialSharedVersion: any };\n\nexport type Object_Owner_FieldsFragment = Object_Owner_Fields_AddressOwner_Fragment | Object_Owner_Fields_ConsensusAddressOwner_Fragment | Object_Owner_Fields_Immutable_Fragment | Object_Owner_Fields_Parent_Fragment | Object_Owner_Fields_Shared_Fragment;\n\nexport type DryRunTransactionBlockQueryVariables = Exact<{\n  txBytes: Scalars['String']['input'];\n}>;\n\n\nexport type DryRunTransactionBlockQuery = { __typename?: 'Query', dryRunTransactionBlock: { __typename?: 'DryRunResult', error?: string | null, transaction?: { __typename?: 'TransactionBlock', digest?: string | null, bcs?: any | null, signatures?: Array<any> | null, effects?: { __typename?: 'TransactionBlockEffects', bcs: any, epoch?: { __typename?: 'Epoch', epochId: any } | null, unchangedSharedObjects: { __typename?: 'UnchangedSharedObjectConnection', nodes: Array<{ __typename: 'SharedObjectCancelled' } | { __typename: 'SharedObjectDelete' } | { __typename: 'SharedObjectRead', object?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> }, objectChanges: { __typename?: 'ObjectChangeConnection', nodes: Array<{ __typename?: 'ObjectChange', address: any, inputState?: { __typename?: 'Object', version: any, asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null, outputState?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> } } | null } | null } };\n\nexport type ExecuteTransactionBlockMutationVariables = Exact<{\n  txBytes: Scalars['String']['input'];\n  signatures: Array<Scalars['String']['input']> | Scalars['String']['input'];\n}>;\n\n\nexport type ExecuteTransactionBlockMutation = { __typename?: 'Mutation', executeTransactionBlock: { __typename?: 'ExecutionResult', errors?: Array<string> | null, effects: { __typename?: 'TransactionBlockEffects', transactionBlock?: { __typename?: 'TransactionBlock', digest?: string | null, bcs?: any | null, signatures?: Array<any> | null, effects?: { __typename?: 'TransactionBlockEffects', bcs: any, epoch?: { __typename?: 'Epoch', epochId: any } | null, unchangedSharedObjects: { __typename?: 'UnchangedSharedObjectConnection', nodes: Array<{ __typename: 'SharedObjectCancelled' } | { __typename: 'SharedObjectDelete' } | { __typename: 'SharedObjectRead', object?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> }, objectChanges: { __typename?: 'ObjectChangeConnection', nodes: Array<{ __typename?: 'ObjectChange', address: any, inputState?: { __typename?: 'Object', version: any, asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null, outputState?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> } } | null } | null } } };\n\nexport type GetTransactionBlockQueryVariables = Exact<{\n  digest: Scalars['String']['input'];\n}>;\n\n\nexport type GetTransactionBlockQuery = { __typename?: 'Query', transactionBlock?: { __typename?: 'TransactionBlock', digest?: string | null, bcs?: any | null, signatures?: Array<any> | null, effects?: { __typename?: 'TransactionBlockEffects', bcs: any, epoch?: { __typename?: 'Epoch', epochId: any } | null, unchangedSharedObjects: { __typename?: 'UnchangedSharedObjectConnection', nodes: Array<{ __typename: 'SharedObjectCancelled' } | { __typename: 'SharedObjectDelete' } | { __typename: 'SharedObjectRead', object?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> }, objectChanges: { __typename?: 'ObjectChangeConnection', nodes: Array<{ __typename?: 'ObjectChange', address: any, inputState?: { __typename?: 'Object', version: any, asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null, outputState?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> } } | null } | null };\n\nexport type Transaction_FieldsFragment = { __typename?: 'TransactionBlock', digest?: string | null, bcs?: any | null, signatures?: Array<any> | null, effects?: { __typename?: 'TransactionBlockEffects', bcs: any, epoch?: { __typename?: 'Epoch', epochId: any } | null, unchangedSharedObjects: { __typename?: 'UnchangedSharedObjectConnection', nodes: Array<{ __typename: 'SharedObjectCancelled' } | { __typename: 'SharedObjectDelete' } | { __typename: 'SharedObjectRead', object?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> }, objectChanges: { __typename?: 'ObjectChangeConnection', nodes: Array<{ __typename?: 'ObjectChange', address: any, inputState?: { __typename?: 'Object', version: any, asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null, outputState?: { __typename?: 'Object', asMoveObject?: { __typename?: 'MoveObject', address: any, contents?: { __typename?: 'MoveValue', type: { __typename?: 'MoveType', repr: string } } | null } | null } | null }> } } | null };\n\nexport type VerifyZkLoginSignatureQueryVariables = Exact<{\n  bytes: Scalars['Base64']['input'];\n  signature: Scalars['Base64']['input'];\n  intentScope: ZkLoginIntentScope;\n  author: Scalars['SuiAddress']['input'];\n}>;\n\n\nexport type VerifyZkLoginSignatureQuery = { __typename?: 'Query', verifyZkloginSignature: { __typename?: 'ZkLoginVerifyResult', success: boolean, errors: Array<string> } };\n\nexport class TypedDocumentString<TResult, TVariables>\n  extends String\n  implements DocumentTypeDecoration<TResult, TVariables>\n{\n  __apiType?: DocumentTypeDecoration<TResult, TVariables>['__apiType'];\n  private value: string;\n  public __meta__?: Record<string, any> | undefined;\n\n  constructor(value: string, __meta__?: Record<string, any> | undefined) {\n    super(value);\n    this.value = value;\n    this.__meta__ = __meta__;\n  }\n\n  toString(): string & DocumentTypeDecoration<TResult, TVariables> {\n    return this.value;\n  }\n}\nexport const Object_Owner_FieldsFragmentDoc = new TypedDocumentString(`\n    fragment OBJECT_OWNER_FIELDS on ObjectOwner {\n  __typename\n  ... on AddressOwner {\n    owner {\n      asObject {\n        address\n      }\n      asAddress {\n        address\n      }\n    }\n  }\n  ... on Parent {\n    parent {\n      address\n    }\n  }\n  ... on Shared {\n    initialSharedVersion\n  }\n  ... on ConsensusAddressOwner {\n    startVersion\n    owner {\n      address\n    }\n  }\n}\n    `, {\"fragmentName\":\"OBJECT_OWNER_FIELDS\"}) as unknown as TypedDocumentString<Object_Owner_FieldsFragment, unknown>;\nexport const Object_FieldsFragmentDoc = new TypedDocumentString(`\n    fragment OBJECT_FIELDS on Object {\n  address\n  digest\n  version\n  asMoveObject {\n    contents {\n      bcs\n      type {\n        repr\n      }\n    }\n  }\n  owner {\n    ...OBJECT_OWNER_FIELDS\n  }\n}\n    fragment OBJECT_OWNER_FIELDS on ObjectOwner {\n  __typename\n  ... on AddressOwner {\n    owner {\n      asObject {\n        address\n      }\n      asAddress {\n        address\n      }\n    }\n  }\n  ... on Parent {\n    parent {\n      address\n    }\n  }\n  ... on Shared {\n    initialSharedVersion\n  }\n  ... on ConsensusAddressOwner {\n    startVersion\n    owner {\n      address\n    }\n  }\n}`, {\"fragmentName\":\"OBJECT_FIELDS\"}) as unknown as TypedDocumentString<Object_FieldsFragment, unknown>;\nexport const Move_Object_FieldsFragmentDoc = new TypedDocumentString(`\n    fragment MOVE_OBJECT_FIELDS on MoveObject {\n  address\n  digest\n  version\n  contents {\n    bcs\n    type {\n      repr\n    }\n  }\n  owner {\n    ...OBJECT_OWNER_FIELDS\n  }\n}\n    fragment OBJECT_OWNER_FIELDS on ObjectOwner {\n  __typename\n  ... on AddressOwner {\n    owner {\n      asObject {\n        address\n      }\n      asAddress {\n        address\n      }\n    }\n  }\n  ... on Parent {\n    parent {\n      address\n    }\n  }\n  ... on Shared {\n    initialSharedVersion\n  }\n  ... on ConsensusAddressOwner {\n    startVersion\n    owner {\n      address\n    }\n  }\n}`, {\"fragmentName\":\"MOVE_OBJECT_FIELDS\"}) as unknown as TypedDocumentString<Move_Object_FieldsFragment, unknown>;\nexport const Transaction_FieldsFragmentDoc = new TypedDocumentString(`\n    fragment TRANSACTION_FIELDS on TransactionBlock {\n  digest\n  bcs\n  signatures\n  effects {\n    bcs\n    epoch {\n      epochId\n    }\n    unchangedSharedObjects {\n      nodes {\n        __typename\n        ... on SharedObjectRead {\n          object {\n            asMoveObject {\n              address\n              contents {\n                type {\n                  repr\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    objectChanges {\n      nodes {\n        address\n        inputState {\n          version\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n        outputState {\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `, {\"fragmentName\":\"TRANSACTION_FIELDS\"}) as unknown as TypedDocumentString<Transaction_FieldsFragment, unknown>;\nexport const GetAllBalancesDocument = new TypedDocumentString(`\n    query getAllBalances($owner: SuiAddress!, $limit: Int, $cursor: String) {\n  address(address: $owner) {\n    balances(first: $limit, after: $cursor) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        coinType {\n          repr\n        }\n        coinObjectCount\n        totalBalance\n      }\n    }\n  }\n}\n    `) as unknown as TypedDocumentString<GetAllBalancesQuery, GetAllBalancesQueryVariables>;\nexport const GetBalanceDocument = new TypedDocumentString(`\n    query getBalance($owner: SuiAddress!, $type: String = \"0x2::sui::SUI\") {\n  address(address: $owner) {\n    balance(type: $type) {\n      coinType {\n        repr\n      }\n      coinObjectCount\n      totalBalance\n    }\n  }\n}\n    `) as unknown as TypedDocumentString<GetBalanceQuery, GetBalanceQueryVariables>;\nexport const GetCoinsDocument = new TypedDocumentString(`\n    query getCoins($owner: SuiAddress!, $first: Int, $cursor: String, $type: String = \"0x2::sui::SUI\") {\n  address(address: $owner) {\n    address\n    coins(first: $first, after: $cursor, type: $type) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        coinBalance\n        owner {\n          ...OBJECT_OWNER_FIELDS\n        }\n        contents {\n          bcs\n          type {\n            repr\n          }\n        }\n        address\n        version\n        digest\n      }\n    }\n  }\n}\n    fragment OBJECT_OWNER_FIELDS on ObjectOwner {\n  __typename\n  ... on AddressOwner {\n    owner {\n      asObject {\n        address\n      }\n      asAddress {\n        address\n      }\n    }\n  }\n  ... on Parent {\n    parent {\n      address\n    }\n  }\n  ... on Shared {\n    initialSharedVersion\n  }\n  ... on ConsensusAddressOwner {\n    startVersion\n    owner {\n      address\n    }\n  }\n}`) as unknown as TypedDocumentString<GetCoinsQuery, GetCoinsQueryVariables>;\nexport const GetDynamicFieldsDocument = new TypedDocumentString(`\n    query getDynamicFields($parentId: SuiAddress!, $first: Int, $cursor: String) {\n  owner(address: $parentId) {\n    dynamicFields(first: $first, after: $cursor) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        name {\n          bcs\n          type {\n            repr\n          }\n        }\n        value {\n          __typename\n          ... on MoveValue {\n            type {\n              repr\n            }\n          }\n          ... on MoveObject {\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    `) as unknown as TypedDocumentString<GetDynamicFieldsQuery, GetDynamicFieldsQueryVariables>;\nexport const GetReferenceGasPriceDocument = new TypedDocumentString(`\n    query getReferenceGasPrice {\n  epoch {\n    referenceGasPrice\n  }\n}\n    `) as unknown as TypedDocumentString<GetReferenceGasPriceQuery, GetReferenceGasPriceQueryVariables>;\nexport const ResolveNameServiceNamesDocument = new TypedDocumentString(`\n    query resolveNameServiceNames($address: SuiAddress!, $limit: Int, $cursor: String) {\n  address(address: $address) {\n    suinsRegistrations(first: $limit, after: $cursor) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        domain\n      }\n    }\n  }\n}\n    `) as unknown as TypedDocumentString<ResolveNameServiceNamesQuery, ResolveNameServiceNamesQueryVariables>;\nexport const GetOwnedObjectsDocument = new TypedDocumentString(`\n    query getOwnedObjects($owner: SuiAddress!, $limit: Int, $cursor: String, $filter: ObjectFilter) {\n  address(address: $owner) {\n    objects(first: $limit, after: $cursor, filter: $filter) {\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n      nodes {\n        ...MOVE_OBJECT_FIELDS\n      }\n    }\n  }\n}\n    fragment MOVE_OBJECT_FIELDS on MoveObject {\n  address\n  digest\n  version\n  contents {\n    bcs\n    type {\n      repr\n    }\n  }\n  owner {\n    ...OBJECT_OWNER_FIELDS\n  }\n}\nfragment OBJECT_OWNER_FIELDS on ObjectOwner {\n  __typename\n  ... on AddressOwner {\n    owner {\n      asObject {\n        address\n      }\n      asAddress {\n        address\n      }\n    }\n  }\n  ... on Parent {\n    parent {\n      address\n    }\n  }\n  ... on Shared {\n    initialSharedVersion\n  }\n  ... on ConsensusAddressOwner {\n    startVersion\n    owner {\n      address\n    }\n  }\n}`) as unknown as TypedDocumentString<GetOwnedObjectsQuery, GetOwnedObjectsQueryVariables>;\nexport const MultiGetObjectsDocument = new TypedDocumentString(`\n    query multiGetObjects($objectIds: [SuiAddress!]!, $limit: Int, $cursor: String) {\n  objects(first: $limit, after: $cursor, filter: {objectIds: $objectIds}) {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    nodes {\n      ...OBJECT_FIELDS\n    }\n  }\n}\n    fragment OBJECT_FIELDS on Object {\n  address\n  digest\n  version\n  asMoveObject {\n    contents {\n      bcs\n      type {\n        repr\n      }\n    }\n  }\n  owner {\n    ...OBJECT_OWNER_FIELDS\n  }\n}\nfragment OBJECT_OWNER_FIELDS on ObjectOwner {\n  __typename\n  ... on AddressOwner {\n    owner {\n      asObject {\n        address\n      }\n      asAddress {\n        address\n      }\n    }\n  }\n  ... on Parent {\n    parent {\n      address\n    }\n  }\n  ... on Shared {\n    initialSharedVersion\n  }\n  ... on ConsensusAddressOwner {\n    startVersion\n    owner {\n      address\n    }\n  }\n}`) as unknown as TypedDocumentString<MultiGetObjectsQuery, MultiGetObjectsQueryVariables>;\nexport const DryRunTransactionBlockDocument = new TypedDocumentString(`\n    query dryRunTransactionBlock($txBytes: String!) {\n  dryRunTransactionBlock(txBytes: $txBytes) {\n    error\n    transaction {\n      ...TRANSACTION_FIELDS\n    }\n  }\n}\n    fragment TRANSACTION_FIELDS on TransactionBlock {\n  digest\n  bcs\n  signatures\n  effects {\n    bcs\n    epoch {\n      epochId\n    }\n    unchangedSharedObjects {\n      nodes {\n        __typename\n        ... on SharedObjectRead {\n          object {\n            asMoveObject {\n              address\n              contents {\n                type {\n                  repr\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    objectChanges {\n      nodes {\n        address\n        inputState {\n          version\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n        outputState {\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}`) as unknown as TypedDocumentString<DryRunTransactionBlockQuery, DryRunTransactionBlockQueryVariables>;\nexport const ExecuteTransactionBlockDocument = new TypedDocumentString(`\n    mutation executeTransactionBlock($txBytes: String!, $signatures: [String!]!) {\n  executeTransactionBlock(txBytes: $txBytes, signatures: $signatures) {\n    errors\n    effects {\n      transactionBlock {\n        ...TRANSACTION_FIELDS\n      }\n    }\n  }\n}\n    fragment TRANSACTION_FIELDS on TransactionBlock {\n  digest\n  bcs\n  signatures\n  effects {\n    bcs\n    epoch {\n      epochId\n    }\n    unchangedSharedObjects {\n      nodes {\n        __typename\n        ... on SharedObjectRead {\n          object {\n            asMoveObject {\n              address\n              contents {\n                type {\n                  repr\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    objectChanges {\n      nodes {\n        address\n        inputState {\n          version\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n        outputState {\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}`) as unknown as TypedDocumentString<ExecuteTransactionBlockMutation, ExecuteTransactionBlockMutationVariables>;\nexport const GetTransactionBlockDocument = new TypedDocumentString(`\n    query getTransactionBlock($digest: String!) {\n  transactionBlock(digest: $digest) {\n    ...TRANSACTION_FIELDS\n  }\n}\n    fragment TRANSACTION_FIELDS on TransactionBlock {\n  digest\n  bcs\n  signatures\n  effects {\n    bcs\n    epoch {\n      epochId\n    }\n    unchangedSharedObjects {\n      nodes {\n        __typename\n        ... on SharedObjectRead {\n          object {\n            asMoveObject {\n              address\n              contents {\n                type {\n                  repr\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    objectChanges {\n      nodes {\n        address\n        inputState {\n          version\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n        outputState {\n          asMoveObject {\n            address\n            contents {\n              type {\n                repr\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}`) as unknown as TypedDocumentString<GetTransactionBlockQuery, GetTransactionBlockQueryVariables>;\nexport const VerifyZkLoginSignatureDocument = new TypedDocumentString(`\n    query verifyZkLoginSignature($bytes: Base64!, $signature: Base64!, $intentScope: ZkLoginIntentScope!, $author: SuiAddress!) {\n  verifyZkloginSignature(\n    bytes: $bytes\n    signature: $signature\n    intentScope: $intentScope\n    author: $author\n  ) {\n    success\n    errors\n  }\n}\n    `) as unknown as TypedDocumentString<VerifyZkLoginSignatureQuery, VerifyZkLoginSignatureQueryVariables>;", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Experimental_CoreClient } from '../core.js';\nimport type { Experimental_SuiClientTypes } from '../types.js';\nimport type { GraphQLQueryOptions, SuiGraphQLClient } from '../../graphql/client.js';\nimport type {\n\tObject_Owner_FieldsFragment,\n\tObject_FieldsFragment,\n\tTransaction_FieldsFragment,\n} from '../../graphql/generated/queries.js';\nimport {\n\tDryRunTransactionBlockDocument,\n\tExecuteTransactionBlockDocument,\n\tGetAllBalancesDocument,\n\tGetBalanceDocument,\n\tGetCoinsDocument,\n\tGetDynamicFieldsDocument,\n\tGetOwnedObjectsDocument,\n\tGetReferenceGasPriceDocument,\n\tGetTransactionBlockDocument,\n\tMultiGetObjectsDocument,\n\tResolveNameServiceNamesDocument,\n\tVerifyZkLoginSignatureDocument,\n\tZkLoginIntentScope,\n} from '../../graphql/generated/queries.js';\nimport { ObjectError } from '../errors.js';\nimport { fromBase64, toBase64 } from '@mysten/utils';\nimport { normalizeStructTag, normalizeSuiAddress } from '../../utils/sui-types.js';\nimport { deriveDynamicFieldID } from '../../utils/dynamic-fields.js';\nimport { parseTransactionBcs, parseTransactionEffectsBcs } from './utils.js';\n\nexport class GraphQLTransport extends Experimental_CoreClient {\n\t#graphqlClient: SuiGraphQLClient;\n\n\tconstructor({\n\t\tgraphqlClient,\n\t\tmvr,\n\t}: {\n\t\tgraphqlClient: SuiGraphQLClient;\n\t\tmvr?: Experimental_SuiClientTypes.MvrOptions;\n\t}) {\n\t\tsuper({ network: graphqlClient.network, base: graphqlClient, mvr });\n\t\tthis.#graphqlClient = graphqlClient;\n\t}\n\n\tasync #graphqlQuery<\n\t\tResult = Record<string, unknown>,\n\t\tVariables = Record<string, unknown>,\n\t\tData = Result,\n\t>(\n\t\toptions: GraphQLQueryOptions<Result, Variables>,\n\t\tgetData?: (result: Result) => Data,\n\t): Promise<NonNullable<Data>> {\n\t\tconst { data, errors } = await this.#graphqlClient.query(options);\n\n\t\thandleGraphQLErrors(errors);\n\n\t\tconst extractedData = data && (getData ? getData(data) : data);\n\n\t\tif (extractedData == null) {\n\t\t\tthrow new Error('Missing response data');\n\t\t}\n\n\t\treturn extractedData as NonNullable<Data>;\n\t}\n\n\tasync getObjects(\n\t\toptions: Experimental_SuiClientTypes.GetObjectsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetObjectsResponse> {\n\t\tconst objects: Object_FieldsFragment[] = [];\n\n\t\tlet hasNextPage = true;\n\t\tlet cursor: string | null = null;\n\n\t\twhile (hasNextPage) {\n\t\t\tconst objectsPage = await this.#graphqlQuery(\n\t\t\t\t{\n\t\t\t\t\tquery: MultiGetObjectsDocument,\n\t\t\t\t\tvariables: {\n\t\t\t\t\t\tobjectIds: options.objectIds,\n\t\t\t\t\t\tcursor,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t(result) => result.objects,\n\t\t\t);\n\n\t\t\tobjects.push(...objectsPage.nodes);\n\t\t\thasNextPage = objectsPage.pageInfo.hasNextPage;\n\t\t\tcursor = (objectsPage.pageInfo.endCursor ?? null) as string | null;\n\t\t}\n\n\t\treturn {\n\t\t\tobjects: options.objectIds\n\t\t\t\t.map((id) => normalizeSuiAddress(id))\n\t\t\t\t.map(\n\t\t\t\t\t(id) =>\n\t\t\t\t\t\tobjects.find((obj) => obj.address === id) ??\n\t\t\t\t\t\tnew ObjectError('notFound', `Object ${id} not found`),\n\t\t\t\t)\n\t\t\t\t.map((obj) => {\n\t\t\t\t\tif (obj instanceof ObjectError) {\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: obj.address,\n\t\t\t\t\t\tversion: obj.version.toString(),\n\t\t\t\t\t\tdigest: obj.digest!,\n\t\t\t\t\t\towner: mapOwner(obj.owner!),\n\t\t\t\t\t\ttype: obj.asMoveObject?.contents?.type?.repr!,\n\t\t\t\t\t\tcontent: Promise.resolve(\n\t\t\t\t\t\t\tobj.asMoveObject?.contents?.bcs\n\t\t\t\t\t\t\t\t? fromBase64(obj.asMoveObject.contents.bcs)\n\t\t\t\t\t\t\t\t: new Uint8Array(),\n\t\t\t\t\t\t),\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t};\n\t}\n\tasync getOwnedObjects(\n\t\toptions: Experimental_SuiClientTypes.GetOwnedObjectsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetOwnedObjectsResponse> {\n\t\tconst objects = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetOwnedObjectsDocument,\n\t\t\t\tvariables: {\n\t\t\t\t\towner: options.address,\n\t\t\t\t\tlimit: options.limit,\n\t\t\t\t\tcursor: options.cursor,\n\t\t\t\t\tfilter: options.type ? { type: options.type } : undefined,\n\t\t\t\t},\n\t\t\t},\n\t\t\t(result) => result.address?.objects,\n\t\t);\n\n\t\treturn {\n\t\t\tobjects: objects.nodes.map((obj) => ({\n\t\t\t\tid: obj.address,\n\t\t\t\tversion: obj.version.toString(),\n\t\t\t\tdigest: obj.digest!,\n\t\t\t\towner: mapOwner(obj.owner!),\n\t\t\t\ttype: obj.contents?.type?.repr!,\n\t\t\t\tcontent: Promise.resolve(\n\t\t\t\t\tobj.contents?.bcs ? fromBase64(obj.contents.bcs) : new Uint8Array(),\n\t\t\t\t),\n\t\t\t})),\n\t\t\thasNextPage: objects.pageInfo.hasNextPage,\n\t\t\tcursor: objects.pageInfo.endCursor ?? null,\n\t\t};\n\t}\n\tasync getCoins(\n\t\toptions: Experimental_SuiClientTypes.GetCoinsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetCoinsResponse> {\n\t\tconst coins = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetCoinsDocument,\n\t\t\t\tvariables: {\n\t\t\t\t\towner: options.address,\n\t\t\t\t\tcursor: options.cursor,\n\t\t\t\t\tfirst: options.limit,\n\t\t\t\t\ttype: options.coinType,\n\t\t\t\t},\n\t\t\t},\n\t\t\t(result) => result.address?.coins,\n\t\t);\n\n\t\treturn {\n\t\t\tcursor: coins.pageInfo.endCursor ?? null,\n\t\t\thasNextPage: coins.pageInfo.hasNextPage,\n\t\t\tobjects: coins.nodes.map((coin) => ({\n\t\t\t\tid: coin.address,\n\t\t\t\tversion: coin.version.toString(),\n\t\t\t\tdigest: coin.digest!,\n\t\t\t\towner: mapOwner(coin.owner!),\n\t\t\t\ttype: coin.contents?.type?.repr!,\n\t\t\t\tbalance: coin.coinBalance,\n\t\t\t\tcontent: Promise.resolve(\n\t\t\t\t\tcoin.contents?.bcs ? fromBase64(coin.contents.bcs) : new Uint8Array(),\n\t\t\t\t),\n\t\t\t})),\n\t\t};\n\t}\n\n\tasync getBalance(\n\t\toptions: Experimental_SuiClientTypes.GetBalanceOptions,\n\t): Promise<Experimental_SuiClientTypes.GetBalanceResponse> {\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetBalanceDocument,\n\t\t\t\tvariables: { owner: options.address, type: options.coinType },\n\t\t\t},\n\t\t\t(result) => result.address?.balance,\n\t\t);\n\n\t\treturn {\n\t\t\tbalance: {\n\t\t\t\tcoinType: result.coinType.repr,\n\t\t\t\tbalance: result.totalBalance,\n\t\t\t},\n\t\t};\n\t}\n\tasync getAllBalances(\n\t\toptions: Experimental_SuiClientTypes.GetAllBalancesOptions,\n\t): Promise<Experimental_SuiClientTypes.GetAllBalancesResponse> {\n\t\tconst balances = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetAllBalancesDocument,\n\t\t\t\tvariables: { owner: options.address },\n\t\t\t},\n\t\t\t(result) => result.address?.balances,\n\t\t);\n\n\t\treturn {\n\t\t\tcursor: balances.pageInfo.endCursor ?? null,\n\t\t\thasNextPage: balances.pageInfo.hasNextPage,\n\t\t\tbalances: balances.nodes.map((balance) => ({\n\t\t\t\tcoinType: balance.coinType.repr,\n\t\t\t\tbalance: balance.totalBalance,\n\t\t\t})),\n\t\t};\n\t}\n\tasync getTransaction(\n\t\toptions: Experimental_SuiClientTypes.GetTransactionOptions,\n\t): Promise<Experimental_SuiClientTypes.GetTransactionResponse> {\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetTransactionBlockDocument,\n\t\t\t\tvariables: { digest: options.digest },\n\t\t\t},\n\t\t\t(result) => result.transactionBlock,\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: parseTransaction(result),\n\t\t};\n\t}\n\tasync executeTransaction(\n\t\toptions: Experimental_SuiClientTypes.ExecuteTransactionOptions,\n\t): Promise<Experimental_SuiClientTypes.ExecuteTransactionResponse> {\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: ExecuteTransactionBlockDocument,\n\t\t\t\tvariables: { txBytes: toBase64(options.transaction), signatures: options.signatures },\n\t\t\t},\n\t\t\t(result) => result.executeTransactionBlock,\n\t\t);\n\n\t\tif (result.errors) {\n\t\t\tif (result.errors.length === 1) {\n\t\t\t\tthrow new Error(result.errors[0]);\n\t\t\t}\n\t\t\tthrow new AggregateError(result.errors.map((error) => new Error(error)));\n\t\t}\n\n\t\treturn {\n\t\t\ttransaction: parseTransaction(result.effects.transactionBlock!),\n\t\t};\n\t}\n\tasync dryRunTransaction(\n\t\toptions: Experimental_SuiClientTypes.DryRunTransactionOptions,\n\t): Promise<Experimental_SuiClientTypes.DryRunTransactionResponse> {\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: DryRunTransactionBlockDocument,\n\t\t\t\tvariables: { txBytes: toBase64(options.transaction) },\n\t\t\t},\n\t\t\t(result) => result.dryRunTransactionBlock,\n\t\t);\n\n\t\tif (result.error) {\n\t\t\tthrow new Error(result.error);\n\t\t}\n\n\t\treturn {\n\t\t\ttransaction: parseTransaction(result.transaction!),\n\t\t};\n\t}\n\tasync getReferenceGasPrice(): Promise<Experimental_SuiClientTypes.GetReferenceGasPriceResponse> {\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetReferenceGasPriceDocument,\n\t\t\t},\n\t\t\t(result) => result.epoch?.referenceGasPrice,\n\t\t);\n\n\t\treturn {\n\t\t\treferenceGasPrice: result.referenceGasPrice,\n\t\t};\n\t}\n\n\tasync getDynamicFields(\n\t\toptions: Experimental_SuiClientTypes.GetDynamicFieldsOptions,\n\t): Promise<Experimental_SuiClientTypes.GetDynamicFieldsResponse> {\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: GetDynamicFieldsDocument,\n\t\t\t\tvariables: { parentId: options.parentId },\n\t\t\t},\n\t\t\t(result) => result.owner?.dynamicFields,\n\t\t);\n\n\t\treturn {\n\t\t\tdynamicFields: result.nodes.map((dynamicField) => {\n\t\t\t\tconst valueType =\n\t\t\t\t\tdynamicField.value?.__typename === 'MoveObject'\n\t\t\t\t\t\t? dynamicField.value.contents?.type?.repr!\n\t\t\t\t\t\t: dynamicField.value?.type.repr!;\n\t\t\t\treturn {\n\t\t\t\t\tid: deriveDynamicFieldID(\n\t\t\t\t\t\toptions.parentId,\n\t\t\t\t\t\tdynamicField.name?.type.repr!,\n\t\t\t\t\t\tdynamicField.name?.bcs!,\n\t\t\t\t\t),\n\t\t\t\t\ttype: normalizeStructTag(\n\t\t\t\t\t\tdynamicField.value?.__typename === 'MoveObject'\n\t\t\t\t\t\t\t? `0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${dynamicField.name?.type.repr}>,0x2::object::ID>`\n\t\t\t\t\t\t\t: `0x2::dynamic_field::Field<${dynamicField.name?.type.repr},${valueType}>`,\n\t\t\t\t\t),\n\t\t\t\t\tname: {\n\t\t\t\t\t\ttype: dynamicField.name?.type.repr!,\n\t\t\t\t\t\tbcs: fromBase64(dynamicField.name?.bcs!),\n\t\t\t\t\t},\n\t\t\t\t\tvalueType,\n\t\t\t\t};\n\t\t\t}),\n\t\t\tcursor: result.pageInfo.endCursor ?? null,\n\t\t\thasNextPage: result.pageInfo.hasNextPage,\n\t\t};\n\t}\n\n\tasync verifyZkLoginSignature(\n\t\toptions: Experimental_SuiClientTypes.VerifyZkLoginSignatureOptions,\n\t): Promise<Experimental_SuiClientTypes.ZkLoginVerifyResponse> {\n\t\tconst intentScope =\n\t\t\toptions.intentScope === 'TransactionData'\n\t\t\t\t? ZkLoginIntentScope.TransactionData\n\t\t\t\t: ZkLoginIntentScope.PersonalMessage;\n\n\t\tconst result = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: VerifyZkLoginSignatureDocument,\n\t\t\t\tvariables: {\n\t\t\t\t\tbytes: options.bytes,\n\t\t\t\t\tsignature: options.signature,\n\t\t\t\t\tintentScope,\n\t\t\t\t\tauthor: options.author,\n\t\t\t\t},\n\t\t\t},\n\t\t\t(result) => result.verifyZkloginSignature,\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: result.success,\n\t\t\terrors: result.errors,\n\t\t};\n\t}\n\n\tasync resolveNameServiceNames(\n\t\toptions: Experimental_SuiClientTypes.ResolveNameServiceNamesOptions,\n\t): Promise<Experimental_SuiClientTypes.ResolveNameServiceNamesResponse> {\n\t\tconst suinsRegistrations = await this.#graphqlQuery(\n\t\t\t{\n\t\t\t\tquery: ResolveNameServiceNamesDocument,\n\t\t\t\tsignal: options.signal,\n\t\t\t\tvariables: {\n\t\t\t\t\taddress: options.address,\n\t\t\t\t\tcursor: options.cursor,\n\t\t\t\t\tlimit: options.limit,\n\t\t\t\t},\n\t\t\t},\n\t\t\t(result) => result.address?.suinsRegistrations,\n\t\t);\n\n\t\treturn {\n\t\t\thasNextPage: suinsRegistrations.pageInfo.hasNextPage,\n\t\t\tnextCursor: suinsRegistrations.pageInfo.endCursor ?? null,\n\t\t\tdata: suinsRegistrations.nodes.map((node) => node.domain) ?? [],\n\t\t};\n\t}\n\n\tresolveTransactionPlugin(): never {\n\t\tthrow new Error('GraphQL client does not support transaction resolution yet');\n\t}\n}\nexport type GraphQLResponseErrors = Array<{\n\tmessage: string;\n\tlocations?: { line: number; column: number }[];\n\tpath?: (string | number)[];\n}>;\n\nfunction handleGraphQLErrors(errors: GraphQLResponseErrors | undefined): void {\n\tif (!errors || errors.length === 0) return;\n\n\tconst errorInstances = errors.map((error) => new GraphQLResponseError(error));\n\n\tif (errorInstances.length === 1) {\n\t\tthrow errorInstances[0];\n\t}\n\n\tthrow new AggregateError(errorInstances);\n}\n\nclass GraphQLResponseError extends Error {\n\tlocations?: Array<{ line: number; column: number }>;\n\n\tconstructor(error: GraphQLResponseErrors[0]) {\n\t\tsuper(error.message);\n\t\tthis.locations = error.locations;\n\t}\n}\n\nfunction mapOwner(owner: Object_Owner_FieldsFragment): Experimental_SuiClientTypes.ObjectOwner {\n\tswitch (owner.__typename) {\n\t\tcase 'AddressOwner':\n\t\t\treturn { $kind: 'AddressOwner', AddressOwner: owner.owner?.asAddress?.address };\n\t\tcase 'ConsensusAddressOwner':\n\t\t\treturn {\n\t\t\t\t$kind: 'ConsensusAddressOwner',\n\t\t\t\tConsensusAddressOwner: {\n\t\t\t\t\towner: owner.owner?.address,\n\t\t\t\t\tstartVersion: owner.startVersion,\n\t\t\t\t},\n\t\t\t};\n\t\tcase 'Immutable':\n\t\t\treturn { $kind: 'Immutable', Immutable: true };\n\t\tcase 'Parent':\n\t\t\treturn { $kind: 'ObjectOwner', ObjectOwner: owner.parent?.address };\n\t\tcase 'Shared':\n\t\t\treturn { $kind: 'Shared', Shared: owner.initialSharedVersion };\n\t}\n}\n\nfunction parseTransaction(\n\ttransaction: Transaction_FieldsFragment,\n): Experimental_SuiClientTypes.TransactionResponse {\n\tconst objectTypes: Record<string, string> = {};\n\n\ttransaction.effects?.unchangedSharedObjects.nodes.forEach((node) => {\n\t\tif (node.__typename === 'SharedObjectRead') {\n\t\t\tconst type = node.object?.asMoveObject?.contents?.type.repr;\n\t\t\tconst address = node.object?.asMoveObject?.address;\n\n\t\t\tif (type && address) {\n\t\t\t\tobjectTypes[address] = type;\n\t\t\t}\n\t\t}\n\t});\n\n\ttransaction.effects?.objectChanges.nodes.forEach((node) => {\n\t\tconst address = node.address;\n\t\tconst type =\n\t\t\tnode.inputState?.asMoveObject?.contents?.type.repr ??\n\t\t\tnode.outputState?.asMoveObject?.contents?.type.repr;\n\n\t\tif (address && type) {\n\t\t\tobjectTypes[address] = type;\n\t\t}\n\t});\n\n\treturn {\n\t\tdigest: transaction.digest!,\n\t\teffects: parseTransactionEffectsBcs(new Uint8Array(transaction.effects?.bcs!)),\n\t\tepoch: transaction.effects?.epoch?.epochId ?? null,\n\t\tobjectTypes: Promise.resolve(objectTypes),\n\t\ttransaction: parseTransactionBcs(transaction.bcs!),\n\t\tsignatures: transaction.signatures!,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport type { TadaDocumentNode } from 'gql.tada';\nimport type { DocumentNode } from 'graphql';\nimport { print } from 'graphql';\nimport { Experimental_BaseClient } from '../experimental/index.js';\nimport type { Experimental_SuiClientTypes } from '../experimental/index.js';\nimport { GraphQLTransport } from '../experimental/transports/graphql.js';\nimport type { TypedDocumentString } from './generated/queries.js';\n\nexport type GraphQLDocument<\n\tResult = Record<string, unknown>,\n\tVariables = Record<string, unknown>,\n> =\n\t| string\n\t| DocumentNode\n\t| TypedDocumentString<Result, Variables>\n\t| TypedDocumentNode<Result, Variables>\n\t| TadaDocumentNode<Result, Variables>;\n\nexport type GraphQLQueryOptions<\n\tResult = Record<string, unknown>,\n\tVariables = Record<string, unknown>,\n> = {\n\tquery: GraphQLDocument<Result, Variables>;\n\toperationName?: string;\n\textensions?: Record<string, unknown>;\n\tsignal?: AbortSignal;\n} & (Variables extends { [key: string]: never }\n\t? { variables?: Variables }\n\t: {\n\t\t\tvariables: Variables;\n\t\t});\n\nexport type GraphQLQueryResult<Result = Record<string, unknown>> = {\n\tdata?: Result;\n\terrors?: GraphQLResponseErrors;\n\textensions?: Record<string, unknown>;\n};\n\nexport type GraphQLResponseErrors = Array<{\n\tmessage: string;\n\tlocations?: { line: number; column: number }[];\n\tpath?: (string | number)[];\n}>;\n\nexport interface SuiGraphQLClientOptions<Queries extends Record<string, GraphQLDocument>> {\n\turl: string;\n\tfetch?: typeof fetch;\n\theaders?: Record<string, string>;\n\tqueries?: Queries;\n\tnetwork?: Experimental_SuiClientTypes.Network;\n\tmvr?: Experimental_SuiClientTypes.MvrOptions;\n}\n\nexport class SuiGraphQLRequestError extends Error {}\n\nexport class SuiGraphQLClient<\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tQueries extends Record<string, GraphQLDocument> = {},\n> extends Experimental_BaseClient {\n\t#url: string;\n\t#queries: Queries;\n\t#headers: Record<string, string>;\n\t#fetch: typeof fetch;\n\tcore: GraphQLTransport;\n\n\tconstructor({\n\t\turl,\n\t\tfetch: fetchFn = fetch,\n\t\theaders = {},\n\t\tqueries = {} as Queries,\n\t\tnetwork = 'unknown',\n\t\tmvr,\n\t}: SuiGraphQLClientOptions<Queries>) {\n\t\tsuper({\n\t\t\tnetwork,\n\t\t});\n\t\tthis.#url = url;\n\t\tthis.#queries = queries;\n\t\tthis.#headers = headers;\n\t\tthis.#fetch = (...args) => fetchFn(...args);\n\t\tthis.core = new GraphQLTransport({\n\t\t\tgraphqlClient: this,\n\t\t\tmvr,\n\t\t});\n\t}\n\n\tasync query<Result = Record<string, unknown>, Variables = Record<string, unknown>>(\n\t\toptions: GraphQLQueryOptions<Result, Variables>,\n\t): Promise<GraphQLQueryResult<Result>> {\n\t\tconst res = await this.#fetch(this.#url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...this.#headers,\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tquery:\n\t\t\t\t\ttypeof options.query === 'string' || options.query instanceof String\n\t\t\t\t\t\t? String(options.query)\n\t\t\t\t\t\t: print(options.query),\n\t\t\t\tvariables: options.variables,\n\t\t\t\textensions: options.extensions,\n\t\t\t\toperationName: options.operationName,\n\t\t\t}),\n\t\t\tsignal: options.signal,\n\t\t});\n\n\t\tif (!res.ok) {\n\t\t\tthrow new SuiGraphQLRequestError(`GraphQL request failed: ${res.statusText} (${res.status})`);\n\t\t}\n\n\t\treturn await res.json();\n\t}\n\n\tasync execute<\n\t\tconst Query extends Extract<keyof Queries, string>,\n\t\tResult = Queries[Query] extends GraphQLDocument<infer R, unknown> ? R : Record<string, unknown>,\n\t\tVariables = Queries[Query] extends GraphQLDocument<unknown, infer V>\n\t\t\t? V\n\t\t\t: Record<string, unknown>,\n\t>(\n\t\tquery: Query,\n\t\toptions: Omit<GraphQLQueryOptions<Result, Variables>, 'query'>,\n\t): Promise<GraphQLQueryResult<Result>> {\n\t\treturn this.query({\n\t\t\t...(options as { variables: Record<string, unknown> }),\n\t\t\tquery: this.#queries[query]!,\n\t\t}) as Promise<GraphQLQueryResult<Result>>;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Copied from https://github.com/auth0/jwt-decode/blob/3d372e9875ff673228a9f2d9df74e84690842a9c/lib/index.ts */\n\n/**\nThe MIT License (MIT)\n\nCopyright (c) 2015 Auth0, Inc. <support@auth0.com> (http://auth0.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\nexport interface JwtDecodeOptions {\n\theader?: boolean;\n}\n\nexport interface JwtHeader {\n\ttyp?: string;\n\talg?: string;\n\tkid?: string;\n}\n\nexport interface JwtPayload {\n\tiss?: string;\n\tsub?: string;\n\taud?: string[] | string;\n\texp?: number;\n\tnbf?: number;\n\tiat?: number;\n\tjti?: string;\n}\n\nexport class InvalidTokenError extends Error {}\n\nInvalidTokenError.prototype.name = 'InvalidTokenError';\n\nfunction b64DecodeUnicode(str: string) {\n\treturn decodeURIComponent(\n\t\tatob(str).replace(/(.)/g, (_m, p) => {\n\t\t\tlet code = (p as string).charCodeAt(0).toString(16).toUpperCase();\n\t\t\tif (code.length < 2) {\n\t\t\t\tcode = '0' + code;\n\t\t\t}\n\t\t\treturn '%' + code;\n\t\t}),\n\t);\n}\n\nfunction base64UrlDecode(str: string) {\n\tlet output = str.replace(/-/g, '+').replace(/_/g, '/');\n\tswitch (output.length % 4) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\toutput += '==';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\toutput += '=';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('base64 string is not of the correct length');\n\t}\n\n\ttry {\n\t\treturn b64DecodeUnicode(output);\n\t} catch (err) {\n\t\treturn atob(output);\n\t}\n}\n\nexport function jwtDecode<T = JwtHeader>(\n\ttoken: string,\n\toptions: JwtDecodeOptions & { header: true },\n): T;\nexport function jwtDecode<T = JwtPayload>(token: string, options?: JwtDecodeOptions): T;\nexport function jwtDecode<T = JwtHeader | JwtPayload>(\n\ttoken: string,\n\toptions?: JwtDecodeOptions,\n): T {\n\tif (typeof token !== 'string') {\n\t\tthrow new InvalidTokenError('Invalid token specified: must be a string');\n\t}\n\n\toptions ||= {};\n\n\tconst pos = options.header === true ? 0 : 1;\n\tconst part = token.split('.')[pos];\n\n\tif (typeof part !== 'string') {\n\t\tthrow new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n\t}\n\n\tlet decoded: string;\n\ttry {\n\t\tdecoded = base64UrlDecode(part);\n\t} catch (e) {\n\t\tthrow new InvalidTokenError(\n\t\t\t`Invalid token specified: invalid base64 for part #${pos + 1} (${(e as Error).message})`,\n\t\t);\n\t}\n\n\ttry {\n\t\treturn JSON.parse(decoded) as T;\n\t} catch (e) {\n\t\tthrow new InvalidTokenError(\n\t\t\t`Invalid token specified: invalid json for part #${pos + 1} (${(e as Error).message})`,\n\t\t);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tposeidon1,\n\tposeidon2,\n\tposeidon3,\n\tposeidon4,\n\tposeidon5,\n\tposeidon6,\n\tposeidon7,\n\tposeidon8,\n\tposeidon9,\n\tposeidon10,\n\tposeidon11,\n\tposeidon12,\n\tposeidon13,\n\tposeidon14,\n\tposeidon15,\n\tposeidon16,\n} from 'poseidon-lite';\n\nconst poseidonNumToHashFN = [\n\tposeidon1,\n\tposeidon2,\n\tposeidon3,\n\tposeidon4,\n\tposeidon5,\n\tposeidon6,\n\tposeidon7,\n\tposeidon8,\n\tposeidon9,\n\tposeidon10,\n\tposeidon11,\n\tposeidon12,\n\tposeidon13,\n\tposeidon14,\n\tposeidon15,\n\tposeidon16,\n];\n\nexport const BN254_FIELD_SIZE =\n\t21888242871839275222246405745257275088548364400416034343698204186575808495617n;\n\nexport function poseidonHash(inputs: (number | bigint | string)[]): bigint {\n\tinputs.forEach((x) => {\n\t\tconst b = BigInt(x);\n\t\tif (b < 0 || b >= BN254_FIELD_SIZE) {\n\t\t\tthrow new Error(`Element ${b} not in the BN254 field`);\n\t\t}\n\t});\n\n\tconst hashFN = poseidonNumToHashFN[inputs.length - 1];\n\n\tif (hashFN) {\n\t\treturn hashFN(inputs);\n\t} else if (inputs.length <= 32) {\n\t\tconst hash1 = poseidonHash(inputs.slice(0, 16));\n\t\tconst hash2 = poseidonHash(inputs.slice(16));\n\t\treturn poseidonHash([hash1, hash2]);\n\t} else {\n\t\tthrow new Error(`Yet to implement: Unable to hash a vector of length ${inputs.length}`);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { hexToBytes } from '@noble/hashes/utils';\n\nimport type { PublicKey } from '../cryptography/publickey.js';\nimport { poseidonHash } from './poseidon.js';\n\nconst MAX_KEY_CLAIM_NAME_LENGTH = 32;\nconst MAX_KEY_CLAIM_VALUE_LENGTH = 115;\nconst MAX_AUD_VALUE_LENGTH = 145;\nconst PACK_WIDTH = 248;\n\nfunction findFirstNonZeroIndex(bytes: Uint8Array) {\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tif (bytes[i] !== 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n// Derive bytearray from num where the bytearray is padded to the left with 0s to the specified width.\nexport function toPaddedBigEndianBytes(num: bigint, width: number): Uint8Array {\n\tconst hex = num.toString(16);\n\treturn hexToBytes(hex.padStart(width * 2, '0').slice(-width * 2));\n}\n\n// Derive bytearray from num where the bytearray is not padded with 0.\nexport function toBigEndianBytes(num: bigint, width: number): Uint8Array {\n\tconst bytes = toPaddedBigEndianBytes(num, width);\n\n\tconst firstNonZeroIndex = findFirstNonZeroIndex(bytes);\n\n\tif (firstNonZeroIndex === -1) {\n\t\treturn new Uint8Array([0]);\n\t}\n\n\treturn bytes.slice(firstNonZeroIndex);\n}\n\nexport function getExtendedEphemeralPublicKey(publicKey: PublicKey) {\n\treturn publicKey.toSuiPublicKey();\n}\n\n/**\n * Splits an array into chunks of size chunk_size. If the array is not evenly\n * divisible by chunk_size, the first chunk will be smaller than chunk_size.\n *\n * E.g., arrayChunk([1, 2, 3, 4, 5], 2) => [[1], [2, 3], [4, 5]]\n *\n * Note: Can be made more efficient by avoiding the reverse() calls.\n */\nexport function chunkArray<T>(array: T[], chunk_size: number): T[][] {\n\tconst chunks = Array(Math.ceil(array.length / chunk_size));\n\tconst revArray = array.reverse();\n\tfor (let i = 0; i < chunks.length; i++) {\n\t\tchunks[i] = revArray.slice(i * chunk_size, (i + 1) * chunk_size).reverse();\n\t}\n\treturn chunks.reverse();\n}\n\nfunction bytesBEToBigInt(bytes: number[]): bigint {\n\tconst hex = bytes.map((b) => b.toString(16).padStart(2, '0')).join('');\n\tif (hex.length === 0) {\n\t\treturn BigInt(0);\n\t}\n\treturn BigInt('0x' + hex);\n}\n\n// hashes an ASCII string to a field element\nexport function hashASCIIStrToField(str: string, maxSize: number) {\n\tif (str.length > maxSize) {\n\t\tthrow new Error(`String ${str} is longer than ${maxSize} chars`);\n\t}\n\n\t// Note: Padding with zeroes is safe because we are only using this function to map human-readable sequence of bytes.\n\t// So the ASCII values of those characters will never be zero (null character).\n\tconst strPadded = str\n\t\t.padEnd(maxSize, String.fromCharCode(0))\n\t\t.split('')\n\t\t.map((c) => c.charCodeAt(0));\n\n\tconst chunkSize = PACK_WIDTH / 8;\n\tconst packed = chunkArray(strPadded, chunkSize).map((chunk) => bytesBEToBigInt(chunk));\n\treturn poseidonHash(packed);\n}\n\nexport function genAddressSeed(\n\tsalt: string | bigint,\n\tname: string,\n\tvalue: string,\n\taud: string,\n\tmax_name_length = MAX_KEY_CLAIM_NAME_LENGTH,\n\tmax_value_length = MAX_KEY_CLAIM_VALUE_LENGTH,\n\tmax_aud_length = MAX_AUD_VALUE_LENGTH,\n): bigint {\n\treturn poseidonHash([\n\t\thashASCIIStrToField(name, max_name_length),\n\t\thashASCIIStrToField(value, max_value_length),\n\t\thashASCIIStrToField(aud, max_aud_length),\n\t\tposeidonHash([BigInt(salt)]),\n\t]);\n}\n\nexport function normalizeZkLoginIssuer(iss: string) {\n\tif (iss === 'accounts.google.com') {\n\t\treturn 'https://accounts.google.com';\n\t}\n\treturn iss;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferBcsInput } from '@mysten/bcs';\nimport { bcs } from '@mysten/bcs';\n\nexport const zkLoginSignature = bcs.struct('ZkLoginSignature', {\n\tinputs: bcs.struct('ZkLoginSignatureInputs', {\n\t\tproofPoints: bcs.struct('ZkLoginSignatureInputsProofPoints', {\n\t\t\ta: bcs.vector(bcs.string()),\n\t\t\tb: bcs.vector(bcs.vector(bcs.string())),\n\t\t\tc: bcs.vector(bcs.string()),\n\t\t}),\n\t\tissBase64Details: bcs.struct('ZkLoginSignatureInputsClaim', {\n\t\t\tvalue: bcs.string(),\n\t\t\tindexMod4: bcs.u8(),\n\t\t}),\n\t\theaderBase64: bcs.string(),\n\t\taddressSeed: bcs.string(),\n\t}),\n\tmaxEpoch: bcs.u64(),\n\tuserSignature: bcs.vector(bcs.u8()),\n});\n\nexport type ZkLoginSignature = InferBcsInput<typeof zkLoginSignature>;\nexport type ZkLoginSignatureInputs = ZkLoginSignature['inputs'];\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64, toHex } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { PublicKey } from '../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../cryptography/signature-scheme.js';\nimport { SuiGraphQLClient } from '../graphql/client.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport type { ZkLoginSignatureInputs } from './bcs.js';\nimport { extractClaimValue } from './jwt-utils.js';\nimport { parseZkLoginSignature } from './signature.js';\nimport { normalizeZkLoginIssuer, toBigEndianBytes, toPaddedBigEndianBytes } from './utils.js';\nimport type { ClientWithExtensions, Experimental_SuiClientTypes } from '../experimental/types.js';\n\nexport interface ZkLoginCompatibleClient\n\textends ClientWithExtensions<{\n\t\tcore: {\n\t\t\tverifyZkLoginSignature: Experimental_SuiClientTypes.TransportMethods['verifyZkLoginSignature'];\n\t\t};\n\t}> {}\n\n/**\n * A zkLogin public identifier\n */\nexport class ZkLoginPublicIdentifier extends PublicKey {\n\t#data: Uint8Array;\n\t#client?: ZkLoginCompatibleClient;\n\t#legacyAddress: boolean;\n\n\t/**\n\t * Create a new ZkLoginPublicIdentifier object\n\t * @param value zkLogin public identifier as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData, { client }: { client?: ZkLoginCompatibleClient } = {}) {\n\t\tsuper();\n\n\t\tthis.#client = client;\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.#data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.#data = value;\n\t\t} else {\n\t\t\tthis.#data = Uint8Array.from(value);\n\t\t}\n\t\tthis.#legacyAddress = this.#data.length !== this.#data[0] + 1 + 32;\n\n\t\tif (this.#legacyAddress) {\n\t\t\tthis.#data = normalizeZkLoginPublicKeyBytes(this.#data);\n\t\t}\n\t}\n\n\tstatic fromBytes(\n\t\tbytes: Uint8Array,\n\t\t{\n\t\t\tclient,\n\t\t\taddress,\n\t\t\tlegacyAddress,\n\t\t}: { client?: ZkLoginCompatibleClient; address?: string; legacyAddress?: boolean } = {},\n\t) {\n\t\tlet publicKey: ZkLoginPublicIdentifier;\n\n\t\tif (legacyAddress === true) {\n\t\t\tpublicKey = new ZkLoginPublicIdentifier(normalizeZkLoginPublicKeyBytes(bytes, true), {\n\t\t\t\tclient,\n\t\t\t});\n\t\t} else if (legacyAddress === false) {\n\t\t\tpublicKey = new ZkLoginPublicIdentifier(normalizeZkLoginPublicKeyBytes(bytes, false), {\n\t\t\t\tclient,\n\t\t\t});\n\t\t} else if (address) {\n\t\t\tpublicKey = new ZkLoginPublicIdentifier(normalizeZkLoginPublicKeyBytes(bytes, false), {\n\t\t\t\tclient,\n\t\t\t});\n\n\t\t\tif (publicKey.toSuiAddress() !== address) {\n\t\t\t\tpublicKey = new ZkLoginPublicIdentifier(normalizeZkLoginPublicKeyBytes(bytes, true), {\n\t\t\t\t\tclient,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tpublicKey = new ZkLoginPublicIdentifier(bytes, {\n\t\t\t\tclient,\n\t\t\t});\n\t\t}\n\n\t\tif (address && publicKey.toSuiAddress() !== address) {\n\t\t\tthrow new Error('Public key bytes do not match the provided address');\n\t\t}\n\n\t\treturn publicKey;\n\t}\n\n\tstatic fromProof(address: string, proof: ZkLoginSignatureInputs) {\n\t\tconst { issBase64Details, addressSeed } = proof;\n\t\tconst iss = extractClaimValue<string>(issBase64Details, 'iss');\n\n\t\tconst legacyPublicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {\n\t\t\tlegacyAddress: true,\n\t\t});\n\n\t\tif (legacyPublicKey.toSuiAddress() === address) {\n\t\t\treturn legacyPublicKey;\n\t\t}\n\n\t\tconst publicKey = toZkLoginPublicIdentifier(BigInt(addressSeed), iss, {\n\t\t\tlegacyAddress: false,\n\t\t});\n\n\t\tif (publicKey.toSuiAddress() !== address) {\n\t\t\tthrow new Error('Proof does not match address');\n\t\t}\n\n\t\treturn publicKey;\n\t}\n\n\t/**\n\t * Checks if two zkLogin public identifiers are equal\n\t */\n\toverride equals(publicKey: ZkLoginPublicIdentifier): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\toverride toSuiAddress(): string {\n\t\tif (this.#legacyAddress) {\n\t\t\treturn this.#toLegacyAddress();\n\t\t}\n\n\t\treturn super.toSuiAddress();\n\t}\n\n\t#toLegacyAddress() {\n\t\tconst legacyBytes = normalizeZkLoginPublicKeyBytes(this.#data, true);\n\t\tconst addressBytes = new Uint8Array(legacyBytes.length + 1);\n\t\taddressBytes[0] = this.flag();\n\t\taddressBytes.set(legacyBytes, 1);\n\t\treturn normalizeSuiAddress(\n\t\t\tbytesToHex(blake2b(addressBytes, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n\t\t);\n\t}\n\n\t/**\n\t * Return the byte array representation of the zkLogin public identifier\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this ZkLogin public identifier\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['ZkLogin'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(_message: Uint8Array, _signature: Uint8Array | string): Promise<boolean> {\n\t\tthrow Error('does not support');\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided PersonalMessage\n\t */\n\tverifyPersonalMessage(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(message),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'PersonalMessage',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided Transaction\n\t */\n\tverifyTransaction(transaction: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tconst parsedSignature = parseSerializedZkLoginSignature(signature);\n\t\tconst address = new ZkLoginPublicIdentifier(parsedSignature.publicKey).toSuiAddress();\n\t\treturn graphqlVerifyZkLoginSignature({\n\t\t\taddress: address,\n\t\t\tbytes: toBase64(transaction),\n\t\t\tsignature: parsedSignature.serializedSignature,\n\t\t\tintentScope: 'TransactionData',\n\t\t\tclient: this.#client,\n\t\t});\n\t}\n\n\t/**\n\t * Verifies that the public key is associated with the provided address\n\t */\n\toverride verifyAddress(address: string): boolean {\n\t\treturn address === super.toSuiAddress() || address === this.#toLegacyAddress();\n\t}\n}\n\n// Derive the public identifier for zklogin based on address seed and iss.\nexport function toZkLoginPublicIdentifier(\n\taddressSeed: bigint,\n\tiss: string,\n\toptions?: { client?: ZkLoginCompatibleClient; legacyAddress?: boolean },\n): ZkLoginPublicIdentifier {\n\t// Consists of iss_bytes_len || iss_bytes || padded_32_byte_address_seed.\n\tconst addressSeedBytesBigEndian = options?.legacyAddress\n\t\t? toBigEndianBytes(addressSeed, 32)\n\t\t: toPaddedBigEndianBytes(addressSeed, 32);\n\n\tconst issBytes = new TextEncoder().encode(normalizeZkLoginIssuer(iss));\n\tconst tmp = new Uint8Array(1 + issBytes.length + addressSeedBytesBigEndian.length);\n\ttmp.set([issBytes.length], 0);\n\ttmp.set(issBytes, 1);\n\ttmp.set(addressSeedBytesBigEndian, 1 + issBytes.length);\n\treturn new ZkLoginPublicIdentifier(tmp, options);\n}\n\nfunction normalizeZkLoginPublicKeyBytes(bytes: Uint8Array, legacyAddress = false) {\n\tconst issByteLength = bytes[0] + 1;\n\tconst addressSeed = BigInt(`0x${toHex(bytes.slice(issByteLength))}`);\n\tconst seedBytes = legacyAddress\n\t\t? toBigEndianBytes(addressSeed, 32)\n\t\t: toPaddedBigEndianBytes(addressSeed, 32);\n\tconst data = new Uint8Array(issByteLength + seedBytes.length);\n\tdata.set(bytes.slice(0, issByteLength), 0);\n\tdata.set(seedBytes, issByteLength);\n\treturn data;\n}\n\nasync function graphqlVerifyZkLoginSignature({\n\taddress,\n\tbytes,\n\tsignature,\n\tintentScope,\n\tclient = new SuiGraphQLClient({\n\t\turl: 'https://sui-mainnet.mystenlabs.com/graphql',\n\t}),\n}: {\n\taddress: string;\n\tbytes: string;\n\tsignature: string;\n\tintentScope: 'PersonalMessage' | 'TransactionData';\n\tclient?: ZkLoginCompatibleClient;\n}) {\n\tconst resp = await client.core.verifyZkLoginSignature({\n\t\tbytes,\n\t\tsignature,\n\t\tintentScope,\n\t\tauthor: address,\n\t});\n\n\treturn resp.success === true && resp.errors.length === 0;\n}\n\nexport function parseSerializedZkLoginSignature(signature: Uint8Array | string) {\n\tconst bytes = typeof signature === 'string' ? fromBase64(signature) : signature;\n\n\tif (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.ZkLogin) {\n\t\tthrow new Error('Invalid signature scheme');\n\t}\n\n\tconst signatureBytes = bytes.slice(1);\n\tconst { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);\n\tconst { issBase64Details, addressSeed } = inputs;\n\tconst iss = extractClaimValue<string>(issBase64Details, 'iss');\n\tconst publicIdentifer = toZkLoginPublicIdentifier(BigInt(addressSeed), iss);\n\treturn {\n\t\tserializedSignature: toBase64(bytes),\n\t\tsignatureScheme: 'ZkLogin' as const,\n\t\tzkLogin: {\n\t\t\tinputs,\n\t\t\tmaxEpoch,\n\t\t\tuserSignature,\n\t\t\tiss,\n\t\t\taddressSeed: BigInt(addressSeed),\n\t\t},\n\t\tsignature: bytes,\n\t\tpublicKey: publicIdentifer.toRawBytes(),\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This is adapted from https://github.com/alepop/ed25519-hd-key replacing create-hmac\n// with @noble/hashes to be browser compatible.\n\nimport { fromHex } from '@mysten/bcs';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\n\ntype Hex = string;\ntype Path = string;\n\ntype Keys = {\n\tkey: Uint8Array;\n\tchainCode: Uint8Array;\n};\n\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\n\nconst pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\n\nconst replaceDerive = (val: string): string => val.replace(\"'\", '');\n\nconst getMasterKeyFromSeed = (seed: Hex): Keys => {\n\tconst h = hmac.create(sha512, ED25519_CURVE);\n\tconst I = h.update(fromHex(seed)).digest();\n\tconst IL = I.slice(0, 32);\n\tconst IR = I.slice(32);\n\treturn {\n\t\tkey: IL,\n\t\tchainCode: IR,\n\t};\n};\n\nconst CKDPriv = ({ key, chainCode }: Keys, index: number): Keys => {\n\tconst indexBuffer = new ArrayBuffer(4);\n\tconst cv = new DataView(indexBuffer);\n\tcv.setUint32(0, index);\n\n\tconst data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n\tdata.set(new Uint8Array(1).fill(0));\n\tdata.set(key, 1);\n\tdata.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);\n\n\tconst I = hmac.create(sha512, chainCode).update(data).digest();\n\tconst IL = I.slice(0, 32);\n\tconst IR = I.slice(32);\n\treturn {\n\t\tkey: IL,\n\t\tchainCode: IR,\n\t};\n};\n\nconst isValidPath = (path: string): boolean => {\n\tif (!pathRegex.test(path)) {\n\t\treturn false;\n\t}\n\treturn !path\n\t\t.split('/')\n\t\t.slice(1)\n\t\t.map(replaceDerive)\n\t\t.some(isNaN as any /* ts T_T*/);\n};\n\nexport const derivePath = (path: Path, seed: Hex, offset = HARDENED_OFFSET): Keys => {\n\tif (!isValidPath(path)) {\n\t\tthrow new Error('Invalid derivation path');\n\t}\n\n\tconst { key, chainCode } = getMasterKeyFromSeed(seed);\n\tconst segments = path\n\t\t.split('/')\n\t\t.slice(1)\n\t\t.map(replaceDerive)\n\t\t.map((el) => parseInt(el, 10));\n\n\treturn segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n\t\tkey,\n\t\tchainCode,\n\t});\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nimport {\n\tbytesEqual,\n\tparseSerializedKeypairSignature,\n\tPublicKey,\n} from '../../cryptography/publickey.js';\nimport type { PublicKeyInitData } from '../../cryptography/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from '../../cryptography/signature-scheme.js';\n\nconst PUBLIC_KEY_SIZE = 32;\n\n/**\n * An Ed25519 public key\n */\nexport class Ed25519PublicKey extends PublicKey {\n\tstatic SIZE = PUBLIC_KEY_SIZE;\n\tprivate data: Uint8Array;\n\n\t/**\n\t * Create a new Ed25519PublicKey object\n\t * @param value ed25519 public key as buffer or base-64 encoded string\n\t */\n\tconstructor(value: PublicKeyInitData) {\n\t\tsuper();\n\n\t\tif (typeof value === 'string') {\n\t\t\tthis.data = fromBase64(value);\n\t\t} else if (value instanceof Uint8Array) {\n\t\t\tthis.data = value;\n\t\t} else {\n\t\t\tthis.data = Uint8Array.from(value);\n\t\t}\n\n\t\tif (this.data.length !== PUBLIC_KEY_SIZE) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if two Ed25519 public keys are equal\n\t */\n\toverride equals(publicKey: Ed25519PublicKey): boolean {\n\t\treturn super.equals(publicKey);\n\t}\n\n\t/**\n\t * Return the byte array representation of the Ed25519 public key\n\t */\n\ttoRawBytes(): Uint8Array {\n\t\treturn this.data;\n\t}\n\n\t/**\n\t * Return the Sui address associated with this Ed25519 public key\n\t */\n\tflag(): number {\n\t\treturn SIGNATURE_SCHEME_TO_FLAG['ED25519'];\n\t}\n\n\t/**\n\t * Verifies that the signature is valid for for the provided message\n\t */\n\tasync verify(message: Uint8Array, signature: Uint8Array | string): Promise<boolean> {\n\t\tlet bytes;\n\t\tif (typeof signature === 'string') {\n\t\t\tconst parsed = parseSerializedKeypairSignature(signature);\n\t\t\tif (parsed.signatureScheme !== 'ED25519') {\n\t\t\t\tthrow new Error('Invalid signature scheme');\n\t\t\t}\n\n\t\t\tif (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {\n\t\t\t\tthrow new Error('Signature does not match public key');\n\t\t\t}\n\n\t\t\tbytes = parsed.signature;\n\t\t} else {\n\t\t\tbytes = signature;\n\t\t}\n\n\t\treturn ed25519.verify(bytes, message, this.toRawBytes());\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature } from './data/internal.js';\nimport type { TransactionPlugin } from './resolve.js';\n\nexport interface ObjectCacheEntry {\n\tobjectId: string;\n\tversion: string;\n\tdigest: string;\n\towner: string | null;\n\tinitialSharedVersion: string | null;\n}\n\nexport interface MoveFunctionCacheEntry {\n\tpackage: string;\n\tmodule: string;\n\tfunction: string;\n\tparameters: OpenMoveTypeSignature[];\n}\n\nexport interface CacheEntryTypes {\n\tOwnedObject: ObjectCacheEntry;\n\tSharedOrImmutableObject: ObjectCacheEntry;\n\tMoveFunction: MoveFunctionCacheEntry;\n\tCustom: unknown;\n}\nexport abstract class AsyncCache {\n\tprotected abstract get<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t): Promise<CacheEntryTypes[T] | null>;\n\tprotected abstract set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t): Promise<void>;\n\tprotected abstract delete<T extends keyof CacheEntryTypes>(type: T, key: string): Promise<void>;\n\tabstract clear<T extends keyof CacheEntryTypes>(type?: T): Promise<void>;\n\n\tasync getObject(id: string) {\n\t\tconst [owned, shared] = await Promise.all([\n\t\t\tthis.get('OwnedObject', id),\n\t\t\tthis.get('SharedOrImmutableObject', id),\n\t\t]);\n\n\t\treturn owned ?? shared ?? null;\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn Promise.all([...ids.map((id) => this.getObject(id))]);\n\t}\n\n\tasync addObject(object: ObjectCacheEntry) {\n\t\tif (object.owner) {\n\t\t\tawait this.set('OwnedObject', object.objectId, object);\n\t\t} else {\n\t\t\tawait this.set('SharedOrImmutableObject', object.objectId, object);\n\t\t}\n\n\t\treturn object;\n\t}\n\n\tasync addObjects(objects: ObjectCacheEntry[]) {\n\t\tawait Promise.all(objects.map(async (object) => this.addObject(object)));\n\t}\n\n\tasync deleteObject(id: string) {\n\t\tawait Promise.all([this.delete('OwnedObject', id), this.delete('SharedOrImmutableObject', id)]);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\tawait Promise.all(ids.map((id) => this.deleteObject(id)));\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\treturn this.get('MoveFunction', functionName);\n\t}\n\n\tasync addMoveFunctionDefinition(functionEntry: MoveFunctionCacheEntry) {\n\t\tconst pkg = normalizeSuiAddress(functionEntry.package);\n\t\tconst functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n\t\tconst entry = {\n\t\t\t...functionEntry,\n\t\t\tpackage: pkg,\n\t\t};\n\n\t\tawait this.set('MoveFunction', functionName, entry);\n\n\t\treturn entry;\n\t}\n\n\tasync deleteMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\tconst functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n\t\tawait this.delete('MoveFunction', functionName);\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.get('Custom', key) as Promise<T | null>;\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.set('Custom', key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.delete('Custom', key);\n\t}\n}\n\nexport class InMemoryCache extends AsyncCache {\n\t#caches = {\n\t\tOwnedObject: new Map<string, ObjectCacheEntry>(),\n\t\tSharedOrImmutableObject: new Map<string, ObjectCacheEntry>(),\n\t\tMoveFunction: new Map<string, MoveFunctionCacheEntry>(),\n\t\tCustom: new Map<string, unknown>(),\n\t};\n\n\tprotected async get<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\treturn (this.#caches[type].get(key) as CacheEntryTypes[T]) ?? null;\n\t}\n\n\tprotected async set<T extends keyof CacheEntryTypes>(\n\t\ttype: T,\n\t\tkey: string,\n\t\tvalue: CacheEntryTypes[T],\n\t) {\n\t\t(this.#caches[type] as Map<string, typeof value>).set(key, value as never);\n\t}\n\n\tprotected async delete<T extends keyof CacheEntryTypes>(type: T, key: string) {\n\t\tthis.#caches[type].delete(key);\n\t}\n\n\tasync clear<T extends keyof CacheEntryTypes>(type?: T) {\n\t\tif (type) {\n\t\t\tthis.#caches[type].clear();\n\t\t} else {\n\t\t\tfor (const cache of Object.values(this.#caches)) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface ObjectCacheOptions {\n\tcache?: AsyncCache;\n\tonEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n}\n\nexport class ObjectCache {\n\t#cache: AsyncCache;\n\t#onEffects?: (effects: typeof bcs.TransactionEffects.$inferType) => Promise<void>;\n\n\tconstructor({ cache = new InMemoryCache(), onEffects }: ObjectCacheOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#onEffects = onEffects;\n\t}\n\n\tasPlugin(): TransactionPlugin {\n\t\treturn async (transactionData, _options, next) => {\n\t\t\tconst unresolvedObjects = transactionData.inputs\n\t\t\t\t.filter((input) => input.UnresolvedObject)\n\t\t\t\t.map((input) => input.UnresolvedObject!.objectId);\n\n\t\t\tconst cached = (await this.#cache.getObjects(unresolvedObjects)).filter(\n\t\t\t\t(obj) => obj !== null,\n\t\t\t);\n\n\t\t\tconst byId = new Map(cached.map((obj) => [obj!.objectId, obj]));\n\n\t\t\tfor (const input of transactionData.inputs) {\n\t\t\t\tif (!input.UnresolvedObject) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst cached = byId.get(input.UnresolvedObject.objectId);\n\n\t\t\t\tif (!cached) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cached.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion = cached.initialSharedVersion;\n\t\t\t\t} else {\n\t\t\t\t\tif (cached.version && !input.UnresolvedObject.version) {\n\t\t\t\t\t\tinput.UnresolvedObject.version = cached.version;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cached.digest && !input.UnresolvedObject.digest) {\n\t\t\t\t\t\tinput.UnresolvedObject.digest = cached.digest;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall) {\n\t\t\t\t\t\tconst def = await this.getMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (def) {\n\t\t\t\t\t\t\tcommands.MoveCall._argumentTypes = def.parameters;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tawait next();\n\n\t\t\tawait Promise.all(\n\t\t\t\ttransactionData.commands.map(async (commands) => {\n\t\t\t\t\tif (commands.MoveCall?._argumentTypes) {\n\t\t\t\t\t\tawait this.#cache.addMoveFunctionDefinition({\n\t\t\t\t\t\t\tpackage: commands.MoveCall.package,\n\t\t\t\t\t\t\tmodule: commands.MoveCall.module,\n\t\t\t\t\t\t\tfunction: commands.MoveCall.function,\n\t\t\t\t\t\t\tparameters: commands.MoveCall._argumentTypes,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\tasync clear() {\n\t\tawait this.#cache.clear();\n\t}\n\n\tasync getMoveFunctionDefinition(ref: { package: string; module: string; function: string }) {\n\t\treturn this.#cache.getMoveFunctionDefinition(ref);\n\t}\n\n\tasync getObjects(ids: string[]) {\n\t\treturn this.#cache.getObjects(ids);\n\t}\n\n\tasync deleteObjects(ids: string[]) {\n\t\treturn this.#cache.deleteObjects(ids);\n\t}\n\n\tasync clearOwnedObjects() {\n\t\tawait this.#cache.clear('OwnedObject');\n\t}\n\n\tasync clearCustom() {\n\t\tawait this.#cache.clear('Custom');\n\t}\n\n\tasync getCustom<T>(key: string) {\n\t\treturn this.#cache.getCustom<T>(key);\n\t}\n\n\tasync setCustom<T>(key: string, value: T) {\n\t\treturn this.#cache.setCustom(key, value);\n\t}\n\n\tasync deleteCustom(key: string) {\n\t\treturn this.#cache.deleteCustom(key);\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tif (!effects.V2) {\n\t\t\tthrow new Error(`Unsupported transaction effects version ${effects.$kind}`);\n\t\t}\n\n\t\tconst { lamportVersion, changedObjects } = effects.V2;\n\n\t\tconst deletedIds: string[] = [];\n\t\tconst addedObjects: ObjectCacheEntry[] = [];\n\n\t\tchangedObjects.forEach(([id, change]) => {\n\t\t\tif (change.outputState.NotExist) {\n\t\t\t\tdeletedIds.push(id);\n\t\t\t} else if (change.outputState.ObjectWrite) {\n\t\t\t\tconst [digest, owner] = change.outputState.ObjectWrite;\n\n\t\t\t\taddedObjects.push({\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion: lamportVersion,\n\t\t\t\t\towner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n\t\t\t\t\tinitialSharedVersion: owner.Shared?.initialSharedVersion ?? null,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all([\n\t\t\tthis.#cache.addObjects(addedObjects),\n\t\t\tthis.#cache.deleteObjects(deletedIds),\n\t\t\tthis.#onEffects?.(effects),\n\t\t]);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '../../bcs/index.js';\nimport type { ExecuteTransactionBlockParams, SuiClient } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { ObjectCache } from '../ObjectCache.js';\nimport type { Transaction } from '../Transaction.js';\nimport { isTransaction } from '../Transaction.js';\n\nexport class CachingTransactionExecutor {\n\t#client: SuiClient;\n\t#lastDigest: string | null = null;\n\tcache: ObjectCache;\n\n\tconstructor({\n\t\tclient,\n\t\t...options\n\t}: ObjectCacheOptions & {\n\t\tclient: SuiClient;\n\t}) {\n\t\tthis.#client = client;\n\t\tthis.cache = new ObjectCache(options);\n\t}\n\n\t/**\n\t * Clears all Owned objects\n\t * Immutable objects, Shared objects, and Move function definitions will be preserved\n\t */\n\tasync reset() {\n\t\tawait Promise.all([\n\t\t\tthis.cache.clearOwnedObjects(),\n\t\t\tthis.cache.clearCustom(),\n\t\t\tthis.waitForLastTransaction(),\n\t\t]);\n\t}\n\n\tasync buildTransaction({\n\t\ttransaction,\n\t\t...options\n\t}: { transaction: Transaction } & BuildTransactionOptions) {\n\t\ttransaction.addBuildPlugin(this.cache.asPlugin());\n\t\treturn transaction.build({\n\t\t\tclient: this.#client,\n\t\t\t...options,\n\t\t});\n\t}\n\n\tasync executeTransaction({\n\t\ttransaction,\n\t\toptions,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction | Uint8Array;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock'>) {\n\t\tconst bytes = isTransaction(transaction)\n\t\t\t? await this.buildTransaction({ transaction })\n\t\t\t: transaction;\n\n\t\tconst results = await this.#client.executeTransactionBlock({\n\t\t\t...input,\n\t\t\ttransactionBlock: bytes,\n\t\t\toptions: {\n\t\t\t\t...options,\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tif (results.rawEffects) {\n\t\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n\t\t\tawait this.applyEffects(effects);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tasync signAndExecuteTransaction({\n\t\toptions,\n\t\ttransaction,\n\t\t...input\n\t}: {\n\t\ttransaction: Transaction;\n\n\t\tsigner: Signer;\n\t} & Omit<ExecuteTransactionBlockParams, 'transactionBlock' | 'signature'>) {\n\t\ttransaction.setSenderIfNotSet(input.signer.toSuiAddress());\n\t\tconst bytes = await this.buildTransaction({ transaction });\n\t\tconst { signature } = await input.signer.signTransaction(bytes);\n\t\tconst results = await this.executeTransaction({\n\t\t\ttransaction: bytes,\n\t\t\tsignature,\n\t\t\toptions,\n\t\t});\n\n\t\treturn results;\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\tthis.#lastDigest = effects.V2?.transactionDigest ?? null;\n\t\tawait this.cache.applyEffects(effects);\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tif (this.#lastDigest) {\n\t\t\tawait this.#client.waitForTransaction({ digest: this.#lastDigest });\n\t\t\tthis.#lastDigest = null;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class SerialQueue {\n\t#queue: Array<() => void> = [];\n\n\tasync runTask<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.#queue.push(() => {\n\t\t\t\ttask()\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tthis.#queue.shift();\n\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\tthis.#queue[0]();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve, reject);\n\t\t\t});\n\n\t\t\tif (this.#queue.length === 1) {\n\t\t\t\tthis.#queue[0]();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class ParallelQueue {\n\t#queue: Array<() => void> = [];\n\tactiveTasks = 0;\n\tmaxTasks: number;\n\n\tconstructor(maxTasks: number) {\n\t\tthis.maxTasks = maxTasks;\n\t}\n\n\trunTask<T>(task: () => Promise<T>): Promise<T> {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\tif (this.activeTasks < this.maxTasks) {\n\t\t\t\tthis.activeTasks++;\n\n\t\t\t\ttask()\n\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\tthis.#queue.shift()!();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.activeTasks--;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(resolve, reject);\n\t\t\t} else {\n\t\t\t\tthis.#queue.push(() => {\n\t\t\t\t\ttask()\n\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\tif (this.#queue.length > 0) {\n\t\t\t\t\t\t\t\tthis.#queue.shift()!();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.activeTasks--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(resolve, reject);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\n\nimport type { bcs } from '../../bcs/index.js';\nimport type { SuiClient, SuiTransactionBlockResponseOptions } from '../../client/index.js';\nimport type { Signer } from '../../cryptography/keypair.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { isTransaction, Transaction } from '../Transaction.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { SerialQueue } from './queue.js';\n\nexport class SerialTransactionExecutor {\n\t#queue = new SerialQueue();\n\t#signer: Signer;\n\t#cache: CachingTransactionExecutor;\n\t#defaultGasBudget: bigint;\n\n\tconstructor({\n\t\tsigner,\n\t\tdefaultGasBudget = 50_000_000n,\n\t\t...options\n\t}: Omit<ObjectCacheOptions, 'address'> & {\n\t\tclient: SuiClient;\n\t\tsigner: Signer;\n\t\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `50_000_000n` */\n\t\tdefaultGasBudget?: bigint;\n\t}) {\n\t\tthis.#signer = signer;\n\t\tthis.#defaultGasBudget = defaultGasBudget;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t\tonEffects: (effects) => this.#cacheGasCoin(effects),\n\t\t});\n\t}\n\n\tasync applyEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\t\treturn this.#cache.applyEffects(effects);\n\t}\n\n\t#cacheGasCoin = async (effects: typeof bcs.TransactionEffects.$inferType) => {\n\t\tif (!effects.V2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasCoin = getGasCoinFromEffects(effects).ref;\n\t\tif (gasCoin) {\n\t\t\tthis.#cache.cache.setCustom('gasCoin', gasCoin);\n\t\t} else {\n\t\t\tthis.#cache.cache.deleteCustom('gasCoin');\n\t\t}\n\t};\n\n\tasync buildTransaction(transaction: Transaction) {\n\t\treturn this.#queue.runTask(() => this.#buildTransaction(transaction));\n\t}\n\n\t#buildTransaction = async (transaction: Transaction) => {\n\t\tconst gasCoin = await this.#cache.cache.getCustom<{\n\t\t\tobjectId: string;\n\t\t\tversion: string;\n\t\t\tdigest: string;\n\t\t}>('gasCoin');\n\n\t\tconst copy = Transaction.from(transaction);\n\t\tif (gasCoin) {\n\t\t\tcopy.setGasPayment([gasCoin]);\n\t\t}\n\n\t\tcopy.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\t\tcopy.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\treturn this.#cache.buildTransaction({ transaction: copy });\n\t};\n\n\tresetCache() {\n\t\treturn this.#cache.reset();\n\t}\n\n\twaitForLastTransaction() {\n\t\treturn this.#cache.waitForLastTransaction();\n\t}\n\n\texecuteTransaction(\n\t\ttransaction: Transaction | Uint8Array,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\treturn this.#queue.runTask(async () => {\n\t\t\tconst bytes = isTransaction(transaction)\n\t\t\t\t? await this.#buildTransaction(transaction)\n\t\t\t\t: transaction;\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\t\t\tconst results = await this.#cache\n\t\t\t\t.executeTransaction({\n\t\t\t\t\tsignature: [signature, ...additionalSignatures],\n\t\t\t\t\ttransaction: bytes,\n\t\t\t\t\toptions,\n\t\t\t\t})\n\t\t\t\t.catch(async (error) => {\n\t\t\t\t\tawait this.resetCache();\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t});\n\t}\n}\n\nexport function getGasCoinFromEffects(effects: typeof bcs.TransactionEffects.$inferType) {\n\tif (!effects.V2) {\n\t\tthrow new Error('Unexpected effects version');\n\t}\n\n\tconst gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex!];\n\n\tif (!gasObjectChange) {\n\t\tthrow new Error('Gas object not found in effects');\n\t}\n\n\tconst [objectId, { outputState }] = gasObjectChange;\n\n\tif (!outputState.ObjectWrite) {\n\t\tthrow new Error('Unexpected gas object state');\n\t}\n\n\tconst [digest, owner] = outputState.ObjectWrite;\n\n\treturn {\n\t\tref: {\n\t\t\tobjectId,\n\t\t\tdigest,\n\t\t\tversion: effects.V2.lamportVersion,\n\t\t},\n\t\towner: owner.AddressOwner || owner.ObjectOwner!,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport { promiseWithResolvers } from '@mysten/utils';\nimport { bcs } from '../../bcs/index.js';\nimport type { SuiObjectRef } from '../../bcs/types.js';\nimport type {\n\tSuiClient,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../../client/index.js';\nimport type { Signer } from '../../cryptography/index.js';\nimport type { ObjectCacheOptions } from '../ObjectCache.js';\nimport { Transaction } from '../Transaction.js';\nimport { TransactionDataBuilder } from '../TransactionData.js';\nimport { CachingTransactionExecutor } from './caching.js';\nimport { ParallelQueue, SerialQueue } from './queue.js';\nimport { getGasCoinFromEffects } from './serial.js';\n\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n\tcoinBatchSize: 20,\n\tinitialCoinBalance: 200_000_000n,\n\tminimumCoinBalance: 50_000_000n,\n\tmaxPoolSize: 50,\n\tepochBoundaryWindow: 1_000,\n} satisfies Omit<ParallelTransactionExecutorOptions, 'signer' | 'client'>;\nexport interface ParallelTransactionExecutorOptions extends Omit<ObjectCacheOptions, 'address'> {\n\tclient: SuiClient;\n\tsigner: Signer;\n\t/** The number of coins to create in a batch when refilling the gas pool */\n\tcoinBatchSize?: number;\n\t/** The initial balance of each coin created for the gas pool */\n\tinitialCoinBalance?: bigint;\n\t/** The minimum balance of a coin that can be reused for future transactions.  If the gasCoin is below this value, it will be used when refilling the gasPool */\n\tminimumCoinBalance?: bigint;\n\t/** The gasBudget to use if the transaction has not defined it's own gasBudget, defaults to `minimumCoinBalance` */\n\tdefaultGasBudget?: bigint;\n\t/**\n\t * Time to wait before/after the expected epoch boundary before re-fetching the gas pool (in milliseconds).\n\t * Building transactions will be paused for up to 2x this duration around each epoch boundary to ensure the\n\t * gas price is up-to-date for the next epoch.\n\t * */\n\tepochBoundaryWindow?: number;\n\t/** The maximum number of transactions that can be execute in parallel, this also determines the maximum number of gas coins that will be created */\n\tmaxPoolSize?: number;\n\t/** An initial list of coins used to fund the gas pool, uses all owned SUI coins by default */\n\tsourceCoins?: string[];\n}\n\ninterface CoinWithBalance {\n\tid: string;\n\tversion: string;\n\tdigest: string;\n\tbalance: bigint;\n}\nexport class ParallelTransactionExecutor {\n\t#signer: Signer;\n\t#client: SuiClient;\n\t#coinBatchSize: number;\n\t#initialCoinBalance: bigint;\n\t#minimumCoinBalance: bigint;\n\t#epochBoundaryWindow: number;\n\t#defaultGasBudget: bigint;\n\t#maxPoolSize: number;\n\t#sourceCoins: Map<string, SuiObjectRef | null> | null;\n\t#coinPool: CoinWithBalance[] = [];\n\t#cache: CachingTransactionExecutor;\n\t#objectIdQueues = new Map<string, (() => void)[]>();\n\t#buildQueue = new SerialQueue();\n\t#executeQueue: ParallelQueue;\n\t#lastDigest: string | null = null;\n\t#cacheLock: Promise<void> | null = null;\n\t#pendingTransactions = 0;\n\t#gasPrice: null | {\n\t\tprice: bigint;\n\t\texpiration: number;\n\t} = null;\n\n\tconstructor(options: ParallelTransactionExecutorOptions) {\n\t\tthis.#signer = options.signer;\n\t\tthis.#client = options.client;\n\t\tthis.#coinBatchSize = options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize;\n\t\tthis.#initialCoinBalance =\n\t\t\toptions.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance;\n\t\tthis.#minimumCoinBalance =\n\t\t\toptions.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance;\n\t\tthis.#defaultGasBudget = options.defaultGasBudget ?? this.#minimumCoinBalance;\n\t\tthis.#epochBoundaryWindow =\n\t\t\toptions.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow;\n\t\tthis.#maxPoolSize = options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize;\n\t\tthis.#cache = new CachingTransactionExecutor({\n\t\t\tclient: options.client,\n\t\t\tcache: options.cache,\n\t\t});\n\t\tthis.#executeQueue = new ParallelQueue(this.#maxPoolSize);\n\t\tthis.#sourceCoins = options.sourceCoins\n\t\t\t? new Map(options.sourceCoins.map((id) => [id, null]))\n\t\t\t: null;\n\t}\n\n\tresetCache() {\n\t\tthis.#gasPrice = null;\n\t\treturn this.#updateCache(() => this.#cache.reset());\n\t}\n\n\tasync waitForLastTransaction() {\n\t\tawait this.#updateCache(() => this.#waitForLastDigest());\n\t}\n\n\tasync executeTransaction(\n\t\ttransaction: Transaction,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\tconst { promise, resolve, reject } = promiseWithResolvers<{\n\t\t\tdigest: string;\n\t\t\teffects: string;\n\t\t\tdata: SuiTransactionBlockResponse;\n\t\t}>();\n\t\tconst usedObjects = await this.#getUsedObjects(transaction);\n\n\t\tconst execute = () => {\n\t\t\tthis.#executeQueue.runTask(() => {\n\t\t\t\tconst promise = this.#execute(transaction, usedObjects, options, additionalSignatures);\n\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t});\n\t\t};\n\n\t\tconst conflicts = new Set<string>();\n\n\t\tusedObjects.forEach((objectId) => {\n\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\tif (queue) {\n\t\t\t\tconflicts.add(objectId);\n\t\t\t\tthis.#objectIdQueues.get(objectId)!.push(() => {\n\t\t\t\t\tconflicts.delete(objectId);\n\t\t\t\t\tif (conflicts.size === 0) {\n\t\t\t\t\t\texecute();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.#objectIdQueues.set(objectId, []);\n\t\t\t}\n\t\t});\n\n\t\tif (conflicts.size === 0) {\n\t\t\texecute();\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tasync #getUsedObjects(transaction: Transaction) {\n\t\tconst usedObjects = new Set<string>();\n\t\tlet serialized = false;\n\n\t\ttransaction.addSerializationPlugin(async (blockData, _options, next) => {\n\t\t\tawait next();\n\n\t\t\tif (serialized) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tserialized = true;\n\n\t\t\tblockData.inputs.forEach((input) => {\n\t\t\t\tif (input.Object?.ImmOrOwnedObject?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t\t\t} else if (input.Object?.Receiving?.objectId) {\n\t\t\t\t\tusedObjects.add(input.Object.Receiving.objectId);\n\t\t\t\t} else if (\n\t\t\t\t\tinput.UnresolvedObject?.objectId &&\n\t\t\t\t\t!input.UnresolvedObject.initialSharedVersion\n\t\t\t\t) {\n\t\t\t\t\tusedObjects.add(input.UnresolvedObject.objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tawait transaction.prepareForSerialization({ client: this.#client });\n\n\t\treturn usedObjects;\n\t}\n\n\tasync #execute(\n\t\ttransaction: Transaction,\n\t\tusedObjects: Set<string>,\n\t\toptions?: SuiTransactionBlockResponseOptions,\n\t\tadditionalSignatures: string[] = [],\n\t) {\n\t\tlet gasCoin!: CoinWithBalance;\n\t\ttry {\n\t\t\ttransaction.setSenderIfNotSet(this.#signer.toSuiAddress());\n\n\t\t\tawait this.#buildQueue.runTask(async () => {\n\t\t\t\tconst data = transaction.getData();\n\n\t\t\t\tif (!data.gasData.price) {\n\t\t\t\t\ttransaction.setGasPrice(await this.#getGasPrice());\n\t\t\t\t}\n\n\t\t\t\ttransaction.setGasBudgetIfNotSet(this.#defaultGasBudget);\n\n\t\t\t\tawait this.#updateCache();\n\t\t\t\tgasCoin = await this.#getGasCoin();\n\t\t\t\tthis.#pendingTransactions++;\n\t\t\t\ttransaction.setGasPayment([\n\t\t\t\t\t{\n\t\t\t\t\t\tobjectId: gasCoin.id,\n\t\t\t\t\t\tversion: gasCoin.version,\n\t\t\t\t\t\tdigest: gasCoin.digest,\n\t\t\t\t\t},\n\t\t\t\t]);\n\n\t\t\t\t// Resolve cached references\n\t\t\t\tawait this.#cache.buildTransaction({ transaction, onlyTransactionKind: true });\n\t\t\t});\n\n\t\t\tconst bytes = await transaction.build({ client: this.#client });\n\n\t\t\tconst { signature } = await this.#signer.signTransaction(bytes);\n\n\t\t\tconst results = await this.#cache.executeTransaction({\n\t\t\t\ttransaction: bytes,\n\t\t\t\tsignature: [signature, ...additionalSignatures],\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tshowEffects: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst effectsBytes = Uint8Array.from(results.rawEffects!);\n\t\t\tconst effects = bcs.TransactionEffects.parse(effectsBytes);\n\n\t\t\tconst gasResult = getGasCoinFromEffects(effects);\n\t\t\tconst gasUsed = effects.V2?.gasUsed;\n\n\t\t\tif (gasCoin && gasUsed && gasResult.owner === this.#signer.toSuiAddress()) {\n\t\t\t\tconst totalUsed =\n\t\t\t\t\tBigInt(gasUsed.computationCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) +\n\t\t\t\t\tBigInt(gasUsed.storageCost) -\n\t\t\t\t\tBigInt(gasUsed.storageRebate);\n\n\t\t\t\tlet usesGasCoin = false;\n\t\t\t\tnew TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {\n\t\t\t\t\tif (arg.$kind === 'GasCoin') {\n\t\t\t\t\t\tusesGasCoin = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arg;\n\t\t\t\t});\n\n\t\t\t\tif (!usesGasCoin && gasCoin.balance >= this.#minimumCoinBalance) {\n\t\t\t\t\tthis.#coinPool.push({\n\t\t\t\t\t\tid: gasResult.ref.objectId,\n\t\t\t\t\t\tversion: gasResult.ref.version,\n\t\t\t\t\t\tdigest: gasResult.ref.digest,\n\t\t\t\t\t\tbalance: gasCoin.balance - totalUsed,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t\t}\n\t\t\t\t\tthis.#sourceCoins.set(gasResult.ref.objectId, gasResult.ref);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.#lastDigest = results.digest;\n\n\t\t\treturn {\n\t\t\t\tdigest: results.digest,\n\t\t\t\teffects: toBase64(effectsBytes),\n\t\t\t\tdata: results,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (gasCoin) {\n\t\t\t\tif (!this.#sourceCoins) {\n\t\t\t\t\tthis.#sourceCoins = new Map();\n\t\t\t\t}\n\n\t\t\t\tthis.#sourceCoins.set(gasCoin.id, null);\n\t\t\t}\n\n\t\t\tawait this.#updateCache(async () => {\n\t\t\t\tawait Promise.all([\n\t\t\t\t\tthis.#cache.cache.deleteObjects([...usedObjects]),\n\t\t\t\t\tthis.#waitForLastDigest(),\n\t\t\t\t]);\n\t\t\t});\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tusedObjects.forEach((objectId) => {\n\t\t\t\tconst queue = this.#objectIdQueues.get(objectId);\n\t\t\t\tif (queue && queue.length > 0) {\n\t\t\t\t\tqueue.shift()!();\n\t\t\t\t} else if (queue) {\n\t\t\t\t\tthis.#objectIdQueues.delete(objectId);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.#pendingTransactions--;\n\t\t}\n\t}\n\n\t/** Helper for synchronizing cache updates, by ensuring only one update happens at a time.  This can also be used to wait for any pending cache updates  */\n\tasync #updateCache(fn?: () => Promise<void>) {\n\t\tif (this.#cacheLock) {\n\t\t\tawait this.#cacheLock;\n\t\t}\n\n\t\tthis.#cacheLock =\n\t\t\tfn?.().then(\n\t\t\t\t() => {\n\t\t\t\t\tthis.#cacheLock = null;\n\t\t\t\t},\n\t\t\t\t() => {},\n\t\t\t) ?? null;\n\t}\n\n\tasync #waitForLastDigest() {\n\t\tconst digest = this.#lastDigest;\n\t\tif (digest) {\n\t\t\tthis.#lastDigest = null;\n\t\t\tawait this.#client.waitForTransaction({ digest });\n\t\t}\n\t}\n\n\tasync #getGasCoin() {\n\t\tif (this.#coinPool.length === 0 && this.#pendingTransactions <= this.#maxPoolSize) {\n\t\t\tawait this.#refillCoinPool();\n\t\t}\n\n\t\tif (this.#coinPool.length === 0) {\n\t\t\tthrow new Error('No coins available');\n\t\t}\n\n\t\tconst coin = this.#coinPool.shift()!;\n\t\treturn coin;\n\t}\n\n\tasync #getGasPrice(): Promise<bigint> {\n\t\tconst remaining = this.#gasPrice\n\t\t\t? this.#gasPrice.expiration - this.#epochBoundaryWindow - Date.now()\n\t\t\t: 0;\n\n\t\tif (remaining > 0) {\n\t\t\treturn this.#gasPrice!.price;\n\t\t}\n\n\t\tif (this.#gasPrice) {\n\t\t\tconst timeToNextEpoch = Math.max(\n\t\t\t\tthis.#gasPrice.expiration + this.#epochBoundaryWindow - Date.now(),\n\t\t\t\t1_000,\n\t\t\t);\n\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));\n\t\t}\n\n\t\tconst state = await this.#client.getLatestSuiSystemState();\n\n\t\tthis.#gasPrice = {\n\t\t\tprice: BigInt(state.referenceGasPrice),\n\t\t\texpiration:\n\t\t\t\tNumber.parseInt(state.epochStartTimestampMs, 10) +\n\t\t\t\tNumber.parseInt(state.epochDurationMs, 10),\n\t\t};\n\n\t\treturn this.#getGasPrice();\n\t}\n\n\tasync #refillCoinPool() {\n\t\tconst batchSize = Math.min(\n\t\t\tthis.#coinBatchSize,\n\t\t\tthis.#maxPoolSize - (this.#coinPool.length + this.#pendingTransactions) + 1,\n\t\t);\n\n\t\tif (batchSize === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst txb = new Transaction();\n\t\tconst address = this.#signer.toSuiAddress();\n\t\ttxb.setSender(address);\n\n\t\tif (this.#sourceCoins) {\n\t\t\tconst refs = [];\n\t\t\tconst ids = [];\n\t\t\tfor (const [id, ref] of this.#sourceCoins) {\n\t\t\t\tif (ref) {\n\t\t\t\t\trefs.push(ref);\n\t\t\t\t} else {\n\t\t\t\t\tids.push(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ids.length > 0) {\n\t\t\t\tconst coins = await this.#client.multiGetObjects({\n\t\t\t\t\tids,\n\t\t\t\t});\n\t\t\t\trefs.push(\n\t\t\t\t\t...coins\n\t\t\t\t\t\t.filter((coin): coin is typeof coin & { data: object } => coin.data !== null)\n\t\t\t\t\t\t.map(({ data }) => ({\n\t\t\t\t\t\t\tobjectId: data.objectId,\n\t\t\t\t\t\t\tversion: data.version,\n\t\t\t\t\t\t\tdigest: data.digest,\n\t\t\t\t\t\t})),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttxb.setGasPayment(refs);\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst amounts = new Array(batchSize).fill(this.#initialCoinBalance);\n\t\tconst results = txb.splitCoins(txb.gas, amounts);\n\t\tconst coinResults = [];\n\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\tcoinResults.push(results[i]);\n\t\t}\n\t\ttxb.transferObjects(coinResults, address);\n\n\t\tawait this.waitForLastTransaction();\n\n\t\tconst result = await this.#client.signAndExecuteTransaction({\n\t\t\ttransaction: txb,\n\t\t\tsigner: this.#signer,\n\t\t\toptions: {\n\t\t\t\tshowRawEffects: true,\n\t\t\t},\n\t\t});\n\n\t\tconst effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects!));\n\t\teffects.V2?.changedObjects.forEach(([id, { outputState }], i) => {\n\t\t\tif (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.#coinPool.push({\n\t\t\t\tid,\n\t\t\t\tversion: effects.V2!.lamportVersion,\n\t\t\t\tdigest: outputState.ObjectWrite[0],\n\t\t\t\tbalance: BigInt(this.#initialCoinBalance),\n\t\t\t});\n\t\t});\n\n\t\tif (!this.#sourceCoins) {\n\t\t\tthis.#sourceCoins = new Map();\n\t\t}\n\n\t\tconst gasObject = getGasCoinFromEffects(effects).ref;\n\t\tthis.#sourceCoins!.set(gasObject.objectId, gasObject);\n\n\t\tawait this.#client.waitForTransaction({ digest: result.digest });\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferInput } from 'valibot';\nimport { bigint, object, parse, string } from 'valibot';\n\nimport { bcs } from '../../bcs/index.js';\nimport type { CoinStruct, SuiClient } from '../../client/index.js';\nimport { normalizeStructTag } from '../../utils/sui-types.js';\nimport { Commands } from '../Commands.js';\nimport type { Argument } from '../data/internal.js';\nimport { Inputs } from '../Inputs.js';\nimport { getClient } from '../resolve.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { Transaction, TransactionResult } from '../Transaction.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\n\nconst COIN_WITH_BALANCE = 'CoinWithBalance';\nconst SUI_TYPE = normalizeStructTag('0x2::sui::SUI');\n\nexport function coinWithBalance({\n\ttype = SUI_TYPE,\n\tbalance,\n\tuseGasCoin = true,\n}: {\n\tbalance: bigint | number;\n\ttype?: string;\n\tuseGasCoin?: boolean;\n}): (tx: Transaction) => TransactionResult {\n\tlet coinResult: TransactionResult | null = null;\n\n\treturn (tx: Transaction) => {\n\t\tif (coinResult) {\n\t\t\treturn coinResult;\n\t\t}\n\n\t\ttx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n\t\tconst coinType = type === 'gas' ? type : normalizeStructTag(type);\n\n\t\tcoinResult = tx.add(\n\t\t\tCommands.Intent({\n\t\t\t\tname: COIN_WITH_BALANCE,\n\t\t\t\tinputs: {},\n\t\t\t\tdata: {\n\t\t\t\t\ttype: coinType === SUI_TYPE && useGasCoin ? 'gas' : coinType,\n\t\t\t\t\tbalance: BigInt(balance),\n\t\t\t\t} satisfies InferInput<typeof CoinWithBalanceData>,\n\t\t\t}),\n\t\t);\n\n\t\treturn coinResult;\n\t};\n}\n\nconst CoinWithBalanceData = object({\n\ttype: string(),\n\tbalance: bigint(),\n});\n\nasync function resolveCoinBalance(\n\ttransactionData: TransactionDataBuilder,\n\tbuildOptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tconst coinTypes = new Set<string>();\n\tconst totalByType = new Map<string, bigint>();\n\n\tif (!transactionData.sender) {\n\t\tthrow new Error('Sender must be set to resolve CoinWithBalance');\n\t}\n\n\tfor (const command of transactionData.commands) {\n\t\tif (command.$kind === '$Intent' && command.$Intent.name === COIN_WITH_BALANCE) {\n\t\t\tconst { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n\n\t\t\tif (type !== 'gas' && balance > 0n) {\n\t\t\t\tcoinTypes.add(type);\n\t\t\t}\n\n\t\t\ttotalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n\t\t}\n\t}\n\tconst usedIds = new Set<string>();\n\n\tfor (const input of transactionData.inputs) {\n\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\tusedIds.add(input.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\t\tif (input.UnresolvedObject?.objectId) {\n\t\t\tusedIds.add(input.UnresolvedObject.objectId);\n\t\t}\n\t}\n\n\tconst coinsByType = new Map<string, CoinStruct[]>();\n\tconst client = getSuiClient(buildOptions);\n\tawait Promise.all(\n\t\t[...coinTypes].map(async (coinType) => {\n\t\t\tcoinsByType.set(\n\t\t\t\tcoinType,\n\t\t\t\tawait getCoinsOfType({\n\t\t\t\t\tcoinType,\n\t\t\t\t\tbalance: totalByType.get(coinType)!,\n\t\t\t\t\tclient,\n\t\t\t\t\towner: transactionData.sender!,\n\t\t\t\t\tusedIds,\n\t\t\t\t}),\n\t\t\t);\n\t\t}),\n\t);\n\n\tconst mergedCoins = new Map<string, Argument>();\n\n\tmergedCoins.set('gas', { $kind: 'GasCoin', GasCoin: true });\n\n\tfor (const [index, transaction] of transactionData.commands.entries()) {\n\t\tif (transaction.$kind !== '$Intent' || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { type, balance } = transaction.$Intent.data as {\n\t\t\ttype: string;\n\t\t\tbalance: bigint;\n\t\t};\n\n\t\tif (balance === 0n && type !== 'gas') {\n\t\t\ttransactionData.replaceCommand(\n\t\t\t\tindex,\n\t\t\t\tCommands.MoveCall({ target: '0x2::coin::zero', typeArguments: [type] }),\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst commands = [];\n\n\t\tif (!mergedCoins.has(type)) {\n\t\t\tconst [first, ...rest] = coinsByType.get(type)!.map((coin) =>\n\t\t\t\ttransactionData.addInput(\n\t\t\t\t\t'object',\n\t\t\t\t\tInputs.ObjectRef({\n\t\t\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\t\t\tdigest: coin.digest,\n\t\t\t\t\t\tversion: coin.version,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tif (rest.length > 0) {\n\t\t\t\tcommands.push(Commands.MergeCoins(first, rest));\n\t\t\t}\n\n\t\t\tmergedCoins.set(type, first);\n\t\t}\n\n\t\tcommands.push(\n\t\t\tCommands.SplitCoins(mergedCoins.get(type)!, [\n\t\t\t\ttransactionData.addInput('pure', Inputs.Pure(bcs.u64().serialize(balance))),\n\t\t\t]),\n\t\t);\n\n\t\ttransactionData.replaceCommand(index, commands);\n\n\t\ttransactionData.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Result' && arg.Result === index) {\n\t\t\t\treturn {\n\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\tNestedResult: [index + commands.length - 1, 0],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treturn next();\n}\n\nasync function getCoinsOfType({\n\tcoinType,\n\tbalance,\n\tclient,\n\towner,\n\tusedIds,\n}: {\n\tcoinType: string;\n\tbalance: bigint;\n\tclient: SuiClient;\n\towner: string;\n\tusedIds: Set<string>;\n}): Promise<CoinStruct[]> {\n\tlet remainingBalance = balance;\n\tconst coins: CoinStruct[] = [];\n\n\treturn loadMoreCoins();\n\n\tasync function loadMoreCoins(cursor: string | null = null): Promise<CoinStruct[]> {\n\t\tconst { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n\n\t\tconst sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n\n\t\tfor (const coin of sortedCoins) {\n\t\t\tif (usedIds.has(coin.coinObjectId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst coinBalance = BigInt(coin.balance);\n\n\t\t\tcoins.push(coin);\n\t\t\tremainingBalance -= coinBalance;\n\n\t\t\tif (remainingBalance <= 0) {\n\t\t\t\treturn coins;\n\t\t\t}\n\t\t}\n\n\t\tif (hasNextPage) {\n\t\t\treturn loadMoreCoins(nextCursor);\n\t\t}\n\n\t\tthrow new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n\t}\n}\n\nexport function getSuiClient(options: BuildTransactionOptions): SuiClient {\n\tconst client = getClient(options) as SuiClient;\n\tif (!client.jsonRpc) {\n\t\tthrow new Error(`CoinWithBalance intent currently only works with SuiClient`);\n\t}\n\n\treturn client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\nimport type { Inputs } from './Inputs.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport type { Transaction, TransactionObjectArgument } from './Transaction.js';\n\nexport const Arguments = {\n\tpure: createPure<(tx: Transaction) => Argument>((value) => (tx) => tx.pure(value)) as ReturnType<\n\t\ttypeof createPure<(tx: Transaction) => Argument>\n\t>,\n\tobject: createObjectMethods<TransactionObjectArgument>((value) => (tx) => tx.object(value)),\n\tsharedObjectRef:\n\t\t(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.sharedObjectRef(...args),\n\tobjectRef:\n\t\t(...args: Parameters<(typeof Inputs)['ObjectRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.objectRef(...args),\n\treceivingRef:\n\t\t(...args: Parameters<(typeof Inputs)['ReceivingRef']>) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.receivingRef(...args),\n};\n", "function getVarName(variable) {\n  var matches = variable.match(/^var\\((.*)\\)$/);\n  if (matches) {\n    return matches[1];\n  }\n  return variable;\n}\n\nfunction get(obj, path) {\n  var result = obj;\n  for (var key of path) {\n    if (!(key in result)) {\n      throw new Error(\"Path \".concat(path.join(' -> '), \" does not exist in object\"));\n    }\n    result = result[key];\n  }\n  return result;\n}\n\nfunction walkObject(obj, fn) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var clone = {};\n  for (var key in obj) {\n    var _value = obj[key];\n    var currentPath = [...path, key];\n    if (typeof _value === 'string' || typeof _value === 'number' || _value == null) {\n      clone[key] = fn(_value, currentPath);\n    } else if (typeof _value === 'object' && !Array.isArray(_value)) {\n      clone[key] = walkObject(_value, fn, currentPath);\n    } else {\n      console.warn(\"Skipping invalid key \\\"\".concat(currentPath.join('.'), \"\\\". Should be a string, number, null or object. Received: \\\"\").concat(Array.isArray(_value) ? 'Array' : typeof _value, \"\\\"\"));\n    }\n  }\n  return clone;\n}\n\nexport { get, getVarName, walkObject };\n", "var stylesheets = {};\nvar injectStyles = _ref => {\n  var {\n    fileScope,\n    css\n  } = _ref;\n  var fileScopeId = fileScope.packageName ? [fileScope.packageName, fileScope.filePath].join('/') : fileScope.filePath;\n  var stylesheet = stylesheets[fileScopeId];\n  if (!stylesheet) {\n    var styleEl = document.createElement('style');\n    if (fileScope.packageName) {\n      styleEl.setAttribute('data-package', fileScope.packageName);\n    }\n    styleEl.setAttribute('data-file', fileScope.filePath);\n    styleEl.setAttribute('type', 'text/css');\n    stylesheet = stylesheets[fileScopeId] = styleEl;\n    document.head.appendChild(styleEl);\n  }\n  stylesheet.innerHTML = css;\n};\n\nexport { injectStyles };\n", "import { getVarName } from '@vanilla-extract/private';\nimport cssesc from 'cssesc';\nimport AhoCorasick from 'modern-ahocorasick';\nimport { markCompositionUsed } from '../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';\nimport { _ as _taggedTemplateLiteral } from './taggedTemplateLiteral-8e47dbd7.browser.esm.js';\nimport { parse } from 'css-what';\nimport dedent from 'dedent';\nimport { toAST } from 'media-query-parser';\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction forEach(obj, fn) {\n  for (var _key in obj) {\n    fn(obj[_key], _key);\n  }\n}\nfunction omit(obj, omitKeys) {\n  var result = {};\n  for (var _key2 in obj) {\n    if (omitKeys.indexOf(_key2) === -1) {\n      result[_key2] = obj[_key2];\n    }\n  }\n  return result;\n}\nfunction mapKeys(obj, fn) {\n  var result = {};\n  for (var _key3 in obj) {\n    result[fn(obj[_key3], _key3)] = obj[_key3];\n  }\n  return result;\n}\nfunction composeStylesIntoSet(set) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    classNames[_key5 - 1] = arguments[_key5];\n  }\n  for (var className of classNames) {\n    if (className.length === 0) {\n      continue;\n    }\n    if (typeof className === 'string') {\n      if (className.includes(' ')) {\n        composeStylesIntoSet(set, ...className.trim().split(' '));\n      } else {\n        set.add(className);\n      }\n    } else if (Array.isArray(className)) {\n      composeStylesIntoSet(set, ...className);\n    }\n  }\n}\nfunction dudupeAndJoinClassList(classNames) {\n  var set = new Set();\n  composeStylesIntoSet(set, ...classNames);\n  return Array.from(set).join(' ');\n}\n\nvar _templateObject$1;\n\n// https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction escapeRegex(string) {\n  return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nvar validateSelector = (selector, targetClassName) => {\n  var replaceTarget = () => {\n    var targetRegex = new RegExp(\".\".concat(escapeRegex(cssesc(targetClassName, {\n      isIdentifier: true\n    }))), 'g');\n    return selector.replace(targetRegex, '&');\n  };\n  var selectorParts;\n  try {\n    selectorParts = parse(selector);\n  } catch (err) {\n    throw new Error(\"Invalid selector: \".concat(replaceTarget()));\n  }\n  selectorParts.forEach(tokens => {\n    try {\n      for (var i = tokens.length - 1; i >= -1; i--) {\n        if (!tokens[i]) {\n          throw new Error();\n        }\n        var token = tokens[i];\n        if (token.type === 'child' || token.type === 'parent' || token.type === 'sibling' || token.type === 'adjacent' || token.type === 'descendant') {\n          throw new Error();\n        }\n        if (token.type === 'attribute' && token.name === 'class' && token.value === targetClassName) {\n          return; // Found it\n        }\n      }\n    } catch (err) {\n      throw new Error(dedent(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([\"\\n        Invalid selector: \", \"\\n    \\n        Style selectors must target the '&' character (along with any modifiers), e.g. \", \" or \", \".\\n        \\n        This is to ensure that each style block only affects the styling of a single class.\\n        \\n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of \", \") to 'parent', you should add \", \" to 'child').\\n        \\n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write \", \", you should instead write 'globalStyle(\", \", { ... })'\\n      \"])), replaceTarget(), '`${parent} &`', '`${parent} &:hover`', '`& ${child}`', '`${parent} &`', '`& h1`', '`${parent} h1`'));\n    }\n  });\n};\n\n/** e.g. @media screen and (min-width: 500px) */\n\nclass ConditionalRuleset {\n  /**\n   * Stores information about where conditions must be in relation to other conditions\n   *\n   * e.g. mobile -> tablet, desktop\n   */\n\n  constructor() {\n    this.ruleset = new Map();\n    this.precedenceLookup = new Map();\n  }\n  findOrCreateCondition(conditionQuery) {\n    var targetCondition = this.ruleset.get(conditionQuery);\n    if (!targetCondition) {\n      // No target condition so create one\n      targetCondition = {\n        query: conditionQuery,\n        rules: [],\n        children: new ConditionalRuleset()\n      };\n      this.ruleset.set(conditionQuery, targetCondition);\n    }\n    return targetCondition;\n  }\n  getConditionalRulesetByPath(conditionPath) {\n    var currRuleset = this;\n    for (var query of conditionPath) {\n      var condition = currRuleset.findOrCreateCondition(query);\n      currRuleset = condition.children;\n    }\n    return currRuleset;\n  }\n  addRule(rule, conditionQuery, conditionPath) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);\n    if (!targetCondition) {\n      throw new Error('Failed to add conditional rule');\n    }\n    targetCondition.rules.push(rule);\n  }\n  addConditionPrecedence(conditionPath, conditionOrder) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    for (var i = 0; i < conditionOrder.length; i++) {\n      var _ruleset$precedenceLo;\n      var query = conditionOrder[i];\n      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : new Set();\n      for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) {\n        conditionPrecedence.add(lowerPrecedenceCondition);\n      }\n      ruleset.precedenceLookup.set(query, conditionPrecedence);\n    }\n  }\n  isCompatible(incomingRuleset) {\n    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {\n      for (var lowerPrecedenceCondition of orderPrecedence) {\n        var _incomingRuleset$prec;\n        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that children are compatible\n    for (var {\n      query,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  merge(incomingRuleset) {\n    // Merge rulesets into one array\n    for (var {\n      query,\n      rules,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition) {\n        matchingCondition.rules.push(...rules);\n        matchingCondition.children.merge(children);\n      } else {\n        this.ruleset.set(query, {\n          query,\n          rules,\n          children\n        });\n      }\n    }\n\n    // Merge order precedences\n    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {\n      var _this$precedenceLooku;\n      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : new Set();\n      this.precedenceLookup.set(condition, new Set([...orderPrecedence, ...incomingOrderPrecedence]));\n    }\n  }\n\n  /**\n   * Merge another ConditionalRuleset into this one if they are compatible\n   *\n   * @returns true if successful, false if the ruleset is incompatible\n   */\n  mergeIfCompatible(incomingRuleset) {\n    if (!this.isCompatible(incomingRuleset)) {\n      return false;\n    }\n    this.merge(incomingRuleset);\n    return true;\n  }\n  getSortedRuleset() {\n    var _this = this;\n    var sortedRuleset = [];\n\n    // Loop through all queries and add them to the sorted ruleset\n    var _loop = function _loop(dependents) {\n      var conditionForQuery = _this.ruleset.get(query);\n      if (!conditionForQuery) {\n        throw new Error(\"Can't find condition for \".concat(query));\n      }\n\n      // Find the location of the first dependent condition in the sortedRuleset\n      // A dependent condition is a condition that must be placed *after* the current one\n      var firstMatchingDependent = sortedRuleset.findIndex(condition => dependents.has(condition.query));\n      if (firstMatchingDependent > -1) {\n        // Insert the condition before the dependent one\n        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);\n      } else {\n        // No match, just insert at the end\n        sortedRuleset.push(conditionForQuery);\n      }\n    };\n    for (var [query, dependents] of this.precedenceLookup.entries()) {\n      _loop(dependents);\n    }\n    return sortedRuleset;\n  }\n  renderToArray() {\n    var arr = [];\n    for (var {\n      query,\n      rules,\n      children\n    } of this.getSortedRuleset()) {\n      var selectors = {};\n      for (var rule of rules) {\n        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);\n      }\n      Object.assign(selectors, ...children.renderToArray());\n      arr.push({\n        [query]: selectors\n      });\n    }\n    return arr;\n  }\n}\n\nvar simplePseudoMap = {\n  ':-moz-any-link': true,\n  ':-moz-full-screen': true,\n  ':-moz-placeholder': true,\n  ':-moz-read-only': true,\n  ':-moz-read-write': true,\n  ':-ms-fullscreen': true,\n  ':-ms-input-placeholder': true,\n  ':-webkit-any-link': true,\n  ':-webkit-full-screen': true,\n  '::-moz-color-swatch': true,\n  '::-moz-list-bullet': true,\n  '::-moz-list-number': true,\n  '::-moz-page-sequence': true,\n  '::-moz-page': true,\n  '::-moz-placeholder': true,\n  '::-moz-progress-bar': true,\n  '::-moz-range-progress': true,\n  '::-moz-range-thumb': true,\n  '::-moz-range-track': true,\n  '::-moz-scrolled-page-sequence': true,\n  '::-moz-selection': true,\n  '::-ms-backdrop': true,\n  '::-ms-browse': true,\n  '::-ms-check': true,\n  '::-ms-clear': true,\n  '::-ms-fill-lower': true,\n  '::-ms-fill-upper': true,\n  '::-ms-fill': true,\n  '::-ms-reveal': true,\n  '::-ms-thumb': true,\n  '::-ms-ticks-after': true,\n  '::-ms-ticks-before': true,\n  '::-ms-tooltip': true,\n  '::-ms-track': true,\n  '::-ms-value': true,\n  '::-webkit-backdrop': true,\n  '::-webkit-calendar-picker-indicator': true,\n  '::-webkit-inner-spin-button': true,\n  '::-webkit-input-placeholder': true,\n  '::-webkit-meter-bar': true,\n  '::-webkit-meter-even-less-good-value': true,\n  '::-webkit-meter-inner-element': true,\n  '::-webkit-meter-optimum-value': true,\n  '::-webkit-meter-suboptimum-value': true,\n  '::-webkit-outer-spin-button': true,\n  '::-webkit-progress-bar': true,\n  '::-webkit-progress-inner-element': true,\n  '::-webkit-progress-inner-value': true,\n  '::-webkit-progress-value': true,\n  '::-webkit-resizer': true,\n  '::-webkit-scrollbar-button': true,\n  '::-webkit-scrollbar-corner': true,\n  '::-webkit-scrollbar-thumb': true,\n  '::-webkit-scrollbar-track-piece': true,\n  '::-webkit-scrollbar-track': true,\n  '::-webkit-scrollbar': true,\n  '::-webkit-search-cancel-button': true,\n  '::-webkit-search-results-button': true,\n  '::-webkit-slider-runnable-track': true,\n  '::-webkit-slider-thumb': true,\n  '::after': true,\n  '::backdrop': true,\n  '::before': true,\n  '::cue': true,\n  '::file-selector-button': true,\n  '::first-letter': true,\n  '::first-line': true,\n  '::grammar-error': true,\n  '::marker': true,\n  '::placeholder': true,\n  '::selection': true,\n  '::spelling-error': true,\n  '::target-text': true,\n  '::view-transition-group': true,\n  '::view-transition-image-pair': true,\n  '::view-transition-new': true,\n  '::view-transition-old': true,\n  '::view-transition': true,\n  ':active': true,\n  ':after': true,\n  ':any-link': true,\n  ':before': true,\n  ':blank': true,\n  ':checked': true,\n  ':default': true,\n  ':defined': true,\n  ':disabled': true,\n  ':empty': true,\n  ':enabled': true,\n  ':first-child': true,\n  ':first-letter': true,\n  ':first-line': true,\n  ':first-of-type': true,\n  ':first': true,\n  ':focus-visible': true,\n  ':focus-within': true,\n  ':focus': true,\n  ':fullscreen': true,\n  ':hover': true,\n  ':in-range': true,\n  ':indeterminate': true,\n  ':invalid': true,\n  ':last-child': true,\n  ':last-of-type': true,\n  ':left': true,\n  ':link': true,\n  ':only-child': true,\n  ':only-of-type': true,\n  ':optional': true,\n  ':out-of-range': true,\n  ':placeholder-shown': true,\n  ':read-only': true,\n  ':read-write': true,\n  ':required': true,\n  ':right': true,\n  ':root': true,\n  ':scope': true,\n  ':target': true,\n  ':valid': true,\n  ':visited': true\n};\nvar simplePseudos = Object.keys(simplePseudoMap);\nvar simplePseudoLookup = simplePseudoMap;\n\nvar _templateObject;\nvar createMediaQueryError = (mediaQuery, msg) => new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    Invalid media query: \\\"\", \"\\\"\\n\\n    \", \"\\n\\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\\n  \"])), mediaQuery, msg));\nvar validateMediaQuery = mediaQuery => {\n  // Empty queries will start with '@media '\n  if (mediaQuery === '@media ') {\n    throw createMediaQueryError(mediaQuery, 'Query is empty');\n  }\n  try {\n    toAST(mediaQuery);\n  } catch (e) {\n    throw createMediaQueryError(mediaQuery, e.message);\n  }\n};\n\nvar _excluded = [\"vars\"],\n  _excluded2 = [\"content\"];\nvar DECLARATION = '__DECLARATION';\nvar UNITLESS = {\n  animationIterationCount: true,\n  borderImage: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  initialLetter: true,\n  lineClamp: true,\n  lineHeight: true,\n  maxLines: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  scale: true,\n  tabSize: true,\n  WebkitLineClamp: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // svg properties\n  fillOpacity: true,\n  floodOpacity: true,\n  maskBorder: true,\n  maskBorderOutset: true,\n  maskBorderSlice: true,\n  maskBorderWidth: true,\n  shapeImageThreshold: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\nfunction dashify(str) {\n  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();\n}\nfunction replaceBetweenIndexes(target, startIndex, endIndex, replacement) {\n  var start = target.slice(0, startIndex);\n  var end = target.slice(endIndex);\n  return \"\".concat(start).concat(replacement).concat(end);\n}\nvar DOUBLE_SPACE = '  ';\nvar specialKeys = [...simplePseudos, '@layer', '@media', '@supports', '@container', 'selectors'];\nclass Stylesheet {\n  constructor(localClassNames, composedClassLists) {\n    this.rules = [];\n    this.conditionalRulesets = [new ConditionalRuleset()];\n    this.fontFaceRules = [];\n    this.keyframesRules = [];\n    this.propertyRules = [];\n    this.localClassNamesMap = new Map(localClassNames.map(localClassName => [localClassName, localClassName]));\n    this.localClassNamesSearch = new AhoCorasick(localClassNames);\n    this.layers = new Map();\n\n    // Class list compositions should be priortized by Newer > Older\n    // Therefore we reverse the array as they are added in sequence\n    this.composedClassLists = composedClassLists.map(_ref => {\n      var {\n        identifier,\n        classList\n      } = _ref;\n      return {\n        identifier,\n        regex: RegExp(\"(\".concat(classList, \")\"), 'g')\n      };\n    }).reverse();\n  }\n  processCssObj(root) {\n    if (root.type === 'fontFace') {\n      this.fontFaceRules.push(root.rule);\n      return;\n    }\n    if (root.type === 'property') {\n      this.propertyRules.push(root);\n      return;\n    }\n    if (root.type === 'keyframes') {\n      root.rule = Object.fromEntries(Object.entries(root.rule).map(_ref2 => {\n        var [keyframe, rule] = _ref2;\n        return [keyframe, this.transformVars(this.transformProperties(rule))];\n      }));\n      this.keyframesRules.push(root);\n      return;\n    }\n    this.currConditionalRuleset = new ConditionalRuleset();\n    if (root.type === 'layer') {\n      var layerDefinition = \"@layer \".concat(root.name);\n      this.addLayer([layerDefinition]);\n    } else {\n      // Add main styles\n      var mainRule = omit(root.rule, specialKeys);\n      this.addRule({\n        selector: root.selector,\n        rule: mainRule\n      });\n      this.transformLayer(root, root.rule['@layer']);\n      this.transformMedia(root, root.rule['@media']);\n      this.transformSupports(root, root.rule['@supports']);\n      this.transformContainer(root, root.rule['@container']);\n      this.transformSimplePseudos(root, root.rule);\n      this.transformSelectors(root, root.rule);\n    }\n    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];\n    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {\n      // Ruleset merge failed due to incompatibility. We now deopt by starting a fresh ConditionalRuleset\n      this.conditionalRulesets.push(this.currConditionalRuleset);\n    }\n  }\n  addConditionalRule(cssRule, conditions) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    if (!this.currConditionalRuleset) {\n      throw new Error(\"Couldn't add conditional rule\");\n    }\n    var conditionQuery = conditions[conditions.length - 1];\n    var parentConditions = conditions.slice(0, conditions.length - 1);\n    this.currConditionalRuleset.addRule({\n      selector,\n      rule\n    }, conditionQuery, parentConditions);\n  }\n  addRule(cssRule) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    this.rules.push({\n      selector,\n      rule\n    });\n  }\n  addLayer(layer) {\n    var uniqueLayerKey = layer.join(' - ');\n    this.layers.set(uniqueLayerKey, layer);\n  }\n  transformProperties(cssRule) {\n    return this.transformContent(this.pixelifyProperties(cssRule));\n  }\n  pixelifyProperties(cssRule) {\n    forEach(cssRule, (value, key) => {\n      if (typeof value === 'number' && value !== 0 && !UNITLESS[key]) {\n        // @ts-expect-error Any ideas?\n        cssRule[key] = \"\".concat(value, \"px\");\n      }\n    });\n    return cssRule;\n  }\n  transformVars(_ref3) {\n    var {\n        vars\n      } = _ref3,\n      rest = _objectWithoutProperties(_ref3, _excluded);\n    if (!vars) {\n      return rest;\n    }\n    return _objectSpread2(_objectSpread2({}, mapKeys(vars, (_value, key) => getVarName(key))), rest);\n  }\n  transformContent(_ref4) {\n    var {\n        content\n      } = _ref4,\n      rest = _objectWithoutProperties(_ref4, _excluded2);\n    if (typeof content === 'undefined') {\n      return rest;\n    }\n\n    // Handle fallback arrays:\n    var contentArray = Array.isArray(content) ? content : [content];\n    return _objectSpread2({\n      content: contentArray.map(value =>\n      // This logic was adapted from Stitches :)\n      value && (value.includes('\"') || value.includes(\"'\") || /^([A-Za-z\\-]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\\s|$)/.test(value)) ? value : \"\\\"\".concat(value, \"\\\"\"))\n    }, rest);\n  }\n  transformClassname(identifier) {\n    return \".\".concat(cssesc(identifier, {\n      isIdentifier: true\n    }));\n  }\n  transformSelector(selector) {\n    // Map class list compositions to single identifiers\n    var transformedSelector = selector;\n    var _loop = function _loop(identifier) {\n      transformedSelector = transformedSelector.replace(regex, () => {\n        markCompositionUsed(identifier);\n        return identifier;\n      });\n    };\n    for (var {\n      identifier,\n      regex\n    } of this.composedClassLists) {\n      _loop(identifier);\n    }\n    if (this.localClassNamesMap.has(transformedSelector)) {\n      return this.transformClassname(transformedSelector);\n    }\n    var results = this.localClassNamesSearch.search(transformedSelector);\n    var lastReplaceIndex = transformedSelector.length;\n\n    // Perform replacements backwards to simplify index handling\n    for (var i = results.length - 1; i >= 0; i--) {\n      var [endIndex, [firstMatch]] = results[i];\n      var startIndex = endIndex - firstMatch.length + 1;\n\n      // Class names can be substrings of other class names\n      // e.g. '_1g1ptzo1' and '_1g1ptzo10'\n      //\n      // Additionally, concatenated classnames can contain substrings equal to other classnames\n      // e.g. '&&' where '&' is 'debugName_hash1' and 'debugName_hash1d' is also a local classname\n      // Before transforming the selector, this would look like `debugName_hash1debugName_hash1`\n      // which contains the substring `debugName_hash1d`.\n      //\n      // In either of these cases, the last replace index will occur either before or within the\n      // current replacement range (from `startIndex` to `endIndex`).\n      // If this occurs, we skip the replacement to avoid transforming the selector incorrectly.\n      var skipReplacement = lastReplaceIndex <= endIndex;\n      if (skipReplacement) {\n        continue;\n      }\n      lastReplaceIndex = startIndex;\n\n      // If class names already starts with a '.' then skip\n      if (transformedSelector[startIndex - 1] !== '.') {\n        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));\n      }\n    }\n    return transformedSelector;\n  }\n  transformSelectors(root, rule, conditions) {\n    forEach(rule.selectors, (selectorRule, selector) => {\n      if (root.type !== 'local') {\n        throw new Error(\"Selectors are not allowed within \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n      }\n      var transformedSelector = this.transformSelector(selector.replace(RegExp('&', 'g'), root.selector));\n      validateSelector(transformedSelector, root.selector);\n      var rule = {\n        selector: transformedSelector,\n        rule: omit(selectorRule, specialKeys)\n      };\n      if (conditions) {\n        this.addConditionalRule(rule, conditions);\n      } else {\n        this.addRule(rule);\n      }\n      var selectorRoot = {\n        type: 'selector',\n        selector: transformedSelector,\n        rule: selectorRule\n      };\n      this.transformLayer(selectorRoot, selectorRule['@layer'], conditions);\n      this.transformSupports(selectorRoot, selectorRule['@supports'], conditions);\n      this.transformMedia(selectorRoot, selectorRule['@media'], conditions);\n      this.transformContainer(selectorRoot, selectorRule['@container'], conditions);\n    });\n  }\n  transformMedia(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional;\n      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@media \".concat(query)));\n      for (var [query, mediaRule] of Object.entries(rules)) {\n        var mediaQuery = \"@media \".concat(query);\n        validateMediaQuery(mediaQuery);\n        var conditions = [...parentConditions, mediaQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(mediaRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, mediaRule, conditions);\n          this.transformSelectors(root, mediaRule, conditions);\n        }\n        this.transformLayer(root, mediaRule['@layer'], conditions);\n        this.transformSupports(root, mediaRule['@supports'], conditions);\n        this.transformContainer(root, mediaRule['@container'], conditions);\n      }\n    }\n  }\n  transformContainer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional2;\n      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@container \".concat(query)));\n      forEach(rules, (containerRule, query) => {\n        var containerQuery = \"@container \".concat(query);\n        var conditions = [...parentConditions, containerQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(containerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, containerRule, conditions);\n          this.transformSelectors(root, containerRule, conditions);\n        }\n        this.transformLayer(root, containerRule['@layer'], conditions);\n        this.transformSupports(root, containerRule['@supports'], conditions);\n        this.transformMedia(root, containerRule['@media'], conditions);\n      });\n    }\n  }\n  transformLayer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional3;\n      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map(name => \"@layer \".concat(name)));\n      forEach(rules, (layerRule, name) => {\n        var conditions = [...parentConditions, \"@layer \".concat(name)];\n        this.addLayer(conditions);\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(layerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, layerRule, conditions);\n          this.transformSelectors(root, layerRule, conditions);\n        }\n        this.transformMedia(root, layerRule['@media'], conditions);\n        this.transformSupports(root, layerRule['@supports'], conditions);\n        this.transformContainer(root, layerRule['@container'], conditions);\n      });\n    }\n  }\n  transformSupports(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional4;\n      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@supports \".concat(query)));\n      forEach(rules, (supportsRule, query) => {\n        var conditions = [...parentConditions, \"@supports \".concat(query)];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(supportsRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, supportsRule, conditions);\n          this.transformSelectors(root, supportsRule, conditions);\n        }\n        this.transformLayer(root, supportsRule['@layer'], conditions);\n        this.transformMedia(root, supportsRule['@media'], conditions);\n        this.transformContainer(root, supportsRule['@container'], conditions);\n      });\n    }\n  }\n  transformSimplePseudos(root, rule, conditions) {\n    for (var key of Object.keys(rule)) {\n      // Process simple pseudos\n      if (simplePseudoLookup[key]) {\n        if (root.type !== 'local') {\n          throw new Error(\"Simple pseudos are not valid in \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n        }\n        if (conditions) {\n          this.addConditionalRule({\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          }, conditions);\n        } else {\n          this.addRule({\n            conditions,\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          });\n        }\n      }\n    }\n  }\n  toCss() {\n    var css = [];\n\n    // Render font-face rules\n    for (var fontFaceRule of this.fontFaceRules) {\n      css.push(renderCss({\n        '@font-face': fontFaceRule\n      }));\n    }\n\n    // Render property rules\n    for (var property of this.propertyRules) {\n      css.push(renderCss({\n        [\"@property \".concat(property.name)]: property.rule\n      }));\n    }\n\n    // Render keyframes\n    for (var keyframe of this.keyframesRules) {\n      css.push(renderCss({\n        [\"@keyframes \".concat(keyframe.name)]: keyframe.rule\n      }));\n    }\n\n    // Render layer definitions\n    for (var layer of this.layers.values()) {\n      var [definition, ...nesting] = layer.reverse();\n      var cssObj = {\n        [definition]: DECLARATION\n      };\n      for (var part of nesting) {\n        cssObj = {\n          [part]: cssObj\n        };\n      }\n      css.push(renderCss(cssObj));\n    }\n\n    // Render unconditional rules\n    for (var rule of this.rules) {\n      css.push(renderCss({\n        [rule.selector]: rule.rule\n      }));\n    }\n\n    // Render conditional rules\n    for (var conditionalRuleset of this.conditionalRulesets) {\n      for (var conditionalRule of conditionalRuleset.renderToArray()) {\n        css.push(renderCss(conditionalRule));\n      }\n    }\n    return css.filter(Boolean);\n  }\n}\nfunction renderCss(v) {\n  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var rules = [];\n  var _loop2 = function _loop2(key) {\n    var value = v[key];\n    if (value && Array.isArray(value)) {\n      rules.push(...value.map(v => renderCss({\n        [key]: v\n      }, indent)));\n    } else if (value && typeof value === 'object') {\n      var isEmpty = Object.keys(value).length === 0;\n      if (!isEmpty) {\n        rules.push(\"\".concat(indent).concat(key, \" {\\n\").concat(renderCss(value, indent + DOUBLE_SPACE), \"\\n\").concat(indent, \"}\"));\n      }\n    } else if (value === DECLARATION) {\n      rules.push(\"\".concat(indent).concat(key, \";\"));\n    } else {\n      rules.push(\"\".concat(indent).concat(key.startsWith('--') ? key : dashify(key), \": \").concat(value, \";\"));\n    }\n  };\n  for (var key of Object.keys(v)) {\n    _loop2(key);\n  }\n  return rules.join('\\n');\n}\nfunction transformCss(_ref5) {\n  var {\n    localClassNames,\n    cssObjs,\n    composedClassLists\n  } = _ref5;\n  var stylesheet = new Stylesheet(localClassNames, composedClassLists);\n  for (var root of cssObjs) {\n    stylesheet.processCssObj(root);\n  }\n  return stylesheet.toCss();\n}\n\nexport { _objectSpread2 as _, _objectWithoutProperties as a, dudupeAndJoinClassList as d, transformCss as t };\n", "// src/index.ts\nvar AhoCorasick = class {\n  constructor(keywords) {\n    const { failure, gotoFn, output } = this._buildTables(keywords);\n    this.gotoFn = gotoFn;\n    this.output = output;\n    this.failure = failure;\n  }\n  _buildTables(keywords) {\n    const gotoFn = {\n      0: {}\n    };\n    const output = {};\n    let state = 0;\n    for (const word of keywords) {\n      let curr = 0;\n      for (const l of word) {\n        if (gotoFn[curr] && l in gotoFn[curr]) {\n          curr = gotoFn[curr][l];\n        } else {\n          state++;\n          gotoFn[curr][l] = state;\n          gotoFn[state] = {};\n          curr = state;\n          output[state] = [];\n        }\n      }\n      output[curr].push(word);\n    }\n    const failure = {};\n    const xs = [];\n    for (const l in gotoFn[0]) {\n      const state2 = gotoFn[0][l];\n      failure[state2] = 0;\n      xs.push(state2);\n    }\n    while (xs.length > 0) {\n      const r = xs.shift();\n      if (r !== void 0) {\n        for (const l in gotoFn[r]) {\n          const s = gotoFn[r][l];\n          xs.push(s);\n          let state2 = failure[r];\n          while (state2 > 0 && !(l in gotoFn[state2])) {\n            state2 = failure[state2];\n          }\n          if (l in gotoFn[state2]) {\n            const fs = gotoFn[state2][l];\n            failure[s] = fs;\n            output[s] = [...output[s], ...output[fs]];\n          } else {\n            failure[s] = 0;\n          }\n        }\n      }\n    }\n    return {\n      gotoFn,\n      output,\n      failure\n    };\n  }\n  search(str) {\n    let state = 0;\n    const results = [];\n    for (let i = 0; i < str.length; i++) {\n      const l = str[i];\n      while (state > 0 && !(l in this.gotoFn[state])) {\n        state = this.failure[state];\n      }\n      if (!(l in this.gotoFn[state])) {\n        continue;\n      }\n      state = this.gotoFn[state][l];\n      if (this.output[state].length > 0) {\n        const foundStrs = this.output[state];\n        results.push([i, foundStrs]);\n      }\n    }\n    return results;\n  }\n  match(str) {\n    let state = 0;\n    for (let i = 0; i < str.length; i++) {\n      const l = str[i];\n      while (state > 0 && !(l in this.gotoFn[state])) {\n        state = this.failure[state];\n      }\n      if (!(l in this.gotoFn[state])) {\n        continue;\n      }\n      state = this.gotoFn[state][l];\n      if (this.output[state].length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport {\n  AhoCorasick as default\n};\n", "var mockAdapter = {\n  appendCss: () => {},\n  registerClassName: () => {},\n  onEndFileScope: () => {},\n  registerComposition: () => {},\n  markCompositionUsed: () => {},\n  getIdentOption: () => process.env.NODE_ENV === 'production' ? 'short' : 'debug'\n};\nvar adapterStack = [mockAdapter];\nvar currentAdapter = () => {\n  if (adapterStack.length < 1) {\n    throw new Error('No adapter configured');\n  }\n  return adapterStack[adapterStack.length - 1];\n};\nvar hasConfiguredAdapter = false;\nvar setAdapterIfNotSet = newAdapter => {\n  if (!hasConfiguredAdapter) {\n    setAdapter(newAdapter);\n  }\n};\nvar setAdapter = newAdapter => {\n  if (!newAdapter) {\n    throw new Error('No adapter provided when calling \"setAdapter\"');\n  }\n  hasConfiguredAdapter = true;\n  adapterStack.push(newAdapter);\n};\nvar removeAdapter = () => {\n  adapterStack.pop();\n};\nvar appendCss = function appendCss() {\n  return currentAdapter().appendCss(...arguments);\n};\nvar registerClassName = function registerClassName() {\n  return currentAdapter().registerClassName(...arguments);\n};\nvar registerComposition = function registerComposition() {\n  return currentAdapter().registerComposition(...arguments);\n};\nvar markCompositionUsed = function markCompositionUsed() {\n  return currentAdapter().markCompositionUsed(...arguments);\n};\nvar onBeginFileScope = function onBeginFileScope() {\n  var _currentAdapter$onBeg, _currentAdapter;\n  for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n    props[_key] = arguments[_key];\n  }\n  return (_currentAdapter$onBeg = (_currentAdapter = currentAdapter()).onBeginFileScope) === null || _currentAdapter$onBeg === void 0 ? void 0 : _currentAdapter$onBeg.call(_currentAdapter, ...props);\n};\nvar onEndFileScope = function onEndFileScope() {\n  return currentAdapter().onEndFileScope(...arguments);\n};\nvar getIdentOption = function getIdentOption() {\n  var adapter = currentAdapter();\n\n  // Backwards compatibility with old versions of the integration package\n  if (!('getIdentOption' in adapter)) {\n    return process.env.NODE_ENV === 'production' ? 'short' : 'debug';\n  }\n  return adapter.getIdentOption(...arguments);\n};\n\nexport { appendCss, getIdentOption, markCompositionUsed, mockAdapter, onBeginFileScope, onEndFileScope, registerClassName, registerComposition, removeAdapter, setAdapter, setAdapterIfNotSet };\n", "function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nexport { _taggedTemplateLiteral as _ };\n", "export var SelectorType;\n(function (SelectorType) {\n    SelectorType[\"Attribute\"] = \"attribute\";\n    SelectorType[\"Pseudo\"] = \"pseudo\";\n    SelectorType[\"PseudoElement\"] = \"pseudo-element\";\n    SelectorType[\"Tag\"] = \"tag\";\n    SelectorType[\"Universal\"] = \"universal\";\n    // Traversals\n    SelectorType[\"Adjacent\"] = \"adjacent\";\n    SelectorType[\"Child\"] = \"child\";\n    SelectorType[\"Descendant\"] = \"descendant\";\n    SelectorType[\"Parent\"] = \"parent\";\n    SelectorType[\"Sibling\"] = \"sibling\";\n    SelectorType[\"ColumnCombinator\"] = \"column-combinator\";\n})(SelectorType || (SelectorType = {}));\n/**\n * Modes for ignore case.\n *\n * This could be updated to an enum, and the object is\n * the current stand-in that will allow code to be updated\n * without big changes.\n */\nexport const IgnoreCaseMode = {\n    Unknown: null,\n    QuirksMode: \"quirks\",\n    IgnoreCase: true,\n    CaseSensitive: false,\n};\nexport var AttributeAction;\n(function (AttributeAction) {\n    AttributeAction[\"Any\"] = \"any\";\n    AttributeAction[\"Element\"] = \"element\";\n    AttributeAction[\"End\"] = \"end\";\n    AttributeAction[\"Equals\"] = \"equals\";\n    AttributeAction[\"Exists\"] = \"exists\";\n    AttributeAction[\"Hyphen\"] = \"hyphen\";\n    AttributeAction[\"Not\"] = \"not\";\n    AttributeAction[\"Start\"] = \"start\";\n})(AttributeAction || (AttributeAction = {}));\n", "import { SelectorType, AttributeAction, } from \"./types\";\nconst reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nconst reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nconst actionTypes = new Map([\n    [126 /* Tilde */, AttributeAction.Element],\n    [94 /* Circumflex */, AttributeAction.Start],\n    [36 /* Dollar */, AttributeAction.End],\n    [42 /* Asterisk */, AttributeAction.Any],\n    [33 /* ExclamationMark */, AttributeAction.Not],\n    [124 /* Pipe */, AttributeAction.Hyphen],\n]);\n// Pseudos, whose data property is parsed as well.\nconst unpackPseudos = new Set([\n    \"has\",\n    \"not\",\n    \"matches\",\n    \"is\",\n    \"where\",\n    \"host\",\n    \"host-context\",\n]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nexport function isTraversal(selector) {\n    switch (selector.type) {\n        case SelectorType.Adjacent:\n        case SelectorType.Child:\n        case SelectorType.Descendant:\n        case SelectorType.Parent:\n        case SelectorType.Sibling:\n        case SelectorType.ColumnCombinator:\n            return true;\n        default:\n            return false;\n    }\n}\nconst stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n    const high = parseInt(escaped, 16) - 0x10000;\n    // NaN means non-codepoint\n    return high !== high || escapedWhitespace\n        ? escaped\n        : high < 0\n            ? // BMP codepoint\n                String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n}\nfunction unescapeCSS(str) {\n    return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\nfunction isWhitespace(c) {\n    return (c === 32 /* Space */ ||\n        c === 9 /* Tab */ ||\n        c === 10 /* NewLine */ ||\n        c === 12 /* FormFeed */ ||\n        c === 13 /* CarriageReturn */);\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nexport function parse(selector) {\n    const subselects = [];\n    const endIndex = parseSelector(subselects, `${selector}`, 0);\n    if (endIndex < selector.length) {\n        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);\n    }\n    return subselects;\n}\nfunction parseSelector(subselects, selector, selectorIndex) {\n    let tokens = [];\n    function getName(offset) {\n        const match = selector.slice(selectorIndex + offset).match(reName);\n        if (!match) {\n            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);\n        }\n        const [name] = match;\n        selectorIndex += offset + name.length;\n        return unescapeCSS(name);\n    }\n    function stripWhitespace(offset) {\n        selectorIndex += offset;\n        while (selectorIndex < selector.length &&\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\n            selectorIndex++;\n        }\n    }\n    function readValueWithParenthesis() {\n        selectorIndex += 1;\n        const start = selectorIndex;\n        let counter = 1;\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n            if (selector.charCodeAt(selectorIndex) ===\n                40 /* LeftParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter++;\n            }\n            else if (selector.charCodeAt(selectorIndex) ===\n                41 /* RightParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter--;\n            }\n        }\n        if (counter) {\n            throw new Error(\"Parenthesis not matched\");\n        }\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\n    }\n    function isEscaped(pos) {\n        let slashCount = 0;\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\n            slashCount++;\n        return (slashCount & 1) === 1;\n    }\n    function ensureNotTraversal() {\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n            throw new Error(\"Did not expect successive traversals.\");\n        }\n    }\n    function addTraversal(type) {\n        if (tokens.length > 0 &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens[tokens.length - 1].type = type;\n            return;\n        }\n        ensureNotTraversal();\n        tokens.push({ type });\n    }\n    function addSpecialAttribute(name, action) {\n        tokens.push({\n            type: SelectorType.Attribute,\n            name,\n            action,\n            value: getName(1),\n            namespace: null,\n            ignoreCase: \"quirks\",\n        });\n    }\n    /**\n     * We have finished parsing the current part of the selector.\n     *\n     * Remove descendant tokens at the end if they exist,\n     * and return the last index, so that parsing can be\n     * picked up from here.\n     */\n    function finalizeSubselector() {\n        if (tokens.length &&\n            tokens[tokens.length - 1].type === SelectorType.Descendant) {\n            tokens.pop();\n        }\n        if (tokens.length === 0) {\n            throw new Error(\"Empty sub-selector\");\n        }\n        subselects.push(tokens);\n    }\n    stripWhitespace(0);\n    if (selector.length === selectorIndex) {\n        return selectorIndex;\n    }\n    loop: while (selectorIndex < selector.length) {\n        const firstChar = selector.charCodeAt(selectorIndex);\n        switch (firstChar) {\n            // Whitespace\n            case 32 /* Space */:\n            case 9 /* Tab */:\n            case 10 /* NewLine */:\n            case 12 /* FormFeed */:\n            case 13 /* CarriageReturn */: {\n                if (tokens.length === 0 ||\n                    tokens[0].type !== SelectorType.Descendant) {\n                    ensureNotTraversal();\n                    tokens.push({ type: SelectorType.Descendant });\n                }\n                stripWhitespace(1);\n                break;\n            }\n            // Traversals\n            case 62 /* GreaterThan */: {\n                addTraversal(SelectorType.Child);\n                stripWhitespace(1);\n                break;\n            }\n            case 60 /* LessThan */: {\n                addTraversal(SelectorType.Parent);\n                stripWhitespace(1);\n                break;\n            }\n            case 126 /* Tilde */: {\n                addTraversal(SelectorType.Sibling);\n                stripWhitespace(1);\n                break;\n            }\n            case 43 /* Plus */: {\n                addTraversal(SelectorType.Adjacent);\n                stripWhitespace(1);\n                break;\n            }\n            // Special attribute selectors: .class, #id\n            case 46 /* Period */: {\n                addSpecialAttribute(\"class\", AttributeAction.Element);\n                break;\n            }\n            case 35 /* Hash */: {\n                addSpecialAttribute(\"id\", AttributeAction.Equals);\n                break;\n            }\n            case 91 /* LeftSquareBracket */: {\n                stripWhitespace(1);\n                // Determine attribute name and namespace\n                let name;\n                let namespace = null;\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n                    // Equivalent to no namespace\n                    name = getName(1);\n                }\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\n                    namespace = \"*\";\n                    name = getName(2);\n                }\n                else {\n                    name = getName(0);\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                        selector.charCodeAt(selectorIndex + 1) !==\n                            61 /* Equal */) {\n                        namespace = name;\n                        name = getName(1);\n                    }\n                }\n                stripWhitespace(0);\n                // Determine comparison operation\n                let action = AttributeAction.Exists;\n                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n                if (possibleAction) {\n                    action = possibleAction;\n                    if (selector.charCodeAt(selectorIndex + 1) !==\n                        61 /* Equal */) {\n                        throw new Error(\"Expected `=`\");\n                    }\n                    stripWhitespace(2);\n                }\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n                    action = AttributeAction.Equals;\n                    stripWhitespace(1);\n                }\n                // Determine value\n                let value = \"\";\n                let ignoreCase = null;\n                if (action !== \"exists\") {\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\n                        const quote = selector.charCodeAt(selectorIndex);\n                        let sectionEnd = selectorIndex + 1;\n                        while (sectionEnd < selector.length &&\n                            (selector.charCodeAt(sectionEnd) !== quote ||\n                                isEscaped(sectionEnd))) {\n                            sectionEnd += 1;\n                        }\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\n                            throw new Error(\"Attribute value didn't end\");\n                        }\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n                        selectorIndex = sectionEnd + 1;\n                    }\n                    else {\n                        const valueStart = selectorIndex;\n                        while (selectorIndex < selector.length &&\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\n                                selector.charCodeAt(selectorIndex) !==\n                                    93 /* RightSquareBracket */) ||\n                                isEscaped(selectorIndex))) {\n                            selectorIndex += 1;\n                        }\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n                    }\n                    stripWhitespace(0);\n                    // See if we have a force ignore flag\n                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\n                    if (forceIgnore === 115 /* LowerS */) {\n                        ignoreCase = false;\n                        stripWhitespace(1);\n                    }\n                    else if (forceIgnore === 105 /* LowerI */) {\n                        ignoreCase = true;\n                        stripWhitespace(1);\n                    }\n                }\n                if (selector.charCodeAt(selectorIndex) !==\n                    93 /* RightSquareBracket */) {\n                    throw new Error(\"Attribute selector didn't terminate\");\n                }\n                selectorIndex += 1;\n                const attributeSelector = {\n                    type: SelectorType.Attribute,\n                    name,\n                    action,\n                    value,\n                    namespace,\n                    ignoreCase,\n                };\n                tokens.push(attributeSelector);\n                break;\n            }\n            case 58 /* Colon */: {\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n                    tokens.push({\n                        type: SelectorType.PseudoElement,\n                        name: getName(2).toLowerCase(),\n                        data: selector.charCodeAt(selectorIndex) ===\n                            40 /* LeftParenthesis */\n                            ? readValueWithParenthesis()\n                            : null,\n                    });\n                    continue;\n                }\n                const name = getName(1).toLowerCase();\n                let data = null;\n                if (selector.charCodeAt(selectorIndex) ===\n                    40 /* LeftParenthesis */) {\n                    if (unpackPseudos.has(name)) {\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);\n                        }\n                        data = [];\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n                        if (selector.charCodeAt(selectorIndex) !==\n                            41 /* RightParenthesis */) {\n                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);\n                        }\n                        selectorIndex += 1;\n                    }\n                    else {\n                        data = readValueWithParenthesis();\n                        if (stripQuotesFromPseudos.has(name)) {\n                            const quot = data.charCodeAt(0);\n                            if (quot === data.charCodeAt(data.length - 1) &&\n                                isQuote(quot)) {\n                                data = data.slice(1, -1);\n                            }\n                        }\n                        data = unescapeCSS(data);\n                    }\n                }\n                tokens.push({ type: SelectorType.Pseudo, name, data });\n                break;\n            }\n            case 44 /* Comma */: {\n                finalizeSubselector();\n                tokens = [];\n                stripWhitespace(1);\n                break;\n            }\n            default: {\n                if (selector.startsWith(\"/*\", selectorIndex)) {\n                    const endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n                    if (endIndex < 0) {\n                        throw new Error(\"Comment was not terminated\");\n                    }\n                    selectorIndex = endIndex + 2;\n                    // Remove leading whitespace\n                    if (tokens.length === 0) {\n                        stripWhitespace(0);\n                    }\n                    break;\n                }\n                let namespace = null;\n                let name;\n                if (firstChar === 42 /* Asterisk */) {\n                    selectorIndex += 1;\n                    name = \"*\";\n                }\n                else if (firstChar === 124 /* Pipe */) {\n                    name = \"\";\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n                        addTraversal(SelectorType.ColumnCombinator);\n                        stripWhitespace(2);\n                        break;\n                    }\n                }\n                else if (reName.test(selector.slice(selectorIndex))) {\n                    name = getName(0);\n                }\n                else {\n                    break loop;\n                }\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n                    namespace = name;\n                    if (selector.charCodeAt(selectorIndex + 1) ===\n                        42 /* Asterisk */) {\n                        name = \"*\";\n                        selectorIndex += 2;\n                    }\n                    else {\n                        name = getName(1);\n                    }\n                }\n                tokens.push(name === \"*\"\n                    ? { type: SelectorType.Universal, namespace }\n                    : { type: SelectorType.Tag, name, namespace });\n            }\n        }\n    }\n    finalizeSubselector();\n    return selectorIndex;\n}\n", "import { SelectorType, AttributeAction } from \"./types\";\nconst attribValChars = [\"\\\\\", '\"'];\nconst pseudoValChars = [...attribValChars, \"(\", \")\"];\nconst charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));\nconst charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));\nconst charsToEscapeInName = new Set([\n    ...pseudoValChars,\n    \"~\",\n    \"^\",\n    \"$\",\n    \"*\",\n    \"+\",\n    \"!\",\n    \"|\",\n    \":\",\n    \"[\",\n    \"]\",\n    \" \",\n    \".\",\n].map((c) => c.charCodeAt(0)));\n/**\n * Turns `selector` back into a string.\n *\n * @param selector Selector to stringify.\n */\nexport function stringify(selector) {\n    return selector\n        .map((token) => token.map(stringifyToken).join(\"\"))\n        .join(\", \");\n}\nfunction stringifyToken(token, index, arr) {\n    switch (token.type) {\n        // Simple types\n        case SelectorType.Child:\n            return index === 0 ? \"> \" : \" > \";\n        case SelectorType.Parent:\n            return index === 0 ? \"< \" : \" < \";\n        case SelectorType.Sibling:\n            return index === 0 ? \"~ \" : \" ~ \";\n        case SelectorType.Adjacent:\n            return index === 0 ? \"+ \" : \" + \";\n        case SelectorType.Descendant:\n            return \" \";\n        case SelectorType.ColumnCombinator:\n            return index === 0 ? \"|| \" : \" || \";\n        case SelectorType.Universal:\n            // Return an empty string if the selector isn't needed.\n            return token.namespace === \"*\" &&\n                index + 1 < arr.length &&\n                \"name\" in arr[index + 1]\n                ? \"\"\n                : `${getNamespace(token.namespace)}*`;\n        case SelectorType.Tag:\n            return getNamespacedName(token);\n        case SelectorType.PseudoElement:\n            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null\n                ? \"\"\n                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;\n        case SelectorType.Pseudo:\n            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null\n                ? \"\"\n                : `(${typeof token.data === \"string\"\n                    ? escapeName(token.data, charsToEscapeInPseudoValue)\n                    : stringify(token.data)})`}`;\n        case SelectorType.Attribute: {\n            if (token.name === \"id\" &&\n                token.action === AttributeAction.Equals &&\n                token.ignoreCase === \"quirks\" &&\n                !token.namespace) {\n                return `#${escapeName(token.value, charsToEscapeInName)}`;\n            }\n            if (token.name === \"class\" &&\n                token.action === AttributeAction.Element &&\n                token.ignoreCase === \"quirks\" &&\n                !token.namespace) {\n                return `.${escapeName(token.value, charsToEscapeInName)}`;\n            }\n            const name = getNamespacedName(token);\n            if (token.action === AttributeAction.Exists) {\n                return `[${name}]`;\n            }\n            return `[${name}${getActionValue(token.action)}=\"${escapeName(token.value, charsToEscapeInAttributeValue)}\"${token.ignoreCase === null ? \"\" : token.ignoreCase ? \" i\" : \" s\"}]`;\n        }\n    }\n}\nfunction getActionValue(action) {\n    switch (action) {\n        case AttributeAction.Equals:\n            return \"\";\n        case AttributeAction.Element:\n            return \"~\";\n        case AttributeAction.Start:\n            return \"^\";\n        case AttributeAction.End:\n            return \"$\";\n        case AttributeAction.Any:\n            return \"*\";\n        case AttributeAction.Not:\n            return \"!\";\n        case AttributeAction.Hyphen:\n            return \"|\";\n        case AttributeAction.Exists:\n            throw new Error(\"Shouldn't be here\");\n    }\n}\nfunction getNamespacedName(token) {\n    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;\n}\nfunction getNamespace(namespace) {\n    return namespace !== null\n        ? `${namespace === \"*\"\n            ? \"*\"\n            : escapeName(namespace, charsToEscapeInName)}|`\n        : \"\";\n}\nfunction escapeName(str, charsToEscape) {\n    let lastIdx = 0;\n    let ret = \"\";\n    for (let i = 0; i < str.length; i++) {\n        if (charsToEscape.has(str.charCodeAt(i))) {\n            ret += `${str.slice(lastIdx, i)}\\\\${str.charAt(i)}`;\n            lastIdx = i + 1;\n        }\n    }\n    return ret.length > 0 ? ret + str.slice(lastIdx) : str;\n}\n", "function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst dedent = createDedent({});\nexport default dedent;\nfunction createDedent(options) {\n  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n  return dedent;\n  function dedent(strings, ...values) {\n    const raw = typeof strings === \"string\" ? [strings] : strings.raw;\n    const {\n      escapeSpecialCharacters = Array.isArray(strings),\n      trimWhitespace = true\n    } = options;\n\n    // first, perform interpolation\n    let result = \"\";\n    for (let i = 0; i < raw.length; i++) {\n      let next = raw[i];\n      if (escapeSpecialCharacters) {\n        // handle escaped newlines, backticks, and interpolation characters\n        next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\\\{/g, \"{\");\n      }\n      result += next;\n      if (i < values.length) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += values[i];\n      }\n    }\n\n    // now strip indentation\n    const lines = result.split(\"\\n\");\n    let mindent = null;\n    for (const l of lines) {\n      const m = l.match(/^(\\s+)\\S+/);\n      if (m) {\n        const indent = m[1].length;\n        if (!mindent) {\n          // this is the first indented line\n          mindent = indent;\n        } else {\n          mindent = Math.min(mindent, indent);\n        }\n      }\n    }\n    if (mindent !== null) {\n      const m = mindent; // appease TypeScript\n      result = lines\n      // https://github.com/typescript-eslint/typescript-eslint/issues/7140\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      .map(l => l[0] === \" \" || l[0] === \"\\t\" ? l.slice(m) : l).join(\"\\n\");\n    }\n\n    // dedent eats leading and trailing whitespace too\n    if (trimWhitespace) {\n      result = result.trim();\n    }\n\n    // handle escaped newlines at the end to ensure they don't get stripped too\n    if (escapeSpecialCharacters) {\n      result = result.replace(/\\\\n/g, \"\\n\");\n    }\n    return result;\n  }\n}\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import { __read } from \"tslib\";\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nexport var lexicalAnalysis = function (str, index) {\n    if (index === void 0) { index = 0; }\n    str = str.replace(weirdNewlines, '\\n').replace(nullOrSurrogates, '\\uFFFD');\n    str = str.replace(commentRegex, '');\n    var tokens = [];\n    for (; index < str.length; index += 1) {\n        var code = str.charCodeAt(index);\n        if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            var code_1 = str.charCodeAt(++index);\n            while (code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a) {\n                code_1 = str.charCodeAt(++index);\n            }\n            index -= 1;\n            tokens.push({\n                type: '<whitespace-token>'\n            });\n        }\n        else if (code === 0x0022) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            tokens.push({\n                type: '<string-token>',\n                value: value\n            });\n            index = lastIndex;\n        }\n        else if (code === 0x0023) {\n            if (index + 1 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                if (nextCode === 0x005f ||\n                    (nextCode >= 0x0041 && nextCode <= 0x005a) ||\n                    (nextCode >= 0x0061 && nextCode <= 0x007a) ||\n                    nextCode >= 0x0080 ||\n                    (nextCode >= 0x0030 && nextCode <= 0x0039) ||\n                    (nextCode === 0x005c &&\n                        index + 2 < str.length &&\n                        str.charCodeAt(index + 2) !== 0x000a)) {\n                    var flag = wouldStartIdentifier(str, index + 1)\n                        ? 'id'\n                        : 'unrestricted';\n                    var result = consumeIdentUnsafe(str, index + 1);\n                    if (result !== null) {\n                        var _b = __read(result, 2), lastIndex = _b[0], value = _b[1];\n                        tokens.push({\n                            type: '<hash-token>',\n                            value: value.toLowerCase(),\n                            flag: flag\n                        });\n                        index = lastIndex;\n                        continue;\n                    }\n                }\n            }\n            tokens.push({ type: '<delim-token>', value: code });\n        }\n        else if (code === 0x0027) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];\n            tokens.push({\n                type: '<string-token>',\n                value: value\n            });\n            index = lastIndex;\n        }\n        else if (code === 0x0028) {\n            tokens.push({ type: '<(-token>' });\n        }\n        else if (code === 0x0029) {\n            tokens.push({ type: '<)-token>' });\n        }\n        else if (code === 0x002b) {\n            var plusNumeric = consumeNumeric(str, index);\n            if (plusNumeric === null) {\n                tokens.push({\n                    type: '<delim-token>',\n                    value: code\n                });\n            }\n            else {\n                var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];\n                if (tokenTuple[0] === '<dimension-token>') {\n                    tokens.push({\n                        type: '<dimension-token>',\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: 'number'\n                    });\n                }\n                else if (tokenTuple[0] === '<number-token>') {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: 'number'\n                    });\n                }\n                index = lastIndex;\n            }\n        }\n        else if (code === 0x002c) {\n            tokens.push({ type: '<comma-token>' });\n        }\n        else if (code === 0x002d) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric !== null) {\n                var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];\n                if (tokenTuple[0] === '<dimension-token>') {\n                    tokens.push({\n                        type: '<dimension-token>',\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: 'number'\n                    });\n                }\n                else if (tokenTuple[0] === '<number-token>') {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: 'number'\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n            if (index + 2 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                if (nextCode === 0x002d && nextNextCode === 0x003e) {\n                    tokens.push({\n                        type: '<CDC-token>'\n                    });\n                    index += 2;\n                    continue;\n                }\n            }\n            var result = consumeIdentLike(str, index);\n            if (result !== null) {\n                var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];\n                tokens.push({\n                    type: type,\n                    value: value\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({\n                type: '<delim-token>',\n                value: code\n            });\n        }\n        else if (code === 0x002e) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric === null) {\n                tokens.push({\n                    type: '<delim-token>',\n                    value: code\n                });\n            }\n            else {\n                var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];\n                if (tokenTuple[0] === '<dimension-token>') {\n                    tokens.push({\n                        type: '<dimension-token>',\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: 'number'\n                    });\n                }\n                else if (tokenTuple[0] === '<number-token>') {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: 'number'\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n        }\n        else if (code === 0x003a) {\n            tokens.push({ type: '<colon-token>' });\n        }\n        else if (code === 0x003b) {\n            tokens.push({ type: '<semicolon-token>' });\n        }\n        else if (code === 0x003c) {\n            if (index + 3 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                var nextNextNextCode = str.charCodeAt(index + 3);\n                if (nextCode === 0x0021 &&\n                    nextNextCode === 0x002d &&\n                    nextNextNextCode === 0x002d) {\n                    tokens.push({\n                        type: '<CDO-token>'\n                    });\n                    index += 3;\n                    continue;\n                }\n            }\n            tokens.push({\n                type: '<delim-token>',\n                value: code\n            });\n        }\n        else if (code === 0x0040) {\n            var result = consumeIdent(str, index + 1);\n            if (result !== null) {\n                var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];\n                tokens.push({\n                    type: '<at-keyword-token>',\n                    value: value.toLowerCase()\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({ type: '<delim-token>', value: code });\n        }\n        else if (code === 0x005b) {\n            tokens.push({ type: '<[-token>' });\n        }\n        else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];\n            str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n            index -= 1;\n        }\n        else if (code === 0x005d) {\n            tokens.push({ type: '<]-token>' });\n        }\n        else if (code === 0x007b) {\n            tokens.push({ type: '<{-token>' });\n        }\n        else if (code === 0x007d) {\n            tokens.push({ type: '<}-token>' });\n        }\n        else if (code >= 0x0030 && code <= 0x0039) {\n            var result = consumeNumeric(str, index);\n            var _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];\n            if (tokenTuple[0] === '<dimension-token>') {\n                tokens.push({\n                    type: '<dimension-token>',\n                    value: tokenTuple[1],\n                    unit: tokenTuple[2].toLowerCase(),\n                    flag: 'number'\n                });\n            }\n            else if (tokenTuple[0] === '<number-token>') {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: tokenTuple[2]\n                });\n            }\n            else {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: 'number'\n                });\n            }\n            index = lastIndex;\n        }\n        else if (code === 0x005f ||\n            (code >= 0x0041 && code <= 0x005a) ||\n            (code >= 0x0061 && code <= 0x007a) ||\n            code >= 0x0080) {\n            var result = consumeIdentLike(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];\n            tokens.push({\n                type: type,\n                value: value\n            });\n            index = lastIndex;\n        }\n        else {\n            tokens.push({ type: '<delim-token>', value: code });\n        }\n    }\n    tokens.push({ type: '<EOF-token>' });\n    return tokens;\n};\nexport var consumeString = function (str, index) {\n    if (str.length <= index + 1)\n        return null;\n    var firstCode = str.charCodeAt(index);\n    var charCodes = [];\n    for (var i = index + 1; i < str.length; i += 1) {\n        var code = str.charCodeAt(i);\n        if (code === firstCode) {\n            return [i, String.fromCharCode.apply(null, charCodes)];\n        }\n        else if (code === 0x005c) {\n            var result = consumeEscape(str, i);\n            if (result === null)\n                return null;\n            var _a = __read(result, 2), lastIndex = _a[0], charCode = _a[1];\n            charCodes.push(charCode);\n            i = lastIndex;\n        }\n        else if (code === 0x000a) {\n            return null;\n        }\n        else {\n            charCodes.push(code);\n        }\n    }\n    return null;\n};\nexport var wouldStartIdentifier = function (str, index) {\n    if (str.length <= index)\n        return false;\n    var code = str.charCodeAt(index);\n    if (code === 0x002d) {\n        if (str.length <= index + 1)\n            return false;\n        var nextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002d ||\n            nextCode === 0x005f ||\n            (nextCode >= 0x0041 && nextCode <= 0x005a) ||\n            (nextCode >= 0x0061 && nextCode <= 0x007a) ||\n            nextCode >= 0x0080) {\n            return true;\n        }\n        else if (nextCode === 0x005c) {\n            if (str.length <= index + 2)\n                return false;\n            var nextNextCode = str.charCodeAt(index + 2);\n            return nextNextCode !== 0x000a;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (code === 0x005f ||\n        (code >= 0x0041 && code <= 0x005a) ||\n        (code >= 0x0061 && code <= 0x007a) ||\n        code >= 0x0080) {\n        return true;\n    }\n    else if (code === 0x005c) {\n        if (str.length <= index + 1)\n            return false;\n        var nextCode = str.charCodeAt(index + 1);\n        return nextCode !== 0x000a;\n    }\n    else {\n        return false;\n    }\n};\nexport var consumeEscape = function (str, index) {\n    if (str.length <= index + 1)\n        return null;\n    if (str.charCodeAt(index) !== 0x005c)\n        return null;\n    var code = str.charCodeAt(index + 1);\n    if (code === 0x000a) {\n        return null;\n    }\n    else if ((code >= 0x0030 && code <= 0x0039) ||\n        (code >= 0x0041 && code <= 0x0046) ||\n        (code >= 0x0061 && code <= 0x0066)) {\n        var hexCharCodes = [code];\n        var min = Math.min(index + 7, str.length);\n        var i = index + 2;\n        for (; i < min; i += 1) {\n            var code_2 = str.charCodeAt(i);\n            if ((code_2 >= 0x0030 && code_2 <= 0x0039) ||\n                (code_2 >= 0x0041 && code_2 <= 0x0046) ||\n                (code_2 >= 0x0061 && code_2 <= 0x0066)) {\n                hexCharCodes.push(code_2);\n            }\n            else {\n                break;\n            }\n        }\n        if (i < str.length) {\n            var code_3 = str.charCodeAt(i);\n            if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n                i += 1;\n            }\n        }\n        return [i - 1, parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)];\n    }\n    else {\n        return [index + 1, code];\n    }\n};\nexport var consumeNumeric = function (str, index) {\n    var numberResult = consumeNumber(str, index);\n    if (numberResult === null)\n        return null;\n    var _a = __read(numberResult, 3), numberEndIndex = _a[0], numberValue = _a[1], numberFlag = _a[2];\n    var identResult = consumeIdent(str, numberEndIndex + 1);\n    if (identResult !== null) {\n        var _b = __read(identResult, 2), identEndIndex = _b[0], identValue = _b[1];\n        return [identEndIndex, ['<dimension-token>', numberValue, identValue]];\n    }\n    if (numberEndIndex + 1 < str.length &&\n        str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n        return [numberEndIndex + 1, ['<percentage-token>', numberValue]];\n    }\n    return [numberEndIndex, ['<number-token>', numberValue, numberFlag]];\n};\nexport var consumeNumber = function (str, index) {\n    if (str.length <= index)\n        return null;\n    var flag = 'integer';\n    var numberChars = [];\n    var firstCode = str.charCodeAt(index);\n    if (firstCode === 0x002b || firstCode === 0x002d) {\n        index += 1;\n        if (firstCode === 0x002d)\n            numberChars.push(0x002d);\n    }\n    while (index < str.length) {\n        var code = str.charCodeAt(index);\n        if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n        }\n        else {\n            break;\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002e &&\n            nextNextCode >= 0x0030 &&\n            nextNextCode <= 0x0039) {\n            numberChars.push(nextCode, nextNextCode);\n            flag = 'number';\n            index += 2;\n            while (index < str.length) {\n                var code = str.charCodeAt(index);\n                if (code >= 0x0030 && code <= 0x0039) {\n                    numberChars.push(code);\n                    index += 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        var nextNextNextCode = str.charCodeAt(index + 2);\n        if (nextCode === 0x0045 || nextCode === 0x0065) {\n            var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n            if (nextNextIsDigit ||\n                ((nextNextCode === 0x002b || nextNextCode === 0x002d) &&\n                    nextNextNextCode >= 0x0030 &&\n                    nextNextNextCode <= 0x0039)) {\n                flag = 'number';\n                if (nextNextIsDigit) {\n                    numberChars.push(0x0045, nextNextCode);\n                    index += 2;\n                }\n                else if (nextNextCode === 0x002d) {\n                    numberChars.push(0x0045, 0x002d, nextNextNextCode);\n                    index += 3;\n                }\n                else {\n                    numberChars.push(0x0045, nextNextNextCode);\n                    index += 3;\n                }\n                while (index < str.length) {\n                    var code = str.charCodeAt(index);\n                    if (code >= 0x0030 && code <= 0x0039) {\n                        numberChars.push(code);\n                        index += 1;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    var numberString = String.fromCharCode.apply(null, numberChars);\n    var value = flag === 'number' ? parseFloat(numberString) : parseInt(numberString);\n    if (value === -0)\n        value = 0;\n    return Number.isNaN(value) ? null : [index - 1, value, flag];\n};\nexport var consumeIdentUnsafe = function (str, index) {\n    if (str.length <= index) {\n        return null;\n    }\n    var identChars = [];\n    for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n        if (code === 0x002d ||\n            code === 0x005f ||\n            (code >= 0x0041 && code <= 0x005a) ||\n            (code >= 0x0061 && code <= 0x007a) ||\n            code >= 0x0080 ||\n            (code >= 0x0030 && code <= 0x0039)) {\n            identChars.push(code);\n            continue;\n        }\n        else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_4 = _a[1];\n                identChars.push(code_4);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return index === 0\n        ? null\n        : [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nexport var consumeIdent = function (str, index) {\n    if (str.length <= index || !wouldStartIdentifier(str, index)) {\n        return null;\n    }\n    var identChars = [];\n    for (var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)) {\n        if (code === 0x002d ||\n            code === 0x005f ||\n            (code >= 0x0041 && code <= 0x005a) ||\n            (code >= 0x0061 && code <= 0x007a) ||\n            code >= 0x0080 ||\n            (code >= 0x0030 && code <= 0x0039)) {\n            identChars.push(code);\n            continue;\n        }\n        else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_5 = _a[1];\n                identChars.push(code_5);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return [index - 1, String.fromCharCode.apply(null, identChars)];\n};\nexport var consumeUrl = function (str, index) {\n    var code = str.charCodeAt(index);\n    while (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n        code = str.charCodeAt(++index);\n    }\n    var urlChars = [];\n    var hasFinishedWord = false;\n    while (index < str.length) {\n        if (code === 0x0029) {\n            return [index, String.fromCharCode.apply(null, urlChars)];\n        }\n        else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n            return null;\n        }\n        else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            if (!hasFinishedWord && urlChars.length !== 0)\n                hasFinishedWord = true;\n        }\n        else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null || hasFinishedWord)\n                return null;\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            urlChars.push(value);\n            index = lastIndex;\n        }\n        else {\n            if (hasFinishedWord)\n                return null;\n            urlChars.push(code);\n        }\n        code = str.charCodeAt(++index);\n    }\n    return null;\n};\nexport var consumeIdentLike = function (str, index) {\n    var result = consumeIdent(str, index);\n    if (result === null)\n        return null;\n    var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n    if (value.toLowerCase() === 'url') {\n        if (str.length > lastIndex + 1) {\n            var nextCode = str.charCodeAt(lastIndex + 1);\n            if (nextCode === 0x0028) {\n                for (var offset = 2; lastIndex + offset < str.length; offset += 1) {\n                    var nextNextCode = str.charCodeAt(lastIndex + offset);\n                    if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n                        return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n                    }\n                    else if (nextNextCode !== 0x0009 &&\n                        nextNextCode !== 0x0020 &&\n                        nextNextCode !== 0x000a) {\n                        var result_1 = consumeUrl(str, lastIndex + offset);\n                        if (result_1 === null)\n                            return null;\n                        var _b = __read(result_1, 2), lastUrlIndex = _b[0], value_1 = _b[1];\n                        return [lastUrlIndex, value_1, '<url-token>'];\n                    }\n                }\n                return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n            }\n        }\n    }\n    else if (str.length > lastIndex + 1) {\n        var nextCode = str.charCodeAt(lastIndex + 1);\n        if (nextCode === 0x0028) {\n            return [lastIndex + 1, value.toLowerCase(), '<function-token>'];\n        }\n    }\n    return [lastIndex, value.toLowerCase(), '<ident-token>'];\n};\n//# sourceMappingURL=lexicalAnalysis.js.map", "export var simplifyAST = function (ast) {\n    for (var i = ast.length - 1; i >= 0; i--) {\n        ast[i] = simplifyMediaQuery(ast[i]);\n    }\n    return ast;\n};\nvar simplifyMediaQuery = function (mediaQuery) {\n    if (mediaQuery.mediaCondition === null)\n        return mediaQuery;\n    var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n    if (mediaCondition.operator === null &&\n        mediaCondition.children.length === 1 &&\n        'children' in mediaCondition.children[0]) {\n        mediaCondition = mediaCondition.children[0];\n    }\n    return {\n        mediaPrefix: mediaQuery.mediaPrefix,\n        mediaType: mediaQuery.mediaType,\n        mediaCondition: mediaCondition\n    };\n};\nvar simplifyMediaCondition = function (mediaCondition) {\n    for (var i = mediaCondition.children.length - 1; i >= 0; i--) {\n        var unsimplifiedChild = mediaCondition.children[i];\n        if (!('context' in unsimplifiedChild)) {\n            var child = simplifyMediaCondition(unsimplifiedChild);\n            if (child.operator === null && child.children.length === 1) {\n                mediaCondition.children[i] = child.children[0];\n            }\n            else if (child.operator === mediaCondition.operator &&\n                (child.operator === 'and' || child.operator === 'or')) {\n                var spliceArgs = [i, 1];\n                for (var i_1 = 0; i_1 < child.children.length; i_1++) {\n                    spliceArgs.push(child.children[i_1]);\n                }\n                mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n            }\n        }\n    }\n    return mediaCondition;\n};\n//# sourceMappingURL=simplifyAST.js.map", "import { __assign, __rest, __values } from \"tslib\";\nimport { lexicalAnalysis } from './lexicalAnalysis';\nimport { simplifyAST } from './simplifyAST';\nvar createError = function (message, err) {\n    if (err instanceof Error) {\n        return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n    }\n    else {\n        return new Error(message.trim());\n    }\n};\nexport var toAST = function (str) {\n    return simplifyAST(toUnflattenedAST(str));\n};\nexport var toUnflattenedAST = function (str) {\n    var tokenList = lexicalAnalysis(str.trim());\n    if (tokenList === null) {\n        throw createError('Failed tokenizing');\n    }\n    var startIndex = 0;\n    var endIndex = tokenList.length - 1;\n    if (tokenList[0].type === '<at-keyword-token>' &&\n        tokenList[0].value === 'media') {\n        if (tokenList[1].type !== '<whitespace-token>') {\n            throw createError('Expected whitespace after media');\n        }\n        startIndex = 2;\n        for (var i = 2; i < tokenList.length - 1; i++) {\n            var token = tokenList[i];\n            if (token.type === '<{-token>') {\n                endIndex = i;\n                break;\n            }\n            else if (token.type === '<semicolon-token>') {\n                throw createError(\"Expected '{' in media query but found ';'\");\n            }\n        }\n    }\n    tokenList = tokenList.slice(startIndex, endIndex);\n    return syntacticAnalysis(tokenList);\n};\nexport var removeWhitespace = function (tokenList) {\n    var newTokenList = [];\n    var before = false;\n    for (var i = 0; i < tokenList.length; i++) {\n        if (tokenList[i].type === '<whitespace-token>') {\n            before = true;\n            if (newTokenList.length > 0) {\n                newTokenList[newTokenList.length - 1].wsAfter = true;\n            }\n        }\n        else {\n            newTokenList.push(__assign(__assign({}, tokenList[i]), { wsBefore: before, wsAfter: false }));\n            before = false;\n        }\n    }\n    return newTokenList;\n};\nexport var syntacticAnalysis = function (tokenList) {\n    var e_1, _a;\n    var mediaQueryList = [[]];\n    for (var i = 0; i < tokenList.length; i++) {\n        var token = tokenList[i];\n        if (token.type === '<comma-token>') {\n            mediaQueryList.push([]);\n        }\n        else {\n            mediaQueryList[mediaQueryList.length - 1].push(token);\n        }\n    }\n    var mediaQueries = mediaQueryList.map(removeWhitespace);\n    if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n        return [{ mediaCondition: null, mediaPrefix: null, mediaType: 'all' }];\n    }\n    else {\n        var mediaQueryTokens = mediaQueries.map(function (mediaQueryTokens) {\n            if (mediaQueryTokens.length === 0) {\n                return null;\n            }\n            else {\n                return tokenizeMediaQuery(mediaQueryTokens);\n            }\n        });\n        var nonNullMediaQueryTokens = [];\n        try {\n            for (var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()) {\n                var mediaQueryToken = mediaQueryTokens_1_1.value;\n                if (mediaQueryToken !== null) {\n                    nonNullMediaQueryTokens.push(mediaQueryToken);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1.return)) _a.call(mediaQueryTokens_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (nonNullMediaQueryTokens.length === 0) {\n            throw createError('No valid media queries');\n        }\n        return nonNullMediaQueryTokens;\n    }\n};\nexport var tokenizeMediaQuery = function (tokens) {\n    var firstToken = tokens[0];\n    if (firstToken.type === '<(-token>') {\n        try {\n            return {\n                mediaPrefix: null,\n                mediaType: 'all',\n                mediaCondition: tokenizeMediaCondition(tokens, true)\n            };\n        }\n        catch (err) {\n            throw createError(\"Expected media condition after '('\", err);\n        }\n    }\n    else if (firstToken.type === '<ident-token>') {\n        var mediaPrefix = null;\n        var mediaType = void 0;\n        var value = firstToken.value;\n        if (value === 'only' || value === 'not') {\n            mediaPrefix = value;\n        }\n        var firstIndex = mediaPrefix === null ? 0 : 1;\n        if (tokens.length <= firstIndex) {\n            throw createError(\"Expected extra token in media query\");\n        }\n        var firstNonUnaryToken = tokens[firstIndex];\n        if (firstNonUnaryToken.type === '<ident-token>') {\n            var value_1 = firstNonUnaryToken.value;\n            if (value_1 === 'all') {\n                mediaType = 'all';\n            }\n            else if (value_1 === 'print' || value_1 === 'screen') {\n                mediaType = value_1;\n            }\n            else if (value_1 === 'tty' ||\n                value_1 === 'tv' ||\n                value_1 === 'projection' ||\n                value_1 === 'handheld' ||\n                value_1 === 'braille' ||\n                value_1 === 'embossed' ||\n                value_1 === 'aural' ||\n                value_1 === 'speech') {\n                mediaPrefix = mediaPrefix === 'not' ? null : 'not';\n                mediaType = 'all';\n            }\n            else {\n                throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n            }\n        }\n        else if (mediaPrefix === 'not' &&\n            firstNonUnaryToken.type === '<(-token>') {\n            var tokensWithParens = [\n                { type: '<(-token>', wsBefore: false, wsAfter: false }\n            ];\n            tokensWithParens.push.apply(tokensWithParens, tokens);\n            tokensWithParens.push({\n                type: '<)-token>',\n                wsBefore: false,\n                wsAfter: false\n            });\n            try {\n                return {\n                    mediaPrefix: null,\n                    mediaType: 'all',\n                    mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n                };\n            }\n            catch (err) {\n                throw createError(\"Expected media condition after '('\", err);\n            }\n        }\n        else {\n            throw createError('Invalid media query');\n        }\n        if (firstIndex + 1 === tokens.length) {\n            return {\n                mediaPrefix: mediaPrefix,\n                mediaType: mediaType,\n                mediaCondition: null\n            };\n        }\n        else if (firstIndex + 4 < tokens.length) {\n            var secondNonUnaryToken = tokens[firstIndex + 1];\n            if (secondNonUnaryToken.type === '<ident-token>' &&\n                secondNonUnaryToken.value === 'and') {\n                try {\n                    return {\n                        mediaPrefix: mediaPrefix,\n                        mediaType: mediaType,\n                        mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n                    };\n                }\n                catch (err) {\n                    throw createError(\"Expected media condition after 'and'\", err);\n                }\n            }\n            else {\n                throw createError(\"Expected 'and' after media prefix\");\n            }\n        }\n        else {\n            throw createError('Expected media condition after media prefix');\n        }\n    }\n    else {\n        throw createError('Expected media condition or media prefix');\n    }\n};\nexport var tokenizeMediaCondition = function (tokens, mayContainOr, previousOperator) {\n    if (previousOperator === void 0) { previousOperator = null; }\n    if (tokens.length < 3 ||\n        tokens[0].type !== '<(-token>' ||\n        tokens[tokens.length - 1].type !== '<)-token>') {\n        throw new Error('Invalid media condition');\n    }\n    var endIndexOfFirstFeature = tokens.length - 1;\n    var maxDepth = 0;\n    var count = 0;\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (token.type === '<(-token>') {\n            count += 1;\n            maxDepth = Math.max(maxDepth, count);\n        }\n        else if (token.type === '<)-token>') {\n            count -= 1;\n        }\n        if (count === 0) {\n            endIndexOfFirstFeature = i;\n            break;\n        }\n    }\n    if (count !== 0) {\n        throw new Error('Mismatched parens\\nInvalid media condition');\n    }\n    var child;\n    var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n    if (maxDepth === 1) {\n        child = tokenizeMediaFeature(featureTokens);\n    }\n    else {\n        if (featureTokens[1].type === '<ident-token>' &&\n            featureTokens[1].value === 'not') {\n            child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, 'not');\n        }\n        else {\n            child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n        }\n    }\n    if (endIndexOfFirstFeature === tokens.length - 1) {\n        return {\n            operator: previousOperator,\n            children: [child]\n        };\n    }\n    else {\n        var nextToken = tokens[endIndexOfFirstFeature + 1];\n        if (nextToken.type !== '<ident-token>') {\n            throw new Error('Invalid operator\\nInvalid media condition');\n        }\n        else if (previousOperator !== null &&\n            previousOperator !== nextToken.value) {\n            throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n        }\n        else if (nextToken.value === 'or' && !mayContainOr) {\n            throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n        }\n        else if (nextToken.value !== 'and' && nextToken.value !== 'or') {\n            throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n        }\n        var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n        return {\n            operator: nextToken.value,\n            children: [child].concat(siblings.children)\n        };\n    }\n};\nexport var tokenizeMediaFeature = function (rawTokens) {\n    if (rawTokens.length < 3 ||\n        rawTokens[0].type !== '<(-token>' ||\n        rawTokens[rawTokens.length - 1].type !== '<)-token>') {\n        throw new Error('Invalid media feature');\n    }\n    var tokens = [rawTokens[0]];\n    for (var i = 1; i < rawTokens.length; i++) {\n        if (i < rawTokens.length - 2) {\n            var a = rawTokens[i];\n            var b = rawTokens[i + 1];\n            var c = rawTokens[i + 2];\n            if (a.type === '<number-token>' &&\n                a.value > 0 &&\n                b.type === '<delim-token>' &&\n                b.value === 0x002f &&\n                c.type === '<number-token>' &&\n                c.value > 0) {\n                tokens.push({\n                    type: '<ratio-token>',\n                    numerator: a.value,\n                    denominator: c.value,\n                    wsBefore: a.wsBefore,\n                    wsAfter: c.wsAfter\n                });\n                i += 2;\n                continue;\n            }\n        }\n        tokens.push(rawTokens[i]);\n    }\n    var nextToken = tokens[1];\n    if (nextToken.type === '<ident-token>' && tokens.length === 3) {\n        return {\n            context: 'boolean',\n            feature: nextToken.value\n        };\n    }\n    else if (tokens.length === 5 &&\n        tokens[1].type === '<ident-token>' &&\n        tokens[2].type === '<colon-token>') {\n        var valueToken = tokens[3];\n        if (valueToken.type === '<number-token>' ||\n            valueToken.type === '<dimension-token>' ||\n            valueToken.type === '<ratio-token>' ||\n            valueToken.type === '<ident-token>') {\n            var feature = tokens[1].value;\n            var prefix = null;\n            var slice = feature.slice(0, 4);\n            if (slice === 'min-') {\n                prefix = 'min';\n                feature = feature.slice(4);\n            }\n            else if (slice === 'max-') {\n                prefix = 'max';\n                feature = feature.slice(4);\n            }\n            var _0 = valueToken.wsBefore, _1 = valueToken.wsAfter, value = __rest(valueToken, [\"wsBefore\", \"wsAfter\"]);\n            return {\n                context: 'value',\n                prefix: prefix,\n                feature: feature,\n                value: value\n            };\n        }\n    }\n    else if (tokens.length >= 5) {\n        try {\n            var range = tokenizeRange(tokens);\n            return {\n                context: 'range',\n                feature: range.featureName,\n                range: range\n            };\n        }\n        catch (err) {\n            throw createError('Invalid media feature', err);\n        }\n    }\n    throw new Error('Invalid media feature');\n};\nexport var tokenizeRange = function (tokens) {\n    var _a, _b, _c, _d;\n    if (tokens.length < 5 ||\n        tokens[0].type !== '<(-token>' ||\n        tokens[tokens.length - 1].type !== '<)-token>') {\n        throw new Error('Invalid range');\n    }\n    var range = {\n        leftToken: null,\n        leftOp: null,\n        featureName: '',\n        rightOp: null,\n        rightToken: null\n    };\n    var hasLeft = tokens[1].type === '<number-token>' ||\n        tokens[1].type === '<dimension-token>' ||\n        tokens[1].type === '<ratio-token>' ||\n        (tokens[1].type === '<ident-token>' && tokens[1].value === 'infinite');\n    if (tokens[2].type === '<delim-token>') {\n        if (tokens[2].value === 0x003c) {\n            if (tokens[3].type === '<delim-token>' &&\n                tokens[3].value === 0x003d &&\n                !tokens[3].wsBefore) {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '<=';\n            }\n            else {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '<';\n            }\n        }\n        else if (tokens[2].value === 0x003e) {\n            if (tokens[3].type === '<delim-token>' &&\n                tokens[3].value === 0x003d &&\n                !tokens[3].wsBefore) {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '>=';\n            }\n            else {\n                range[hasLeft ? 'leftOp' : 'rightOp'] = '>';\n            }\n        }\n        else if (tokens[2].value === 0x003d) {\n            range[hasLeft ? 'leftOp' : 'rightOp'] = '=';\n        }\n        else {\n            throw new Error('Invalid range');\n        }\n        if (hasLeft) {\n            range.leftToken = tokens[1];\n        }\n        else if (tokens[1].type === '<ident-token>') {\n            range.featureName = tokens[1].value;\n        }\n        else {\n            throw new Error('Invalid range');\n        }\n        var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? 'leftOp' : 'rightOp']) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n        if (hasLeft) {\n            if (tokenAfterFirstOp.type === '<ident-token>') {\n                range.featureName = tokenAfterFirstOp.value;\n                if (tokens.length >= 7) {\n                    var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n                    var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n                    if (secondOpToken.type === '<delim-token>') {\n                        var charCode = secondOpToken.value;\n                        if (charCode === 0x003c) {\n                            if (followingToken.type === '<delim-token>' &&\n                                followingToken.value === 0x003d &&\n                                !followingToken.wsBefore) {\n                                range.rightOp = '<=';\n                            }\n                            else {\n                                range.rightOp = '<';\n                            }\n                        }\n                        else if (charCode === 0x003e) {\n                            if (followingToken.type === '<delim-token>' &&\n                                followingToken.value === 0x003d &&\n                                !followingToken.wsBefore) {\n                                range.rightOp = '>=';\n                            }\n                            else {\n                                range.rightOp = '>';\n                            }\n                        }\n                        else {\n                            throw new Error('Invalid range');\n                        }\n                        var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n                        range.rightToken = tokenAfterSecondOp;\n                    }\n                    else {\n                        throw new Error('Invalid range');\n                    }\n                }\n                else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n                    throw new Error('Invalid range');\n                }\n            }\n            else {\n                throw new Error('Invalid range');\n            }\n        }\n        else {\n            range.rightToken = tokenAfterFirstOp;\n        }\n        var validRange = null;\n        var lt = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt = range.rightToken;\n        var leftToken = null;\n        if (lt !== null) {\n            if (lt.type === '<ident-token>') {\n                var type = lt.type, value = lt.value;\n                if (value === 'infinite') {\n                    leftToken = { type: type, value: value };\n                }\n            }\n            else if (lt.type === '<number-token>' ||\n                lt.type === '<dimension-token>' ||\n                lt.type === '<ratio-token>') {\n                var _0 = lt.wsBefore, _1 = lt.wsAfter, ltNoWS = __rest(lt, [\"wsBefore\", \"wsAfter\"]);\n                leftToken = ltNoWS;\n            }\n        }\n        var rightToken = null;\n        if (rt !== null) {\n            if (rt.type === '<ident-token>') {\n                var type = rt.type, value = rt.value;\n                if (value === 'infinite') {\n                    rightToken = { type: type, value: value };\n                }\n            }\n            else if (rt.type === '<number-token>' ||\n                rt.type === '<dimension-token>' ||\n                rt.type === '<ratio-token>') {\n                var _0 = rt.wsBefore, _1 = rt.wsAfter, rtNoWS = __rest(rt, [\"wsBefore\", \"wsAfter\"]);\n                rightToken = rtNoWS;\n            }\n        }\n        if (leftToken !== null && rightToken !== null) {\n            if ((leftOp === '<' || leftOp === '<=') &&\n                (rightOp === '<' || rightOp === '<=')) {\n                validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n            }\n            else if ((leftOp === '>' || leftOp === '>=') &&\n                (rightOp === '>' || rightOp === '>=')) {\n                validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n            }\n            else {\n                throw new Error('Invalid range');\n            }\n        }\n        else if (leftToken === null &&\n            leftOp === null &&\n            rightOp !== null &&\n            rightToken !== null) {\n            validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n        }\n        else if (leftToken !== null &&\n            leftOp !== null &&\n            rightOp === null &&\n            rightToken === null) {\n            validRange = { leftToken: leftToken, leftOp: leftOp, featureName: featureName, rightOp: rightOp, rightToken: rightToken };\n        }\n        return validRange;\n    }\n    else {\n        throw new Error('Invalid range');\n    }\n};\n//# sourceMappingURL=syntacticAnalysis.js.map", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "import { injectStyles } from '../injectStyles/dist/vanilla-extract-css-injectStyles.browser.esm.js';\nimport { t as transformCss, _ as _objectSpread2, a as _objectWithoutProperties, d as dudupeAndJoinClassList } from './transformCss-830a230d.browser.esm.js';\nimport { setAdapterIfNotSet, getIdentOption, appendCss, registerClassName, registerComposition, markCompositionUsed } from '../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';\nimport hash from '@emotion/hash';\nimport { getAndIncrementRefCounter, getFileScope, hasFileScope } from '../fileScope/dist/vanilla-extract-css-fileScope.browser.esm.js';\nimport { LRUCache } from 'lru-cache';\nimport { walkObject, get } from '@vanilla-extract/private';\nimport cssesc from 'cssesc';\nimport { diff } from 'deep-object-diff';\nimport pc from 'picocolors';\nimport { _ as _taggedTemplateLiteral } from './taggedTemplateLiteral-8e47dbd7.browser.esm.js';\nimport dedent from 'dedent';\nimport deepmerge from 'deepmerge';\nimport 'modern-ahocorasick';\nimport 'css-what';\nimport 'media-query-parser';\n\nvar localClassNames = new Set();\nvar composedClassLists = [];\nvar bufferedCSSObjs = [];\nvar browserRuntimeAdapter = {\n  appendCss: cssObj => {\n    bufferedCSSObjs.push(cssObj);\n  },\n  registerClassName: className => {\n    localClassNames.add(className);\n  },\n  registerComposition: composition => {\n    composedClassLists.push(composition);\n  },\n  markCompositionUsed: () => {},\n  onEndFileScope: fileScope => {\n    var css = transformCss({\n      localClassNames: Array.from(localClassNames),\n      composedClassLists,\n      cssObjs: bufferedCSSObjs\n    }).join('\\n');\n    injectStyles({\n      fileScope,\n      css\n    });\n    bufferedCSSObjs = [];\n  },\n  getIdentOption: () => process.env.NODE_ENV === 'production' ? 'short' : 'debug'\n};\n{\n  setAdapterIfNotSet(browserRuntimeAdapter);\n}\n\nvar getLastSlashBeforeIndex = (path, index) => {\n  var pathIndex = index - 1;\n  while (pathIndex >= 0) {\n    if (path[pathIndex] === '/') {\n      return pathIndex;\n    }\n    pathIndex--;\n  }\n  return -1;\n};\n\n/**\n * Assumptions:\n * - The path is always normalized to use posix file separators (/) (see `addFileScope`)\n * - The path is always relative to the project root, i.e. there will never be a leading slash (see `addFileScope`)\n * - As long as `.css` is there, we have a valid `.css.*` file path, because otherwise there wouldn't\n *   be a file scope to begin with\n *\n * The LRU cache we use can't cache undefined/null values, so we opt to return an empty string,\n * rather than using a custom Symbol or something similar.\n */\nvar _getDebugFileName = path => {\n  var file;\n  var lastIndexOfDotCss = path.lastIndexOf('.css');\n  if (lastIndexOfDotCss === -1) {\n    return '';\n  }\n  var lastSlashIndex = getLastSlashBeforeIndex(path, lastIndexOfDotCss);\n  file = path.slice(lastSlashIndex + 1, lastIndexOfDotCss);\n\n  // There are no slashes, therefore theres no directory to extract\n  if (lastSlashIndex === -1) {\n    return file;\n  }\n  var secondLastSlashIndex = getLastSlashBeforeIndex(path, lastSlashIndex - 1);\n  // If secondLastSlashIndex is -1, it means that the path looks like `directory/file.css.ts`,\n  // in which case dir will still be sliced starting at 0, which is what we want\n  var dir = path.slice(secondLastSlashIndex + 1, lastSlashIndex);\n  var debugFileName = file !== 'index' ? file : dir;\n  return debugFileName;\n};\nvar memoizedGetDebugFileName = () => {\n  var cache = new LRUCache({\n    max: 500\n  });\n  return path => {\n    var cachedResult = cache.get(path);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = _getDebugFileName(path);\n    cache.set(path, result);\n    return result;\n  };\n};\nvar getDebugFileName = memoizedGetDebugFileName();\n\nfunction getDevPrefix(_ref) {\n  var {\n    debugId,\n    debugFileName\n  } = _ref;\n  var parts = debugId ? [debugId.replace(/\\s/g, '_')] : [];\n  if (debugFileName) {\n    var {\n      filePath\n    } = getFileScope();\n    var _debugFileName = getDebugFileName(filePath);\n\n    // debugFileName could be an empty string\n    if (_debugFileName) {\n      parts.unshift(_debugFileName);\n    }\n  }\n  return parts.join('_');\n}\nfunction normalizeIdentifier(identifier) {\n  return identifier.match(/^[0-9]/) ? \"_\".concat(identifier) : identifier;\n}\nfunction generateIdentifier(arg) {\n  var identOption = getIdentOption();\n  var {\n    debugId,\n    debugFileName = true\n  } = _objectSpread2(_objectSpread2({}, typeof arg === 'string' ? {\n    debugId: arg\n  } : null), typeof arg === 'object' ? arg : null);\n\n  // Convert ref count to base 36 for optimal hash lengths\n  var refCount = getAndIncrementRefCounter().toString(36);\n  var {\n    filePath,\n    packageName\n  } = getFileScope();\n  var fileScopeHash = hash(packageName ? \"\".concat(packageName).concat(filePath) : filePath);\n  var identifier = \"\".concat(fileScopeHash).concat(refCount);\n  if (identOption === 'debug') {\n    var devPrefix = getDevPrefix({\n      debugId,\n      debugFileName\n    });\n    if (devPrefix) {\n      identifier = \"\".concat(devPrefix, \"__\").concat(identifier);\n    }\n    return normalizeIdentifier(identifier);\n  }\n  if (typeof identOption === 'function') {\n    identifier = identOption({\n      hash: identifier,\n      debugId,\n      filePath,\n      packageName\n    });\n    if (!identifier.match(/^[A-Z_][0-9A-Z_-]+$/i)) {\n      throw new Error(\"Identifier function returned invalid indentifier: \\\"\".concat(identifier, \"\\\"\"));\n    }\n    return identifier;\n  }\n  return normalizeIdentifier(identifier);\n}\n\nvar normaliseObject = obj => walkObject(obj, () => '');\nfunction validateContract(contract, tokens) {\n  var theDiff = diff(normaliseObject(contract), normaliseObject(tokens));\n  var valid = Object.keys(theDiff).length === 0;\n  return {\n    valid,\n    diffString: valid ? '' : renderDiff(contract, theDiff)\n  };\n}\nfunction diffLine(value, nesting, type) {\n  var whitespace = [...Array(nesting).keys()].map(() => '  ').join('');\n  var line = \"\".concat(type ? type : ' ').concat(whitespace).concat(value);\n  if (process.env.NODE_ENV !== 'test') {\n    if (type === '-') {\n      return pc.red(line);\n    }\n    if (type === '+') {\n      return pc.green(line);\n    }\n  }\n  return line;\n}\nfunction renderDiff(orig, diff) {\n  var nesting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var lines = [];\n  if (nesting === 0) {\n    lines.push(diffLine('{', 0));\n  }\n  var innerNesting = nesting + 1;\n  var keys = Object.keys(diff).sort();\n  for (var key of keys) {\n    var value = diff[key];\n    if (!(key in orig)) {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '+'));\n    } else if (typeof value === 'object') {\n      lines.push(diffLine(\"\".concat(key, \": {\"), innerNesting));\n      lines.push(renderDiff(orig[key], diff[key], innerNesting));\n      lines.push(diffLine('}', innerNesting));\n    } else {\n      lines.push(diffLine(\"\".concat(key, \": ...,\"), innerNesting, '-'));\n    }\n  }\n  if (nesting === 0) {\n    lines.push(diffLine('}', 0));\n  }\n  return lines.join('\\n');\n}\n\nvar buildPropertyRule = _ref => {\n  var {\n    syntax,\n    inherits,\n    initialValue\n  } = _ref;\n  return _objectSpread2({\n    syntax: \"\\\"\".concat(Array.isArray(syntax) ? syntax.join(' | ') : syntax, \"\\\"\"),\n    inherits: inherits ? 'true' : 'false'\n  }, initialValue != null ? {\n    initialValue\n  } : {});\n};\nfunction createVar(debugIdOrDeclaration, debugId) {\n  var cssVarName = cssesc(generateIdentifier({\n    debugId: typeof debugIdOrDeclaration === 'string' ? debugIdOrDeclaration : debugId,\n    debugFileName: false\n  }), {\n    isIdentifier: true\n  });\n  if (debugIdOrDeclaration && typeof debugIdOrDeclaration === 'object') {\n    appendCss({\n      type: 'property',\n      name: \"--\".concat(cssVarName),\n      rule: buildPropertyRule(debugIdOrDeclaration)\n    }, getFileScope());\n  }\n  return \"var(--\".concat(cssVarName, \")\");\n}\nfunction createGlobalVar(name, declaration) {\n  if (declaration && typeof declaration === 'object') {\n    appendCss({\n      type: 'property',\n      name: \"--\".concat(name),\n      rule: buildPropertyRule(declaration)\n    }, getFileScope());\n  }\n  return \"var(--\".concat(name, \")\");\n}\nfunction assertVarName(value) {\n  if (typeof value !== 'string' || !/^var\\(--.*\\)$/.test(value)) {\n    throw new Error(\"Invalid variable name: \".concat(value));\n  }\n}\nfunction fallbackVar() {\n  var finalValue = '';\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  values.reverse().forEach(value => {\n    if (finalValue === '') {\n      finalValue = String(value);\n    } else {\n      assertVarName(value);\n      finalValue = value.replace(/\\)$/, \", \".concat(finalValue, \")\"));\n    }\n  });\n  return finalValue;\n}\nfunction assignVars(varContract, tokens) {\n  var varSetters = {};\n  var {\n    valid,\n    diffString\n  } = validateContract(varContract, tokens);\n  if (!valid) {\n    throw new Error(\"Tokens don't match contract.\\n\".concat(diffString));\n  }\n  walkObject(tokens, (value, path) => {\n    varSetters[get(varContract, path)] = String(value);\n  });\n  return varSetters;\n}\nfunction createThemeContract(tokens) {\n  return walkObject(tokens, (_value, path) => {\n    return createVar(path.join('-'));\n  });\n}\nfunction createGlobalThemeContract(tokens, mapFn) {\n  return walkObject(tokens, (value, path) => {\n    var rawVarName = typeof mapFn === 'function' ? mapFn(value, path) : value;\n    var varName = typeof rawVarName === 'string' ? rawVarName.replace(/^\\-\\-/, '') : null;\n    if (typeof varName !== 'string' || varName !== cssesc(varName, {\n      isIdentifier: true\n    })) {\n      throw new Error(\"Invalid variable name for \\\"\".concat(path.join('.'), \"\\\": \").concat(varName));\n    }\n    return \"var(--\".concat(varName, \")\");\n  });\n}\n\nvar _excluded = [\"@layer\"];\nfunction createGlobalTheme(selector, arg2, arg3) {\n  var themeContractProvided = Boolean(arg3);\n  var tokenArg = themeContractProvided ? arg3 : arg2;\n  var {\n    layerName,\n    tokens\n  } = extractLayerFromTokens(tokenArg);\n  var themeContract = themeContractProvided ? arg2 : createThemeContract(tokens);\n  var rule = {\n    vars: assignVars(themeContract, tokens)\n  };\n  if (layerName) {\n    rule = {\n      '@layer': {\n        [layerName]: rule\n      }\n    };\n  }\n  appendCss({\n    type: 'global',\n    selector: selector,\n    rule\n  }, getFileScope());\n  if (!themeContractProvided) {\n    return themeContract;\n  }\n}\nfunction createTheme(arg1, arg2, arg3) {\n  var themeClassName = generateIdentifier(typeof arg2 === 'object' ? arg3 : arg2);\n  registerClassName(themeClassName, getFileScope());\n  var vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);\n  return vars ? [themeClassName, vars] : themeClassName;\n}\nfunction extractLayerFromTokens(tokens) {\n  if ('@layer' in tokens) {\n    var {\n        '@layer': layerName\n      } = tokens,\n      rest = _objectWithoutProperties(tokens, _excluded);\n    return {\n      layerName,\n      tokens: rest\n    };\n  }\n  return {\n    tokens\n  };\n}\n\nvar _templateObject;\nfunction composedStyle(rules, debugId) {\n  var className = generateIdentifier(debugId);\n  registerClassName(className, getFileScope());\n  var classList = [];\n  var styleRules = [];\n  for (var rule of rules) {\n    if (typeof rule === 'string') {\n      classList.push(rule);\n    } else {\n      styleRules.push(rule);\n    }\n  }\n  var result = className;\n  if (classList.length > 0) {\n    result = \"\".concat(className, \" \").concat(dudupeAndJoinClassList(classList));\n    registerComposition({\n      identifier: className,\n      classList: result\n    }, getFileScope());\n    if (styleRules.length > 0) {\n      // If there are styles attached to this composition then it is\n      // always used and should never be removed\n      markCompositionUsed(className);\n    }\n  }\n  if (styleRules.length > 0) {\n    var _rule = deepmerge.all(styleRules, {\n      // Replace arrays rather than merging\n      arrayMerge: (_, sourceArray) => sourceArray\n    });\n    appendCss({\n      type: 'local',\n      selector: className,\n      rule: _rule\n    }, getFileScope());\n  }\n  return result;\n}\nfunction style(rule, debugId) {\n  if (Array.isArray(rule)) {\n    return composedStyle(rule, debugId);\n  }\n  var className = generateIdentifier(debugId);\n  registerClassName(className, getFileScope());\n  appendCss({\n    type: 'local',\n    selector: className,\n    rule\n  }, getFileScope());\n  return className;\n}\n\n/**\n * @deprecated The same functionality is now provided by the 'style' function when you pass it an array\n */\nfunction composeStyles() {\n  var compose = hasFileScope() ? composedStyle : dudupeAndJoinClassList;\n  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classNames[_key] = arguments[_key];\n  }\n  return compose(classNames);\n}\nfunction globalStyle(selector, rule) {\n  appendCss({\n    type: 'global',\n    selector,\n    rule\n  }, getFileScope());\n}\nfunction fontFace(rule, debugId) {\n  var fontFamily = \"\\\"\".concat(cssesc(generateIdentifier(debugId), {\n    quotes: 'double'\n  }), \"\\\"\");\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    if ('fontFamily' in singleRule) {\n      throw new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      This function creates and returns a hashed font-family name, so the \\\"fontFamily\\\" property should not be provided.\\n    \\n      If you'd like to define a globally scoped custom font, you can use the \\\"globalFontFace\\\" function instead.\\n    \"]))));\n    }\n    appendCss({\n      type: 'fontFace',\n      rule: _objectSpread2(_objectSpread2({}, singleRule), {}, {\n        fontFamily\n      })\n    }, getFileScope());\n  }\n  return fontFamily;\n}\nfunction globalFontFace(fontFamily, rule) {\n  var rules = Array.isArray(rule) ? rule : [rule];\n  for (var singleRule of rules) {\n    appendCss({\n      type: 'fontFace',\n      rule: _objectSpread2(_objectSpread2({}, singleRule), {}, {\n        fontFamily\n      })\n    }, getFileScope());\n  }\n}\nfunction keyframes(rule, debugId) {\n  var name = cssesc(generateIdentifier(debugId), {\n    isIdentifier: true\n  });\n  appendCss({\n    type: 'keyframes',\n    name,\n    rule\n  }, getFileScope());\n  return name;\n}\nfunction globalKeyframes(name, rule) {\n  appendCss({\n    type: 'keyframes',\n    name,\n    rule\n  }, getFileScope());\n}\nfunction styleVariants() {\n  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n    var _data = arguments.length <= 0 ? undefined : arguments[0];\n    var _mapData = arguments.length <= 1 ? undefined : arguments[1];\n    var _debugId = arguments.length <= 2 ? undefined : arguments[2];\n    var _classMap = {};\n    for (var _key2 in _data) {\n      _classMap[_key2] = style(_mapData(_data[_key2], _key2), _debugId ? \"\".concat(_debugId, \"_\").concat(_key2) : _key2);\n    }\n    return _classMap;\n  }\n  var styleMap = arguments.length <= 0 ? undefined : arguments[0];\n  var debugId = arguments.length <= 1 ? undefined : arguments[1];\n  var classMap = {};\n  for (var _key3 in styleMap) {\n    classMap[_key3] = style(styleMap[_key3], debugId ? \"\".concat(debugId, \"_\").concat(_key3) : _key3);\n  }\n  return classMap;\n}\n\n// createContainer is used for local scoping of CSS containers\n// For now it is mostly just an alias of generateIdentifier\nvar createContainer = debugId => generateIdentifier(debugId);\n\n// createViewTransition is used for locally scoping CSS view transitions\n// For now it is mostly just an alias of generateIdentifier\nvar createViewTransition = debugId => generateIdentifier(debugId);\n\nvar defaultLayerOptions = {};\nvar merge = (obj1, obj2) => _objectSpread2(_objectSpread2({}, obj1), obj2);\nvar getLayerArgs = function getLayerArgs() {\n  var options = defaultLayerOptions;\n  var debugId = arguments.length <= 0 ? undefined : arguments[0];\n  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {\n    options = merge(defaultLayerOptions, arguments.length <= 0 ? undefined : arguments[0]);\n    debugId = arguments.length <= 1 ? undefined : arguments[1];\n  }\n  return [options, debugId];\n};\nfunction layer() {\n  var [options, debugId] = getLayerArgs(...arguments);\n  var name = generateIdentifier(debugId);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  appendCss({\n    type: 'layer',\n    name\n  }, getFileScope());\n  return name;\n}\nfunction globalLayer() {\n  var [options, name] = getLayerArgs(...arguments);\n  if (options.parent) {\n    name = \"\".concat(options.parent, \".\").concat(name);\n  }\n  appendCss({\n    type: 'layer',\n    name\n  }, getFileScope());\n  return name;\n}\n\nexport { assertVarName, assignVars, composeStyles, createContainer, createGlobalTheme, createGlobalThemeContract, createGlobalVar, createTheme, createThemeContract, createVar, createViewTransition, fallbackVar, fontFace, generateIdentifier, globalFontFace, globalKeyframes, globalLayer, globalStyle, keyframes, layer, style, styleVariants };\n", null, null, null, null, null, null, null, null, null, null, null, null, null, null],
  "mappings": "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",
  "names": ["parse", "serialize", "decode", "index", "max", "min", "isDate", "sides", "value", "parse", "cookies", "splitCookiesString", "is", "React", "useState", "useLayoutEffect", "useEffect", "useDebugValue", "is", "React", "useSyncExternalStore", "useRef", "useEffect", "useMemo", "useDebugValue", "object", "hasOwnProperty", "merge", "cssesc", "string", "isMergeableObject", "deepmerge", "object", "array", "import_react", "location", "index", "_a", "memo2", "index", "index", "navigator", "navigator", "_a", "navigator", "location", "index", "_a", "navigator", "object", "url", "object", "location", "index", "_a", "location", "_a", "url", "href", "href", "location", "navigator", "location", "location", "location2", "React", "React2", "React4", "React5", "React3", "React", "ReactDOM", "React2", "_jsx", "_jsx", "data", "_jsxs", "_jsx", "_jsxs", "React", "composeEventHandlers", "React", "React", "import_jsx_runtime", "createContext", "useContext", "index", "_a", "createScope", "nextScopes", "React", "React", "useLayoutEffect", "React", "useId", "useLayoutEffect2", "React", "React2", "React", "React", "useLayoutEffect2", "value", "_a", "React", "React", "ReactDOM", "React", "import_jsx_runtime", "Slot", "props", "Slottable", "Fragment", "_a", "_b", "import_jsx_runtime", "Slot", "Node", "React", "_a", "React", "import_jsx_runtime", "node", "index", "composeEventHandlers", "handleAndDispatchPointerDownOutsideEvent", "React", "import_jsx_runtime", "container", "handleFocusIn", "handleFocusOut", "handleMutations", "_a", "array", "index", "React", "import_jsx_runtime", "useLayoutEffect2", "container", "_a", "ReactDOM", "React2", "React", "getElementRef", "useLayoutEffect2", "node", "_a", "_b", "React", "count", "count", "__assign", "React", "React", "import_react", "useCallbackRef", "React", "useIsomorphicLayoutEffect", "useCallbackRef", "React", "import_react", "data", "cbs", "React", "import_react", "React", "_a", "_a", "_b", "SideCar", "React", "React", "React", "_a", "parse", "_a", "_b", "_a", "Style", "import_jsx_runtime", "useId", "composeEventHandlers", "PORTAL_NAME", "container", "Slot", "_a", "_b", "createContext2", "import_react", "shift", "data", "data", "bigint", "size", "_BcsType", "__privateAdd", "__privateSet", "options", "__privateGet", "validate", "__privateAdd", "__privateSet", "__privateGet", "size", "_a", "serialize", "data", "_a", "size", "array", "index", "name", "variant", "StateType", "ulebEncode", "ulebDecode", "shift", "BcsReader", "data", "ulebDecode", "encodeStr", "data", "splitGenericParameters", "BcsWriter", "toLittleEndian", "ulebEncode", "encodeStr", "bigint", "size", "_write", "_serialize", "_schema", "_bytes", "_BcsType", "__privateAdd", "__privateSet", "options", "BcsWriter", "__privateGet", "SerializedBcs", "BcsReader", "validate", "BcsType", "SERIALIZED_BCS_BRAND", "isSerializedBcs", "fixedSizeBcsType", "size", "uIntBcsType", "_a", "bigUIntBcsType", "dynamicSizeBcsType", "serialize", "stringLikeBcsType", "ulebEncode", "lazyBcsType", "data", "bcs", "uIntBcsType", "bigUIntBcsType", "fixedSizeBcsType", "_a", "dynamicSizeBcsType", "ulebEncode", "size", "array", "BcsType", "stringLikeBcsType", "index", "name", "variant", "lazyBcsType", "isValidSuiNSName", "isValidNamedPackage", "isValidSuiNSName", "isValidNamedType", "SUI_ADDRESS_LENGTH", "isValidSuiAddress", "isHex", "getHexByteLength", "parseStructTag", "isValidNamedPackage", "splitGenericParameters", "normalizeSuiAddress", "normalizeStructTag", "SUI_ADDRESS_LENGTH", "normalizeSuiObjectId", "isHex", "getHexByteLength", "VECTOR_REGEX", "STRUCT_REGEX", "TypeTagSerializer", "normalizeSuiAddress", "splitGenericParameters", "unsafe_u64", "bcs", "optionEnum", "Address", "SUI_ADDRESS_LENGTH", "isValidSuiAddress", "normalizeSuiAddress", "ObjectDigest", "SuiObjectRef", "SharedObjectRef", "ObjectArg", "Owner", "CallArg", "InnerTypeTag", "StructTag", "TypeTag", "TypeTagSerializer", "Argument", "ProgrammableMoveCall", "Command", "ProgrammableTransaction", "TransactionKind", "TransactionExpiration", "GasData", "TransactionDataV1", "TransactionData", "IntentScope", "IntentVersion", "AppId", "Intent", "IntentMessage", "CompressedSignature", "PublicKey", "MultiSigPkMap", "MultiSigPublicKey", "MultiSig", "base64String", "SenderSignedTransaction", "SenderSignedData", "PasskeyAuthenticator", "PackageUpgradeError", "bcs", "Address", "ModuleId", "MoveLocation", "CommandArgumentError", "TypeArgumentError", "ExecutionFailureStatus", "ExecutionStatus", "GasCostSummary", "TransactionEffectsV1", "SuiObjectRef", "ObjectDigest", "Owner", "VersionDigest", "ObjectIn", "ObjectOut", "IDOperation", "EffectsObjectChange", "UnchangedSharedKind", "TransactionEffectsV2", "TransactionEffects", "pureBcsSchemaFromTypeName", "bcs", "Address", "suiBcs", "bcs", "Address", "AppId", "Argument", "CallArg", "Command", "CompressedSignature", "GasData", "Intent", "IntentMessage", "IntentScope", "IntentVersion", "MultiSig", "MultiSigPkMap", "MultiSigPublicKey", "ObjectArg", "ObjectDigest", "Owner", "PasskeyAuthenticator", "ProgrammableMoveCall", "ProgrammableTransaction", "PublicKey", "SenderSignedData", "SenderSignedTransaction", "SharedObjectRef", "StructTag", "SuiObjectRef", "TransactionData", "TransactionDataV1", "TransactionEffects", "TransactionExpiration", "TransactionKind", "TypeTag", "MIST_PER_SUI", "MOVE_STDLIB_ADDRESS", "SUI_FRAMEWORK_ADDRESS", "SUI_CLOCK_OBJECT_ID", "normalizeSuiObjectId", "SUI_TYPE_ARG", "SUI_FRAMEWORK_ADDRESS", "SUI_SYSTEM_STATE_OBJECT_ID", "normalizeSuiObjectId", "normalizeSuiAddress", "suiBcs", "MOVE_STDLIB_ADDRESS", "SUI_FRAMEWORK_ADDRESS", "data", "normalizeSuiAddress", "normalizeSuiAddress", "isValidSuiAddress", "Argument", "GasData", "StructTag", "ProgrammableMoveCall", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "TransactionData", "UpgradePolicy", "Argument", "normalizeSuiObjectId", "data", "ObjectRef", "ObjectArg", "NormalizedCallArg", "TransactionExpiration", "TypeTag", "StructTag", "_a", "index", "TypeTagSerializer", "data", "_b", "TransactionData", "Argument", "GasData", "ProgrammableMoveCall", "$Intent", "Command", "ObjectArg", "CallArg", "TransactionExpiration", "SUI_TYPE_ARG", "_a", "normalizeSuiObjectId", "chunk", "index", "object", "normalizeSuiAddress", "inputs", "_b", "data", "_a", "index", "suiBcs", "object", "pureBcsSchemaFromTypeName", "isSerializedBcs", "suiBcs", "data", "normalizeSuiAddress", "suiBcs", "data", "TransactionData", "index", "normalizeSuiAddress", "_ClientCache", "__privateAdd", "__privateSet", "__privateGet", "_cache", "NAME_SEPARATOR", "url", "__privateAdd", "__privateSet", "__privateGet", "_a", "_b", "__privateMethod", "data", "isValidNamedPackage", "isValidSuiAddress", "normalizeSuiAddress", "parseStructTag", "normalizeStructTag", "isValidNamedType", "getClient", "index", "_Transaction", "__privateAdd", "Argument", "__privateGet", "_a", "_b", "__privateMethod", "normalizeSuiAddress", "__privateSet", "TransactionExpiration", "isSerializedBcs", "result", "_cache", "_cache", "_queue", "_queue", "_queue", "_cache", "_queue", "_cache", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest", "_signer", "_client", "_defaultGasBudget", "_cache", "_lastDigest", "_options", "_b", "_a", "__privateGet", "data", "__privateMethod", "__privateWrapper", "suiBcs", "__privateSet", "normalizeStructTag", "Request", "encode", "encoder", "encode", "encoder", "_a", "_a", "_b", "NAME", "Response", "_isSendCalled", "__privateAdd", "__privateGet", "Response", "__privateMethod", "__privateSet", "data", "_id", "_id", "__privateSet", "__privateGet", "_a", "_a", "_cleanup", "_setup", "React", "React", "import_jsx_runtime", "React", "React", "import_jsx_runtime", "React", "React", "React", "React", "React", "React", "import_react", "import_react", "ReactExports", "useSyncExternalStoreExports", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "r", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_jsx_runtime", "ulebEncode", "ulebDecode", "shift", "BcsReader", "data", "ulebDecode", "encodeStr", "data", "splitGenericParameters", "BcsWriter", "toLittleEndian", "ulebEncode", "encodeStr", "bigint", "size", "_write", "_serialize", "_schema", "_bytes", "_BcsType", "__privateAdd", "__privateSet", "options", "BcsWriter", "__privateGet", "SerializedBcs", "BcsReader", "validate", "BcsType", "SERIALIZED_BCS_BRAND", "isSerializedBcs", "fixedSizeBcsType", "size", "uIntBcsType", "_a", "bigUIntBcsType", "dynamicSizeBcsType", "serialize", "stringLikeBcsType", "ulebEncode", "lazyBcsType", "data", "bcs", "uIntBcsType", "bigUIntBcsType", "fixedSizeBcsType", "_a", "dynamicSizeBcsType", "ulebEncode", "size", "array", "BcsType", "stringLikeBcsType", "index", "name", "variant", "lazyBcsType", "SUI_NS_NAME_REGEX", "SUI_NS_DOMAIN_REGEX", "MAX_SUI_NS_NAME_LENGTH", "isValidSuiNSName", "normalizeSuiNSName", "NAME_PATTERN", "VERSION_REGEX", "MAX_APP_SIZE", "NAME_SEPARATOR", "isValidNamedPackage", "isValidSuiNSName", "isValidNamedType", "isValidTransactionDigest", "SUI_ADDRESS_LENGTH", "isValidSuiAddress", "isHex", "getHexByteLength", "isValidSuiObjectId", "parseTypeTag", "parseStructTag", "isValidNamedPackage", "splitGenericParameters", "normalizeSuiAddress", "normalizeStructTag", "normalizeSuiObjectId", "MIST_PER_SUI", "MOVE_STDLIB_ADDRESS", "SUI_FRAMEWORK_ADDRESS", "SUI_CLOCK_OBJECT_ID", "normalizeSuiObjectId", "SUI_TYPE_ARG", "SUI_FRAMEWORK_ADDRESS", "SUI_SYSTEM_STATE_OBJECT_ID", "normalizeSuiObjectId", "VECTOR_REGEX", "STRUCT_REGEX", "TypeTagSerializer", "normalizeSuiAddress", "splitGenericParameters", "unsafe_u64", "bcs", "optionEnum", "Address", "SUI_ADDRESS_LENGTH", "isValidSuiAddress", "normalizeSuiAddress", "ObjectDigest", "SuiObjectRef", "SharedObjectRef", "ObjectArg", "Owner", "CallArg", "InnerTypeTag", "StructTag", "TypeTag", "TypeTagSerializer", "Argument", "ProgrammableMoveCall", "Command", "ProgrammableTransaction", "TransactionKind", "TransactionExpiration", "GasData", "TransactionDataV1", "TransactionData", "IntentScope", "IntentVersion", "AppId", "Intent", "IntentMessage", "CompressedSignature", "PublicKey", "MultiSigPkMap", "MultiSigPublicKey", "MultiSig", "base64String", "SenderSignedTransaction", "SenderSignedData", "PasskeyAuthenticator", "PackageUpgradeError", "bcs", "Address", "ModuleId", "MoveLocation", "CommandArgumentError", "TypeArgumentError", "ExecutionFailureStatus", "ExecutionStatus", "GasCostSummary", "TransactionEffectsV1", "SuiObjectRef", "ObjectDigest", "Owner", "VersionDigest", "ObjectIn", "ObjectOut", "IDOperation", "EffectsObjectChange", "UnchangedSharedKind", "TransactionEffectsV2", "TransactionEffects", "pureBcsSchemaFromTypeName", "bcs", "Address", "suiBcs", "bcs", "Address", "AppId", "Argument", "CallArg", "Command", "CompressedSignature", "GasData", "Intent", "IntentMessage", "IntentScope", "IntentVersion", "MultiSig", "MultiSigPkMap", "MultiSigPublicKey", "ObjectArg", "ObjectDigest", "Owner", "PasskeyAuthenticator", "ProgrammableMoveCall", "ProgrammableTransaction", "PublicKey", "SenderSignedData", "SenderSignedTransaction", "SharedObjectRef", "StructTag", "SuiObjectRef", "TransactionData", "TransactionDataV1", "TransactionEffects", "TransactionExpiration", "TransactionKind", "TypeTag", "deriveDynamicFieldID", "suiBcs", "React", "React", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "createCollectionScope", "React", "useCollection", "React", "import_jsx_runtime", "React", "platform", "data", "max", "offset", "platform", "placements", "sides", "side", "placement", "overflow", "platform", "x", "y", "min", "max", "offset", "isNode", "getComputedStyle", "getComputedStyle", "data", "offset", "shift", "flip", "size", "hide", "arrow", "limitShift", "computePosition", "React", "import_react", "ReactDOM", "noop", "platform", "transform", "data", "computePosition", "arrow", "offset", "shift", "limitShift", "flip", "size", "hide", "arrow", "React", "import_jsx_runtime", "React", "size", "useLayoutEffect2", "import_jsx_runtime", "CONTENT_NAME", "arrow", "offset", "shift", "limitShift", "flip", "size", "hide", "useLayoutEffect2", "_a", "_b", "PopperArrow", "data", "Root", "Arrow", "React", "import_jsx_runtime", "EVENT_OPTIONS", "composeEventHandlers", "focusFirst", "useId", "array", "index", "Root", "import_jsx_runtime", "Collection", "useCollection", "createCollectionScope", "ANCHOR_NAME", "PORTAL_NAME", "PortalProvider", "usePortalContext", "container", "CONTENT_NAME", "composeEventHandlers", "Slot", "_a", "_b", "Root", "focusFirst", "GROUP_NAME", "ITEM_NAME", "ARROW_NAME", "Arrow", "useId", "wrapArray", "array", "index", "Anchor", "Portal", "Content", "Item", "import_jsx_runtime", "useId", "Root3", "TRIGGER_NAME", "composeEventHandlers", "PORTAL_NAME", "Portal", "CONTENT_NAME", "_a", "GROUP_NAME", "LABEL_NAME", "ITEM_NAME", "CHECKBOX_ITEM_NAME", "RADIO_GROUP_NAME", "RADIO_ITEM_NAME", "SEPARATOR_NAME", "ARROW_NAME", "Arrow2", "SUB_TRIGGER_NAME", "SUB_CONTENT_NAME", "import_react", "PACKAGE_VERSION", "url", "__privateAdd", "__privateMethod", "__privateSet", "__privateGet", "_a", "__privateWrapper", "data", "resolve", "_requestId", "__privateAdd", "__privateSet", "__privateGet", "_a", "PACKAGE_VERSION", "_b", "data", "__privateMethod", "_prefix", "_cache", "_ClientCache", "__privateAdd", "__privateSet", "__privateGet", "ClientCache", "ClientCache", "safeEnum", "SuiAddress", "normalizeSuiAddress", "isValidSuiAddress", "ObjectID", "BCSBytes", "JsonU64", "ObjectRef", "Argument", "GasData", "StructTag", "OpenMoveTypeSignatureBody", "OpenMoveTypeSignature", "ProgrammableMoveCall", "$Intent", "Command", "ObjectArg", "CallArg", "NormalizedCallArg", "TransactionExpiration", "TransactionData", "UpgradePolicy", "Commands", "Argument", "normalizeSuiObjectId", "data", "ObjectRef", "ObjectArg", "safeEnum", "ObjectID", "JsonU64", "NormalizedCallArg", "TransactionInput", "TransactionExpiration", "StringEncodedBigint", "TypeTag", "StructTag", "GasConfig", "TransactionArgumentTypes", "TransactionArgument", "MoveCallTransaction", "TransferObjectsTransaction", "SplitCoinsTransaction", "MergeCoinsTransaction", "MakeMoveVecTransaction", "PublishTransaction", "UpgradeTransaction", "TransactionTypes", "TransactionType", "SerializedTransactionDataV1", "serializeV1TransactionData", "_a", "index", "TypeTagSerializer", "convertTransactionArgument", "transactionDataFromV1", "data", "_b", "TransactionData", "parseV1TransactionArgument", "enumUnion", "Argument", "GasData", "JsonU64", "SuiAddress", "ObjectRef", "ProgrammableMoveCall", "ObjectID", "$Intent", "Command", "BCSBytes", "ObjectArg", "CallArg", "TransactionExpiration", "SerializedTransactionDataV2", "Pure", "data", "Inputs", "normalizeSuiAddress", "OBJECT_MODULE_NAME", "ID_STRUCT_NAME", "STD_ASCII_MODULE_NAME", "STD_ASCII_STRUCT_NAME", "STD_UTF8_MODULE_NAME", "STD_UTF8_STRUCT_NAME", "STD_OPTION_MODULE_NAME", "STD_OPTION_STRUCT_NAME", "isTxContext", "normalizeSuiAddress", "getPureBcsSchema", "suiBcs", "MOVE_STDLIB_ADDRESS", "SUI_FRAMEWORK_ADDRESS", "normalizedTypeToMoveTypeSignature", "normalizedTypeToMoveTypeSignatureBody", "MAX_OBJECTS_PER_FETCH", "GAS_SAFE_OVERHEAD", "MAX_GAS", "suiClientResolveTransactionPlugin", "normalizeInputs", "resolveObjectReferences", "setGasPrice", "setGasBudget", "setGasPayment", "SUI_TYPE_ARG", "_a", "ObjectRef", "normalizeSuiObjectId", "chunk", "index", "object", "normalizeSuiAddress", "Inputs", "isUsedAsMutable", "isUsedAsReceiving", "inputs", "normalizedTypeToMoveTypeSignature", "isTxContext", "_b", "getPureBcsSchema", "isReceivingType", "needsTransactionResolution", "data", "resolveTransactionPlugin", "_a", "normalizeRawArguments", "validate", "getClient", "suiClientResolveTransactionPlugin", "index", "normalizeRawArgument", "suiBcs", "Inputs", "createObjectMethods", "object", "createPure", "pureBcsSchemaFromTypeName", "isSerializedBcs", "suiBcs", "hashTypedData", "data", "prepareSuiAddress", "normalizeSuiAddress", "TransactionDataBuilder", "suiBcs", "data", "TransactionData", "transactionDataFromV1", "hashTypedData", "index", "getIdFromCallArg", "normalizeSuiAddress", "_cache", "_url", "_pageSize", "_overrides", "_MvrClient_instances", "mvrPackageDataLoader_get", "mvrTypeDataLoader_get", "resolvePackages_fn", "resolveTypes_fn", "fetch_fn", "NAME_SEPARATOR", "MVR_API_HEADER", "PACKAGE_VERSION", "MvrClient", "url", "__privateAdd", "__privateSet", "validateOverrides", "__privateGet", "extractMvrTypes", "replaceMvrNames", "_a", "_b", "__privateMethod", "data", "isValidNamedPackage", "isValidSuiAddress", "normalizeSuiAddress", "parseStructTag", "hasMvrName", "isStructTag", "normalizeStructTag", "findNamesInTransaction", "getNamesFromTypeList", "replaceNames", "isValidNamedType", "cacheMap", "namedPackagesPlugin", "ClientCache", "MvrClient", "findNamesInTransaction", "getClient", "replaceNames", "_serializationPlugins", "_buildPlugins", "_intentResolvers", "_inputSection", "_commandSection", "_availableResults", "_pendingPromises", "_added", "_data", "_Transaction_instances", "fork_fn", "addCommand_fn", "addInput_fn", "normalizeTransactionArgument_fn", "resolveArgument_fn", "prepareBuild_fn", "runPlugins_fn", "waitForPendingTasks_fn", "sortCommandsAndInputs_fn", "createTransactionResult", "index", "TRANSACTION_BRAND", "isTransaction", "modulePluginRegistry", "TRANSACTION_REGISTRY_KEY", "getGlobalPluginRegistry", "_Transaction", "__privateAdd", "createObjectMethods", "Argument", "getIdFromCallArg", "__privateGet", "_a", "_b", "__privateMethod", "normalizeSuiAddress", "__privateSet", "TransactionDataBuilder", "TransactionExpiration", "ObjectRef", "serializeV1TransactionData", "createPure", "isSerializedBcs", "NormalizedCallArg", "Inputs", "result", "Commands", "SerializedTransactionDataV2", "needsTransactionResolution", "namedPackagesPlugin", "resolveTransactionPlugin", "Transaction", "_a", "_b", "MvrClient", "deriveDynamicFieldID", "TypeTagSerializer", "parseStructTag", "normalizeStructTag", "SUI_ADDRESS_LENGTH", "TransactionDataBuilder", "suiBcs", "_a", "_b", "object", "__privateAdd", "__privateSet", "__privateGet", "object", "Transaction", "suiClientResolveTransactionPlugin", "_a", "suiBcs", "data", "TransactionDataBuilder", "_b", "isValidSuiAddress", "normalizeSuiAddress", "hasMvrName", "isValidNamedPackage", "isValidSuiObjectId", "normalizeSuiObjectId", "isValidTransactionDigest", "_a", "_b", "isTransaction", "hasNextPage", "data", "normalizeSuiNSName", "import_react", "import_jsx_runtime", "import_jsx_runtime", "import_react", "import_react", "import_react", "suiBcs", "PublicKey", "suiBcs", "normalizeSuiAddress", "SUI_ADDRESS_LENGTH", "size", "PublicKey", "PasskeyAuthenticator", "AddressTransactionBlockRelationship", "DomainFormat", "ExecutionStatus", "Feature", "MoveAbility", "MoveVisibility", "ObjectKind", "StakeStatus", "TransactionBlockKindInput", "ZkLoginIntentScope", "data", "__privateGet", "_url", "_url", "bcs", "_data", "_client", "_data", "_client", "__privateGet", "normalizeSuiAddress", "SUI_ADDRESS_LENGTH", "data", "PublicKey", "_caches", "_cache", "_onEffects", "_caches", "_cache", "_onEffects", "_client", "_lastDigest", "_client", "_lastDigest", "_queue", "_queue", "_queue", "_queue", "_signer", "_cache", "_defaultGasBudget", "_cacheGasCoin", "_buildTransaction", "_queue", "_signer", "_cache", "_defaultGasBudget", "_cacheGasCoin", "_buildTransaction", "getGasCoinFromEffects", "_signer", "_client", "_coinBatchSize", "_initialCoinBalance", "_minimumCoinBalance", "_epochBoundaryWindow", "_defaultGasBudget", "_maxPoolSize", "_sourceCoins", "_coinPool", "_cache", "_objectIdQueues", "_buildQueue", "_executeQueue", "_lastDigest", "_cacheLock", "_pendingTransactions", "_gasPrice", "_ParallelTransactionExecutor_instances", "getUsedObjects_fn", "execute_fn", "updateCache_fn", "waitForLastDigest_fn", "getGasCoin_fn", "getGasPrice_fn", "refillCoinPool_fn", "_signer", "_client", "_coinBatchSize", "_initialCoinBalance", "_minimumCoinBalance", "_epochBoundaryWindow", "_defaultGasBudget", "_maxPoolSize", "_sourceCoins", "_coinPool", "_cache", "_objectIdQueues", "_buildQueue", "_executeQueue", "_lastDigest", "_cacheLock", "_pendingTransactions", "_gasPrice", "_ParallelTransactionExecutor_instances", "getUsedObjects_fn", "_options", "_b", "_a", "__privateGet", "execute_fn", "data", "__privateMethod", "getGasPrice_fn", "updateCache_fn", "getGasCoin_fn", "__privateWrapper", "suiBcs", "getGasCoinFromEffects", "TransactionDataBuilder", "__privateSet", "waitForLastDigest_fn", "refillCoinPool_fn", "Transaction", "SUI_TYPE", "normalizeStructTag", "CoinWithBalanceData", "Arguments", "createPure", "createObjectMethods", "import_react", "import_react", "injectStyles", "r", "markCompositionUsed", "SelectorType", "AttributeAction", "parse", "offset", "data", "ownKeys", "object", "_defineProperty", "dedent", "__assign", "__rest", "r", "weirdNewlines", "nullOrSurrogates", "commentRegex", "lexicalAnalysis", "str", "index", "replace", "tokens", "length", "code", "charCodeAt", "code_1", "push", "type", "result", "consumeString", "_a", "lastIndex", "value", "nextCode", "flag", "wouldStartIdentifier", "consumeIdentUnsafe", "_b", "toLowerCase", "plusNumeric", "consumeNumeric", "tokenTuple", "unit", "minusNumeric", "nextNextCode", "consumeIdentLike", "nextNextNextCode", "consumeIdent", "consumeEscape", "slice", "firstCode", "charCodes", "i", "String", "fromCharCode", "apply", "charCode", "hexCharCodes", "min", "Math", "code_2", "code_3", "parseInt", "numberResult", "consumeNumber", "numberEndIndex", "numberValue", "numberFlag", "identResult", "identEndIndex", "identValue", "numberChars", "nextNextIsDigit", "numberString", "parseFloat", "Number", "isNaN", "identChars", "code_4", "code_5", "consumeUrl", "urlChars", "hasFinishedWord", "offset", "result_1", "lastUrlIndex", "value_1", "simplifyAST", "ast", "simplifyMediaQuery", "mediaQuery", "mediaCondition", "simplifyMediaCondition", "operator", "children", "mediaPrefix", "mediaType", "unsimplifiedChild", "child", "spliceArgs", "i_1", "splice", "createError", "message", "err", "Error", "trim", "concat", "toAST", "toUnflattenedAST", "tokenList", "startIndex", "endIndex", "token", "syntacticAnalysis", "removeWhitespace", "newTokenList", "before", "wsAfter", "wsBefore", "mediaQueryList", "mediaQueries", "map", "mediaQueryTokens", "tokenizeMediaQuery", "nonNullMediaQueryTokens", "mediaQueryTokens_1_1", "mediaQueryToken", "firstToken", "tokenizeMediaCondition", "firstIndex", "firstNonUnaryToken", "tokensWithParens", "secondNonUnaryToken", "mayContainOr", "previousOperator", "endIndexOfFirstFeature", "maxDepth", "count", "max", "featureTokens", "tokenizeMediaFeature", "nextToken", "siblings", "rawTokens", "a", "b", "c", "numerator", "denominator", "context", "feature", "valueToken", "prefix", "range", "tokenizeRange", "featureName", "leftToken", "leftOp", "rightOp", "rightToken", "hasLeft", "tokenIndexAfterFirstOp", "tokenAfterFirstOp", "secondOpToken", "followingToken", "tokenAfterSecondOp", "_c", "_d", "validRange", "lt", "rt", "ltNoWS", "rtNoWS", "toPrimitive", "r", "toPropertyKey", "_defineProperty", "ownKeys", "_objectSpread2", "string", "cssesc", "parse", "_loop", "dependents", "_objectSpread2", "localClassNames", "composedClassLists", "identifier", "rule", "query", "_loop2", "key", "v", "isEmpty", "_a", "_b", "max", "size", "index", "v", "bf", "import_cssesc", "injectStyles", "index", "cssesc", "import_jsx_runtime", "__commonJS", "__toESM", "jsx", "forwardRef", "size", "Slot", "clsx", "_7a468", "forwardRef", "variant", "size", "Slot", "jsx", "clsx", "createContext", "_jsx", "_jsxs", "_Fragment", "_jsx", "_jsxs", "_jsx", "_jsxs", "_jsx", "_jsxs", "_jsx", "import_react", "data", "err", "hasNextPage", "_jsx", "_jsxs", "import_react", "err", "_jsxs", "_jsx", "validate", "_a", "_b", "max", "fetch", "_jsx", "_jsxs", "_Fragment", "url", "import_react", "_jsx", "_jsxs", "import_react", "_jsx", "_jsxs", "_jsx"]
}
