import {
  SuiClient,
  getFullnodeUrl
} from "./chunk-BVVG4NFB.js";
import {
  Ed25519Keypair
} from "./chunk-LNBUFZM4.js";
import {
  Field,
  Keypair,
  _normFnElement,
  bytesToNumberBE,
  createCurve,
  createHasher as createHasher2,
  decodeSuiPrivateKey,
  encodeSuiPrivateKey,
  ensureBytes,
  hmac,
  inRange,
  isValidBIP32Path,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  mnemonicToSeed,
  mod,
  numberToBytesBE,
  parseSerializedSignature,
  pow2,
  secp256r1,
  sha256,
  sha2562,
  sha512
} from "./chunk-6O6PQUFC.js";
import {
  PublicKey,
  SIGNATURE_SCHEME_TO_FLAG,
  bytesEqual,
  parseSerializedKeypairSignature
} from "./chunk-PTBBFSUW.js";
import {
  Chi,
  HashMD,
  Maj,
  abytes,
  blake2b,
  bytesToHex,
  clean,
  concatBytes,
  createBase58check,
  createHasher,
  createView,
  fromBase64,
  hexToBytes,
  isValidSuiAddress,
  normalizeStructTag,
  normalizeSuiAddress,
  randomBytes,
  rotl,
  utf8ToBytes
} from "./chunk-6XQOA6MW.js";
import {
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/@polymedia/suitcase-core/dist/esm/misc.js
function chunkArray(array, chunkSize) {
  const chunks = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    const chunk = array.slice(i, i + chunkSize);
    chunks.push(chunk);
  }
  return chunks;
}
function chunkString(input, chunkSize) {
  const chunks = [];
  for (let i = 0; i < input.length; i += chunkSize) {
    chunks.push(input.slice(i, i + chunkSize));
  }
  return chunks;
}
function makeRanges(from, to, size) {
  const ranges = [];
  for (let start = from; start < to; start += size) {
    const end = Math.min(start + size, to);
    ranges.push([start, end]);
  }
  return ranges;
}
async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/@polymedia/suitcase-core/dist/esm/guards.js
function isOwnerKind(owner, kind) {
  return kind === owner || typeof owner === "object" && kind in owner;
}
function isArgKind(arg, kind) {
  return kind === arg || typeof arg === "object" && kind in arg;
}
function isObjChangeKind(change, kind) {
  return change.type === kind;
}
function isSuiObjectRef(obj) {
  return typeof obj === "object" && obj !== null && "objectId" in obj && "version" in obj && "digest" in obj;
}
function isParsedDataKind(data, kind) {
  return data.dataType === kind;
}
function isTxKind(tx, kind) {
  return kind in tx;
}

// node_modules/@polymedia/suitcase-core/dist/esm/objects.js
function objResToContent(resp) {
  var _a;
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!((_a = resp.data) == null ? void 0 : _a.content)) {
    throw Error(`response has no content: ${JSON.stringify(resp, null, 2)}`);
  }
  return resp.data.content;
}
function objResToDisplay(resp) {
  var _a;
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!((_a = resp.data) == null ? void 0 : _a.display)) {
    throw Error(`response has no display: ${JSON.stringify(resp, null, 2)}`);
  }
  return {
    ...newEmptyDisplay(),
    ...resp.data.display.data
  };
}
function newEmptyDisplay() {
  return {
    name: null,
    description: null,
    link: null,
    image_url: null,
    thumbnail_url: null,
    project_name: null,
    project_url: null,
    project_image_url: null,
    creator: null
  };
}
function objResToFields(resp) {
  var _a, _b;
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (((_b = (_a = resp.data) == null ? void 0 : _a.content) == null ? void 0 : _b.dataType) !== "moveObject") {
    throw Error(`response content missing: ${JSON.stringify(resp, null, 2)}`);
  }
  return resp.data.content.fields;
}
function objResToId(resp) {
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!resp.data) {
    throw Error(`response has no data: ${JSON.stringify(resp, null, 2)}`);
  }
  return resp.data.objectId;
}
function objResToOwner(resp) {
  var _a;
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!((_a = resp.data) == null ? void 0 : _a.owner)) {
    throw Error(`response has no owner data: ${JSON.stringify(resp, null, 2)}`);
  }
  if (isOwnerKind(resp.data.owner, "AddressOwner")) {
    return resp.data.owner.AddressOwner;
  }
  if (isOwnerKind(resp.data.owner, "ObjectOwner")) {
    return resp.data.owner.ObjectOwner;
  }
  if (isOwnerKind(resp.data.owner, "Shared")) {
    return "shared";
  }
  if (isOwnerKind(resp.data.owner, "Immutable")) {
    return "immutable";
  }
  return "unknown";
}
function objResToRef(resp) {
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!resp.data) {
    throw Error(`response has no data: ${JSON.stringify(resp, null, 2)}`);
  }
  return {
    objectId: resp.data.objectId,
    digest: resp.data.digest,
    version: resp.data.version
  };
}
function objResToType(resp) {
  var _a;
  if (resp.error) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!((_a = resp.data) == null ? void 0 : _a.content)) {
    throw Error(`response has no content: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!isParsedDataKind(resp.data.content, "moveObject")) {
    throw Error(`response data is not a moveObject: ${JSON.stringify(resp, null, 2)}`);
  }
  return resp.data.content.type;
}

// node_modules/@polymedia/suitcase-core/dist/esm/SuiClientBase.js
var MAX_OBJECTS_PER_REQUEST = 50;
var SuiClientBase = class {
  /**
   * @param suiClient The client used to communicate with Sui.
   * @param signTx A function that can sign a `Transaction`.
   * @param txRespOptions Which fields to include in transaction responses.
   * @param waitForTxOptions Options for `SuiClient.waitForTransaction()`.
   */
  constructor({ suiClient, signTx, txRespOptions = { showEffects: true, showObjectChanges: true }, waitForTxOptions = { timeout: 45e3, pollInterval: 250 } }) {
    __publicField(this, "suiClient");
    __publicField(this, "signTx");
    __publicField(this, "txRespOptions");
    __publicField(this, "waitForTxOptions");
    this.suiClient = suiClient;
    this.signTx = signTx;
    this.txRespOptions = txRespOptions;
    this.waitForTxOptions = waitForTxOptions;
  }
  // === data fetching ===
  /**
   * Fetch and parse objects from the RPC and cache them.
   * @param objectIds The IDs of the objects to fetch.
   * @param cache The cache to use (if any). Keys are object IDs and values are the parsed objects.
   * @param fetchFn A function that fetches objects from the Sui network.
   * @param parseFn A function that parses a `SuiObjectResponse` into an object.
   * @returns The parsed objects.
   */
  async fetchAndParseObjs({ ids, fetchFn, parseFn, cache }) {
    const results = [];
    const uncachedIds = [];
    for (const id of ids) {
      const cachedObject = cache ? cache.get(id) : void 0;
      if (cachedObject) {
        results.push(cachedObject);
      } else {
        uncachedIds.push(id);
      }
    }
    if (uncachedIds.length === 0) {
      return results;
    }
    const idChunks = chunkArray(uncachedIds, MAX_OBJECTS_PER_REQUEST);
    const allResults = await Promise.all(idChunks.map(fetchFn));
    for (const resps of allResults) {
      for (const resp of resps) {
        const parsedObject = parseFn(resp);
        if (parsedObject) {
          results.push(parsedObject);
          if (cache) {
            cache.set(objResToId(resp), parsedObject);
          }
        }
      }
    }
    return results;
  }
  /**
   * Fetch and parse transactions from the RPC.
   */
  async fetchAndParseTxs({ parseFn, query }) {
    const pagTxRes = await this.suiClient.queryTransactionBlocks(query);
    const results = {
      hasNextPage: pagTxRes.hasNextPage,
      nextCursor: pagTxRes.nextCursor,
      data: pagTxRes.data.map((resp) => parseFn(resp)).filter((result) => result !== null)
    };
    return results;
  }
  // === transactions ===
  async executeTx({ signedTx, waitForTxOptions = this.waitForTxOptions, txRespOptions = this.txRespOptions, dryRun = false, sender }) {
    if (dryRun) {
      return this.dryRunTx({ tx: signedTx.bytes, sender });
    }
    const resp = await this.suiClient.executeTransactionBlock({
      transactionBlock: signedTx.bytes,
      signature: signedTx.signature,
      options: txRespOptions
    });
    if (resp.effects && resp.effects.status.status !== "success") {
      throw new Error(`Transaction failed: ${JSON.stringify(resp, null, 2)}`);
    }
    if (!waitForTxOptions) {
      return resp;
    }
    return await this.suiClient.waitForTransaction({
      digest: resp.digest,
      options: txRespOptions,
      timeout: waitForTxOptions.timeout,
      pollInterval: waitForTxOptions.pollInterval
    });
  }
  async signAndExecuteTx({ tx, waitForTxOptions = this.waitForTxOptions, txRespOptions = this.txRespOptions, dryRun = false, sender }) {
    if (dryRun) {
      return await this.dryRunTx({ tx, sender });
    }
    const signedTx = await this.signTx(tx);
    const resp = await this.executeTx({ signedTx, waitForTxOptions, txRespOptions });
    return resp;
  }
  async dryRunTx({ tx, sender = "0x7777777777777777777777777777777777777777777777777777777777777777" }) {
    const resp = await this.suiClient.devInspectTransactionBlock({
      sender,
      transactionBlock: tx
    });
    if (resp.effects && resp.effects.status.status !== "success") {
      throw new Error(`Transaction failed: ${JSON.stringify(resp, null, 2)}`);
    }
    return { digest: "", ...resp };
  }
};

// node_modules/@polymedia/suitcase-core/dist/esm/SuiEventFetcher.js
var SuiEventFetcher = class {
  // how long to sleep between RPC requests, in milliseconds
  /**
   * @param eventType     The full Sui event object type, e.g. '0x123::your_module::YourEvent'.
   * @param parseEvent    A function that can parse raw Sui events into custom objects.
   * @param nextCursor    (optional) To start fetching events starting at an old cursor.
   * @param networkName   (optional) The network name. Defaults to 'mainnet'.
   */
  constructor(suiClient, eventType, parseEvent, nextCursor = null) {
    __publicField(this, "eventType");
    __publicField(this, "parseEvent");
    __publicField(this, "eventCursor");
    __publicField(this, "suiClient");
    __publicField(this, "rateLimitDelay", 300);
    this.eventType = eventType;
    this.parseEvent = parseEvent;
    this.eventCursor = nextCursor;
    this.suiClient = suiClient;
  }
  /**
   * Fetch the latest events. Every time the function is called it looks
   * for events that took place since the last call.
   */
  async fetchEvents() {
    try {
      if (!this.eventCursor) {
        await this.fetchLastEventAndUpdateCursor();
        return [];
      } else {
        return await this.fetchEventsFromCursor();
      }
    } catch (error) {
      console.error("[SuiEventFetcher]", error);
      return [];
    }
  }
  async fetchLastEventAndUpdateCursor() {
    const suiEvents = await this.suiClient.queryEvents({
      query: { MoveEventType: this.eventType },
      limit: 1,
      order: "descending"
    });
    if (!suiEvents.nextCursor) {
      console.error("[SuiEventFetcher] unexpected missing cursor");
    } else {
      this.eventCursor = suiEvents.nextCursor;
    }
  }
  async fetchEventsFromCursor() {
    const suiEvents = await this.suiClient.queryEvents({
      query: { MoveEventType: this.eventType },
      cursor: this.eventCursor,
      order: "ascending"
      // limit: 10,
    });
    if (!suiEvents.nextCursor) {
      console.error("[SuiEventFetcher] unexpected missing cursor");
      return [];
    }
    this.eventCursor = suiEvents.nextCursor;
    const objects = [];
    for (const suiEvent of suiEvents.data) {
      const obj = this.parseEvent(suiEvent);
      if (obj) {
        objects.push(obj);
      }
    }
    if (suiEvents.hasNextPage) {
      await sleep(this.rateLimitDelay);
      const nextObjects = await this.fetchEventsFromCursor();
      objects.push(...nextObjects);
    }
    return objects;
  }
};

// node_modules/@polymedia/suitcase-core/dist/esm/rpcs.js
var RPC_ENDPOINTS = {
  "mainnet": [
    getFullnodeUrl("mainnet"),
    "https://mainnet.suiet.app",
    "https://rpc-mainnet.suiscan.xyz",
    "https://mainnet.sui.rpcpool.com",
    "https://sui-mainnet.nodeinfra.com",
    "https://mainnet-rpc.sui.chainbase.online",
    "https://sui-mainnet-ca-1.cosmostation.io",
    "https://sui-mainnet-ca-2.cosmostation.io",
    "https://sui-mainnet-us-1.cosmostation.io",
    "https://sui-mainnet-us-2.cosmostation.io"
    // "https://sui-mainnet.public.blastapi.io",            // 500
    // "https://sui-mainnet-endpoint.blockvision.org",      // 429 too many requests
    // "https://sui-rpc.publicnode.com",                    // 504 Gateway Timeout on queryTransactionBlocks() with showEffects/show*
    // "https://sui1mainnet-rpc.chainode.tech",             // CORS error
    // "https://sui-mainnet-rpc.allthatnode.com",           // 000
    // "https://sui-mainnet-rpc-korea.allthatnode.com",     // 000
    // "https://sui-mainnet-rpc-germany.allthatnode.com",   // 000
    // "https://sui-mainnet-rpc.bartestnet.com",            // 403
    // "https://sui-rpc-mainnet.testnet-pride.com",         // 502
    // "https://sui-mainnet-eu-1.cosmostation.io",          // 000
    // "https://sui-mainnet-eu-2.cosmostation.io",          // 000
    // "https://sui-mainnet-eu-3.cosmostation.io",          // CORS error
    // "https://sui-mainnet-eu-4.cosmostation.io",          // CORS error
  ],
  "testnet": [
    getFullnodeUrl("testnet"),
    "https://rpc-testnet.suiscan.xyz",
    "https://sui-testnet-endpoint.blockvision.org",
    "https://sui-testnet.public.blastapi.io",
    "https://testnet.suiet.app",
    "https://sui-testnet.nodeinfra.com",
    "https://testnet.sui.rpcpool.com",
    "https://sui-testnet-rpc.publicnode.com"
  ],
  "devnet": [
    getFullnodeUrl("devnet")
    // "https://devnet.suiet.app",                          // no data
  ],
  "localnet": [
    // to simulate multiple RPC endpoints locally
    getFullnodeUrl("localnet") + "?localnet-1",
    getFullnodeUrl("localnet") + "?localnet-2",
    getFullnodeUrl("localnet") + "?localnet-3",
    getFullnodeUrl("localnet") + "?localnet-4",
    getFullnodeUrl("localnet") + "?localnet-5"
  ]
};
async function measureRpcLatency({
  // TODO: average, p-50, p-90
  endpoints,
  rpcRequest = async (client) => {
    await client.getObject({ id: "0x123" });
  }
}) {
  const promises = endpoints.map(async (url) => {
    try {
      const suiClient = new SuiClient({ url });
      const startTime = performance.now();
      await rpcRequest(suiClient);
      const latency = performance.now() - startTime;
      return { endpoint: url, latency };
    } catch (err) {
      return { endpoint: url, error: String(err) };
    }
  });
  const results = await Promise.allSettled(promises);
  return results.map((result) => {
    if (result.status === "fulfilled") {
      return result.value;
    } else {
      return {
        endpoint: "Unknown endpoint",
        error: String(result.reason.message) || "Unknown error"
        // eslint-disable-line
      };
    }
  });
}
async function newLowLatencySuiClient({ endpoints, rpcRequest }) {
  const results = await measureRpcLatency({ endpoints, rpcRequest });
  const suiClient = new SuiClient({ url: results[0].endpoint });
  return suiClient;
}

// node_modules/@polymedia/suitcase-core/dist/esm/SuiMultiClient.js
var SuiMultiClient = class _SuiMultiClient {
  // the index of the next client to be returned by getNextClient()
  /**
   * @param endpointUrls A list of Sui RPC endpoint URLs.
   * @param rateLimitDelay (optional) Minimum time between batches, in milliseconds.
   */
  constructor(endpointUrls, rateLimitDelay = 300) {
    __publicField(this, "clients");
    __publicField(this, "rateLimitDelay");
    __publicField(this, "clientIdx");
    this.clients = [];
    this.clientIdx = 0;
    this.rateLimitDelay = rateLimitDelay;
    const endpoints = endpointUrls;
    for (const endpoint of endpoints) {
      const client = new SuiClient({ url: endpoint });
      const clientWithEndpoint = Object.assign(client, { endpoint });
      this.clients.push(clientWithEndpoint);
    }
  }
  /**
   * Create a SuiMultiClient instance with the default endpoints for a given network.
   * @param network The network name to select default RPC endpoints.
   * @param rateLimitDelay (optional) Minimum time between batches, in milliseconds.
   */
  static newWithDefaultEndpoints(network, rateLimitDelay) {
    const endpoints = RPC_ENDPOINTS[network];
    return new _SuiMultiClient(endpoints, rateLimitDelay);
  }
  /**
   * Returns a different SuiClient in a round-robin fashion
   */
  getNextClient() {
    const client = this.clients[this.clientIdx];
    this.clientIdx = (this.clientIdx + 1) % this.clients.length;
    return client;
  }
  /**
   * Execute `SuiClient` RPC operations in parallel using multiple endpoints.
   * If any operation fails, it's retried by calling this function recursively.
   * @param inputs The inputs for each RPC call.
   * @param operation A function that performs the RPC operation.
   * @returns The results of the RPC operations in the same order as the inputs.
   */
  async executeInBatches(inputs, operation, onUpdate) {
    const results = new Array(inputs.length).fill(null);
    const retries = new Array();
    const batchSize = this.clients.length;
    const totalBatches = Math.ceil(inputs.length / batchSize);
    onUpdate == null ? void 0 : onUpdate(`[SuiMultiClient] Executing ${inputs.length} operations in batches of ${batchSize}`);
    for (let start = 0, batchNum = 1; start < inputs.length; start += batchSize, batchNum++) {
      onUpdate == null ? void 0 : onUpdate(`[SuiMultiClient] Processing batch ${batchNum} of ${totalBatches}`);
      const batch = inputs.slice(start, start + batchSize);
      const timeStart = Date.now();
      const batchResults = await Promise.allSettled(batch.map((input) => {
        const client = this.getNextClient();
        return operation(client, input);
      }));
      const timeTaken = Date.now() - timeStart;
      batchResults.forEach((result, index) => {
        if (result.status === "fulfilled") {
          results[start + index] = result.value;
        } else {
          onUpdate == null ? void 0 : onUpdate(`[SuiMultiClient] ERROR. status: ${result.status}, reason: ${result.reason}`);
          retries.push(batch[index]);
        }
      });
      if (timeTaken < this.rateLimitDelay) {
        await sleep(this.rateLimitDelay - timeTaken);
      }
    }
    if (retries.length > 0) {
      const retryResults = await this.executeInBatches(retries, operation);
      for (let i = 0, retryIndex = 0; i < results.length; i++) {
        if (results[i] === null) {
          results[i] = retryResults[retryIndex++];
        }
      }
    }
    return results;
  }
  /**
   * Test the latency of various Sui RPC endpoints.
   */
  async testEndpoints(operation) {
    console.log(`testing ${this.clients.length} endpoints`);
    console.time("total time");
    for (const client of this.clients) {
      console.time(`time: ${client.endpoint}`);
      await operation(client);
      console.timeEnd(`time: ${client.endpoint}`);
    }
    console.log("");
    console.timeEnd("total time");
  }
};

// node_modules/@polymedia/suitcase-core/dist/esm/addresses.js
function generateRandomAddress() {
  const randomByteHex = () => Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
  const address = "0x" + Array.from({ length: 32 }, randomByteHex).join("");
  return address;
}
function removeAddressLeadingZeros(address) {
  return address.replaceAll(/0x0+/g, "0x");
}
function shortenAddress(text, start = 4, end = 4, separator = "…", prefix = "0x") {
  if (!text)
    return "";
  const addressRegex = /0[xX][a-fA-F0-9]{1,}/g;
  return text.replace(addressRegex, (match) => {
    if (match.length - prefix.length <= start + end) {
      return match;
    }
    return prefix + match.slice(2, 2 + start) + separator + match.slice(-end);
  });
}
function validateAndNormalizeAddress(address) {
  if (address.length === 0) {
    return null;
  }
  const normalizedAddr = normalizeSuiAddress(address);
  if (!isValidSuiAddress(normalizedAddr)) {
    return null;
  }
  return normalizedAddr;
}

// node_modules/@polymedia/suitcase-core/dist/esm/apis.js
async function apiRequestIndexer(apiUser, apiKey, query) {
  const resp = await fetch("https://api.indexer.xyz/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-user": apiUser,
      "x-api-key": apiKey
    },
    body: JSON.stringify({ query })
  });
  if (!resp.ok) {
    throw new Error(`HTTP error: ${resp.status}`);
  }
  return resp.json();
}

// node_modules/@polymedia/suitcase-core/dist/esm/balances.js
function balanceToString(value, coinDecimals) {
  if (value === 0n) {
    return "0";
  }
  const isNegative = value < 0n;
  const absoluteValue = isNegative ? -value : value;
  const valStr = absoluteValue.toString();
  if (coinDecimals === 0) {
    return (isNegative ? "-" : "") + valStr;
  }
  const paddedValStr = valStr.padStart(coinDecimals + 1, "0");
  const integerPart = paddedValStr.slice(0, -coinDecimals);
  const fractionalPart = paddedValStr.slice(-coinDecimals);
  let result = `${integerPart}.${fractionalPart}`;
  result = result.replace(/\.?0+$/, "");
  return isNegative ? `-${result}` : result;
}
function stringToBalance(value, coinDecimals) {
  value = value.trim();
  if (["", ".", "-"].includes(value)) {
    return 0n;
  }
  if ("-." === value || !/^-?\d*\.?\d*$/.test(value)) {
    throw new Error("Invalid input");
  }
  const [integerPart, rawDecimalPart = ""] = value.split(".");
  const decimalPart = rawDecimalPart.slice(0, coinDecimals);
  const fullNumber = integerPart + decimalPart.padEnd(coinDecimals, "0");
  return BigInt(fullNumber);
}
function formatNumber(num2, format = "standard") {
  if (format === "standard") {
    return formatNumberStandard(num2);
  } else {
    return formatNumberCompact(num2);
  }
}
function formatNumberStandard(num2) {
  if (num2 < 1) {
    return String(num2);
  } else if (num2 < 1e3) {
    return num2.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  } else {
    return num2.toLocaleString("en-US", { maximumFractionDigits: 0 });
  }
}
function formatNumberCompact(num2) {
  if (num2 < 1e6) {
    return formatNumberStandard(num2);
  } else if (num2 < 1e9) {
    return formatNumberStandard(num2 / 1e6) + "M";
  } else if (num2 < 1e12) {
    return formatNumberStandard(num2 / 1e9) + "B";
  } else {
    return formatNumberStandard(num2 / 1e12) + "T";
  }
}
function formatBalance(big, decimals, format = "standard") {
  const isNegative = big < 0n;
  const absoluteBig = isNegative ? -big : big;
  const stringValue = balanceToString(absoluteBig, decimals);
  if (stringValue === "0") {
    return "0.00";
  }
  const [integerPart, fractionalPart = ""] = stringValue.split(".");
  const result = format === "standard" ? formatBigIntStandard(integerPart, fractionalPart) : formatBigIntCompact(integerPart, fractionalPart);
  return isNegative ? "-" + result : result;
}
function formatBigIntStandard(integerPart, fractionalPart) {
  const bigIntValue = BigInt(integerPart);
  if (bigIntValue === 0n && fractionalPart !== "") {
    const significantDecimals = fractionalPart.replace(/0+$/, "");
    return `0.${significantDecimals}`;
  }
  if (bigIntValue < 1000n) {
    const formattedFraction = fractionalPart.slice(0, 2).padEnd(2, "0");
    return `${integerPart}.${formattedFraction}`;
  } else {
    return integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
}
function formatBigIntCompact(integerPart, fractionalPart) {
  const bigIntValue = BigInt(integerPart);
  if (bigIntValue < 1000000n) {
    return formatBigIntStandard(integerPart, fractionalPart);
  } else if (bigIntValue < 1000000000n) {
    return formatCompactPart(integerPart, 6, "M");
  } else if (bigIntValue < 1000000000000n) {
    return formatCompactPart(integerPart, 9, "B");
  } else {
    return formatCompactPart(integerPart, 12, "T");
  }
}
function formatCompactPart(integerPart, digits, suffix) {
  const wholePart = integerPart.slice(0, -digits) || "0";
  const decimalPart = integerPart.slice(-digits).padStart(2, "0").slice(0, 2);
  if (wholePart.length <= 3) {
    return `${wholePart}.${decimalPart}${suffix}`;
  } else {
    return `${addThousandsSeparators(wholePart)}${suffix}`;
  }
}
function addThousandsSeparators(numStr) {
  return numStr.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// node_modules/@polymedia/suitcase-core/dist/esm/constants.js
var MAX_U64 = 18446744073709551615n;
var NORMALIZED_0x0_ADDRESS = "0x0000000000000000000000000000000000000000000000000000000000000000";
var NORMALIZED_SUI_TYPE = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
var REGEX_ADDRESS = "0[xX][0-9a-fA-F]{1,64}";
var REGEX_ADDRESS_NORMALIZED = "0[xX][a-fA-F0-9]{64}";
var REGEX_MODULE_NAME = "[A-Za-z][A-Za-z0-9_]*";
var REGEX_STRUCT_NAME = "[A-Z][a-zA-Z0-9_]*";
var REGEX_TYPE_BASIC = `${REGEX_ADDRESS}::${REGEX_MODULE_NAME}::${REGEX_STRUCT_NAME}`;
var RPC_QUERY_MAX_RESULTS = 50;

// node_modules/@polymedia/suitcase-core/dist/esm/clients.js
async function devInspectAndGetExecutionResults(suiClient, tx, sender = "0x7777777777777777777777777777777777777777777777777777777777777777") {
  var _a;
  const resp = await suiClient.devInspectTransactionBlock({
    sender,
    transactionBlock: tx
  });
  if (resp.error) {
    throw new Error(`Response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (!((_a = resp.results) == null ? void 0 : _a.length)) {
    throw new Error(`Response has no results: ${JSON.stringify(resp, null, 2)}`);
  }
  return resp.results;
}
async function devInspectAndGetReturnValues(suiClient, tx, blockParsers, sender = "0x7777777777777777777777777777777777777777777777777777777777777777") {
  var _a;
  const blockResults = await devInspectAndGetExecutionResults(suiClient, tx, sender);
  if (blockParsers.length !== blockResults.length) {
    throw new Error(`You provided parsers for ${blockParsers.length} txs but the txblock contains ${blockResults.length} txs`);
  }
  const blockReturns = [];
  for (const [txIdx, txResult] of blockResults.entries()) {
    if (!((_a = txResult.returnValues) == null ? void 0 : _a.length)) {
      throw new Error(`Transaction ${txIdx} didn't return any values: ${JSON.stringify(txResult, null, 2)}`);
    }
    const txParsers = blockParsers[txIdx];
    if (txParsers.length !== txResult.returnValues.length) {
      throw new Error(`You provided parsers for ${txParsers.length} return values but tx ${txIdx} contains ${txResult.returnValues.length} return values`);
    }
    const txReturns = [];
    for (const [valueIdx, value] of txResult.returnValues.entries()) {
      const parser = txParsers[valueIdx];
      const valueData = Uint8Array.from(value[0]);
      const valueDeserialized = parser.parse(valueData);
      txReturns.push(valueDeserialized);
    }
    blockReturns.push(txReturns);
  }
  return blockReturns;
}
async function fetchDynamicFields({ client, parentId, limit, cursor, sleepMsBetweenReqs, onUpdate }) {
  const fields = [];
  let hasNextPage = true;
  while (hasNextPage && (!limit || fields.length < limit)) {
    onUpdate == null ? void 0 : onUpdate(`Fetching batch ${fields.length}${limit ? `/${limit}` : ""}`);
    const batchLimit = !limit ? RPC_QUERY_MAX_RESULTS : Math.min(RPC_QUERY_MAX_RESULTS, limit - fields.length);
    const page = await client.getDynamicFields({
      parentId,
      cursor,
      limit: batchLimit
    });
    fields.push(...page.data);
    hasNextPage = page.hasNextPage;
    cursor = page.nextCursor;
    sleepMsBetweenReqs && await sleep(sleepMsBetweenReqs);
  }
  return { data: fields, hasNextPage, cursor };
}
async function getCoinOfValue(suiClient, tx, owner, coinType, coinValue) {
  let coinOfValue;
  coinType = removeAddressLeadingZeros(coinType);
  if (coinType === "0x2::sui::SUI") {
    coinOfValue = tx.splitCoins(tx.gas, [tx.pure.u64(coinValue)]);
  } else {
    const paginatedCoins = await suiClient.getCoins({ owner, coinType });
    const [firstCoin, ...otherCoins] = paginatedCoins.data;
    const firstCoinInput = tx.object(firstCoin.coinObjectId);
    if (otherCoins.length > 0) {
      tx.mergeCoins(firstCoinInput, otherCoins.map((coin) => coin.coinObjectId));
    }
    coinOfValue = tx.splitCoins(firstCoinInput, [tx.pure.u64(coinValue)]);
  }
  return coinOfValue;
}
async function getSuiObjectRef(suiClient, objectId) {
  const resp = await suiClient.getObject({ id: objectId });
  if (resp.error || !resp.data) {
    throw new Error(`[getSuiObjectRef] failed to fetch objectId | error: ${JSON.stringify(resp.error)}`);
  }
  return {
    objectId: resp.data.objectId,
    digest: resp.data.digest,
    version: resp.data.version
  };
}

// node_modules/@polymedia/suitcase-core/dist/esm/coins.js
var CoinMetaFetcher = class {
  constructor({ client, preloadUrl = "https://coinmeta.polymedia.app/api/data.json", preloadData }) {
    __publicField(this, "client");
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    this.client = client;
    if (preloadData) {
      preloadData.forEach((coinMeta) => {
        this.cache.set(coinMeta.type, coinMeta);
      });
    }
    if (preloadUrl) {
      (async () => {
        try {
          const resp = await fetch(preloadUrl);
          const data = await resp.json();
          if (!Array.isArray(data)) {
            throw new Error("Invalid preload data");
          }
          for (const m of data) {
            if (typeof m !== "object" || m === null) {
              throw new Error("Invalid preload data");
            }
            if (typeof m.type !== "string" || typeof m.symbol !== "string" || typeof m.decimals !== "number" || typeof m.name !== "string" || typeof m.description !== "string" || m.id !== void 0 && typeof m.id !== "string" && m.id !== null || m.iconUrl !== void 0 && typeof m.iconUrl !== "string" && m.iconUrl !== null) {
              continue;
            }
            this.cache.set(m.type, m);
          }
        } catch (err) {
          console.warn(`Failed to preload coin metadata from "${preloadUrl}":`, err);
        }
      })();
    }
  }
  async getCoinMeta(coinType) {
    const normalizedType = normalizeStructTag(coinType);
    const cachedMeta = this.cache.get(normalizedType);
    if (cachedMeta !== void 0) {
      return cachedMeta;
    }
    const rawMeta = await this.client.getCoinMetadata({ coinType: normalizedType });
    const coinMeta = !rawMeta ? null : {
      id: rawMeta.id ?? null,
      type: normalizedType,
      symbol: rawMeta.symbol,
      decimals: rawMeta.decimals,
      name: rawMeta.name,
      description: rawMeta.description,
      iconUrl: rawMeta.iconUrl ?? null
    };
    this.cache.set(normalizedType, coinMeta);
    return coinMeta;
  }
  async getCoinMetas(coinTypes) {
    const uniqueTypes = Array.from(new Set(coinTypes.map((coinType) => normalizeStructTag(coinType))));
    const results = await Promise.allSettled(uniqueTypes.map((coinType) => this.getCoinMeta(coinType)));
    const metas = /* @__PURE__ */ new Map();
    results.forEach((result, index) => {
      metas.set(uniqueTypes[index], result.status === "fulfilled" ? result.value : null);
    });
    return metas;
  }
};

// node_modules/@polymedia/suitcase-core/dist/esm/errors.js
function anyToStr(val) {
  if (val === null || val === void 0) {
    return null;
  }
  const str = val instanceof Error ? val.message : typeof val === "string" ? val : (() => {
    try {
      return JSON.stringify(val);
    } catch {
      return String(val);
    }
  })();
  return str.trim() || null;
}
function parseMoveAbort(error) {
  const match = /MoveAbort.*address:\s*(.*?),.* name:.*Identifier\((.*?)\).*instruction:\s+(\d+),.*function_name:.*Some\((.*?)\).*},\s*(\d+).*in command\s*(\d+)/.exec(error);
  if (!match) {
    return null;
  }
  const cleanString = (s) => s.replace(/\\/g, "").replace(/"/g, "");
  return {
    packageId: "0x" + match[1],
    module: cleanString(match[2]),
    instruction: parseInt(match[3]),
    function: cleanString(match[4]),
    code: parseInt(match[5]),
    command: parseInt(match[6])
  };
}
var TxErrorParser = class {
  constructor(packageId, errInfos) {
    __publicField(this, "packageId");
    __publicField(this, "errInfos");
    this.packageId = packageId;
    this.errInfos = errInfos;
  }
  /**
   * Convert a transaction error into a user-friendly message.
   * @param err The error object/string to parse
   * @param defaultMsg Default message if error can't be parsed or is not a known error
   * @param customMsgs Optional map of error symbols to custom messages
   * @returns User-friendly error message or null if user rejected
   */
  errToStr(err, defaultMsg, customMsgs) {
    const str = anyToStr(err);
    if (!str) {
      return defaultMsg;
    }
    if (str.includes("User rejected")) {
      return null;
    }
    if (str.includes("InsufficientCoinBalance")) {
      return "You don't have enough balance";
    }
    const parsed = parseMoveAbort(str);
    if (!parsed || parsed.packageId !== this.packageId || !(parsed.code in this.errInfos)) {
      return str;
    }
    const info = this.errInfos[parsed.code];
    if (customMsgs && info.symbol in customMsgs) {
      return customMsgs[info.symbol];
    }
    return info.msg || info.symbol;
  }
};

// node_modules/@mysten/sui/dist/esm/faucet/faucet.js
var FaucetRateLimitError = class extends Error {
};
async function faucetRequest({ host, path, body, headers, method }) {
  const endpoint = new URL(path, host).toString();
  const res = await fetch(endpoint, {
    method,
    body: body ? JSON.stringify(body) : void 0,
    headers: {
      "Content-Type": "application/json",
      ...headers || {}
    }
  });
  if (res.status === 429) {
    throw new FaucetRateLimitError(
      `Too many requests from this client have been sent to the faucet. Please retry later`
    );
  }
  try {
    const parsed = await res.json();
    return parsed;
  } catch (e) {
    throw new Error(
      `Encountered error when parsing response from faucet, error: ${e}, status ${res.status}, response ${res}`
    );
  }
}
async function requestSuiFromFaucetV2(input) {
  const response = await faucetRequest({
    host: input.host,
    path: "/v2/gas",
    body: {
      FixedAmountRequest: {
        recipient: input.recipient
      }
    },
    headers: input.headers,
    method: "POST"
  });
  if (response.status !== "Success") {
    throw new Error(`Faucet request failed: ${response.status.Failure.internal}`);
  }
  return response;
}

// node_modules/@polymedia/suitcase-core/dist/esm/faucets.js
async function requestSuiFromFaucet(network, recipient) {
  let host;
  if (network == "localnet") {
    host = "http://127.0.0.1:9123";
  } else if (network == "devnet") {
    host = "https://faucet.devnet.sui.io";
  } else {
    host = "https://faucet.testnet.sui.io";
  }
  return requestSuiFromFaucetV2({ host, recipient });
}

// node_modules/@polymedia/suitcase-core/dist/esm/format.js
var TimeUnit;
(function(TimeUnit2) {
  TimeUnit2[TimeUnit2["ONE_SECOND"] = 1e3] = "ONE_SECOND";
  TimeUnit2[TimeUnit2["ONE_MINUTE"] = 6e4] = "ONE_MINUTE";
  TimeUnit2[TimeUnit2["ONE_HOUR"] = 36e5] = "ONE_HOUR";
  TimeUnit2[TimeUnit2["ONE_DAY"] = 864e5] = "ONE_DAY";
})(TimeUnit || (TimeUnit = {}));
var formatBps = (bps) => {
  return `${bps / 100}%`;
};
var formatDate = (ms) => {
  return new Date(ms).toLocaleString();
};
var formatDuration = (ms) => {
  const formatUnit = (value, unit) => `${value} ${unit}${value !== 1 ? "s" : ""}`;
  if (ms >= Number(TimeUnit.ONE_DAY)) {
    return formatUnit(Math.floor(ms / TimeUnit.ONE_DAY), "day");
  }
  if (ms >= Number(TimeUnit.ONE_HOUR)) {
    return formatUnit(Math.floor(ms / TimeUnit.ONE_HOUR), "hour");
  }
  if (ms >= Number(TimeUnit.ONE_MINUTE)) {
    return formatUnit(Math.floor(ms / TimeUnit.ONE_MINUTE), "minute");
  }
  return formatUnit(Math.floor(ms / TimeUnit.ONE_SECOND), "second");
};
function formatTimeDiff({ timestamp, now = Date.now(), format = "short", minTimeUnit = TimeUnit.ONE_SECOND }) {
  if (!timestamp)
    return "";
  let diff = Math.abs(now - timestamp);
  if (diff < Number(minTimeUnit)) {
    return getEndLabel(minTimeUnit, format);
  }
  let timeUnit;
  if (diff >= Number(TimeUnit.ONE_DAY)) {
    timeUnit = [
      [TIME_LABEL.day[format], TimeUnit.ONE_DAY],
      [TIME_LABEL.hour[format], TimeUnit.ONE_HOUR]
    ];
  } else if (diff >= Number(TimeUnit.ONE_HOUR)) {
    timeUnit = [
      [TIME_LABEL.hour[format], TimeUnit.ONE_HOUR],
      [TIME_LABEL.min[format], TimeUnit.ONE_MINUTE]
    ];
  } else {
    timeUnit = [
      [TIME_LABEL.min[format], TimeUnit.ONE_MINUTE],
      [TIME_LABEL.sec[format], TimeUnit.ONE_SECOND]
    ];
  }
  const convertAmount = (amount, label) => {
    const spacing = format === "short" ? "" : " ";
    if (amount > 1)
      return `${amount}${spacing}${label}${format === "long" ? "s" : ""}`;
    if (amount === 1)
      return `${amount}${spacing}${label}`;
    return "";
  };
  const resultArr = timeUnit.map(([label, denom]) => {
    const whole = Math.floor(diff / denom);
    diff = diff - whole * denom;
    return convertAmount(whole, label);
  });
  const result = resultArr.join(" ").trim();
  return result || getEndLabel(minTimeUnit, format);
}
var TIME_LABEL = {
  year: { long: "year", short: "y" },
  month: { long: "month", short: "m" },
  day: { long: "day", short: "d" },
  hour: { long: "hour", short: "h" },
  min: { long: "min", short: "m" },
  sec: { long: "sec", short: "s" }
};
function getEndLabel(minTimeUnit, format) {
  let minLabel = "";
  switch (minTimeUnit) {
    case TimeUnit.ONE_DAY:
      minLabel = TIME_LABEL.day[format];
      break;
    case TimeUnit.ONE_HOUR:
      minLabel = TIME_LABEL.hour[format];
      break;
    case TimeUnit.ONE_MINUTE:
      minLabel = TIME_LABEL.min[format];
      break;
    default:
      minLabel = TIME_LABEL.sec[format];
  }
  if (format === "short") {
    return `< 1${minLabel}`;
  } else {
    return `< 1 ${minLabel}`;
  }
}
var urlToDomain = (url) => {
  const match = /^https?:\/\/([^/]+)/.exec(url);
  return match ? match[1] : "";
};
var shortenDigest = (digest, start = 4, end = 4, separator = "…") => {
  return digest.slice(0, start) + separator + digest.slice(-end);
};

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n, P) * b3 % P;
  const b9 = pow2(b6, _3n, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y) => y % _2n === _0n;
function schnorrGetExtPubKey(priv) {
  const { Fn, BASE } = Pointk1;
  const d_ = _normFnElement(Fn, priv);
  const p = BASE.multiply(d_);
  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  const Fp = Fpk1;
  if (!Fp.isValidNot0(x))
    throw new Error("invalid x: Fail if x ≥ p");
  const xx = Fp.create(x * x);
  const c = Fp.create(xx * x + BigInt(7));
  let y = Fp.sqrt(c);
  if (!hasEven(y))
    y = Fp.neg(y);
  const p = Pointk1.fromAffine({ x, y });
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn } = Pointk1;
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn, BASE } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n, secp256k1_CURVE.p))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n, secp256k1_CURVE.n))
      return false;
    const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      MD5_W[i] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i = 0; i < 64; i++) {
      let F, g, s;
      if (i < 16) {
        F = Chi(B, C, D);
        g = i;
        s = [7, 12, 17, 22];
      } else if (i < 32) {
        F = Chi(D, B, C);
        g = (5 * i + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i < 48) {
        F = B ^ C ^ D;
        g = (3 * i + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i % 16;
        s = [6, 10, 15, 21];
      }
      F = F + A + K[i] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s[i % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
function bytesToNumber(bytes) {
  abytes(bytes);
  const h = bytes.length === 0 ? "0" : bytesToHex(bytes);
  return BigInt("0x" + h);
}
function numberToBytes(num2) {
  if (typeof num2 !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes(num2.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha256(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n) => {
  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
    throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    abytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
    }
    const I = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I.slice(32),
      privateKey: I.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return _HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path) {
    if (!/^[mM]'?/.test(path)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path)) {
      return this;
    }
    const parts = path.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c of parts) {
      const m = /^(\d+)('?)$/.exec(c);
      const m1 = m && m[1];
      if (!m || m.length !== 3 || typeof m1 !== "string")
        throw new Error("invalid child index: " + c);
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index);
    if (index >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I.slice(0, 32));
    const chainCode = I.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
        if (added.equals(Point.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index + 1);
    }
  }
  sign(hash) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    abytes(hash, 32);
    return secp256k1.sign(hash, this.privKey).toCompactRawBytes();
  }
  verify(hash, signature) {
    abytes(hash, 32);
    abytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k1.verify(sig, hash, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    abytes(key, 33);
    return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/@mysten/sui/dist/esm/keypairs/secp256k1/publickey.js
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class extends PublicKey {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256k1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedKeypairSignature(signature);
      if (parsed.signatureScheme !== "Secp256k1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256k1.verify(
      secp256k1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/sui/dist/esm/keypairs/secp256k1/keypair.js
var DEFAULT_SECP256K1_DERIVATION_PATH = "m/54'/784'/0'/0/0";
var Secp256k1Keypair = class _Secp256k1Keypair extends Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Secp256k1Keypair} is provided.
   *
   * @param keypair secp256k1 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = keypair;
    } else {
      const secretKey = secp256k1.utils.randomPrivateKey();
      const publicKey = secp256k1.getPublicKey(secretKey, true);
      this.keypair = { publicKey, secretKey };
    }
  }
  /**
   * Get the key scheme of the keypair Secp256k1
   */
  getKeyScheme() {
    return "Secp256k1";
  }
  /**
   * Generate a new random keypair
   */
  static generate() {
    return new _Secp256k1Keypair();
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array  or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey(secretKey);
      if (decoded.schema !== "Secp256k1") {
        throw new Error(`Expected a Secp256k1 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const publicKey = secp256k1.getPublicKey(secretKey, true);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const msgHash = bytesToHex(blake2b(signData, { dkLen: 32 }));
      const signature = secp256k1.sign(msgHash, secretKey);
      if (!secp256k1.verify(signature, msgHash, publicKey, { lowS: true })) {
        throw new Error("Provided secretKey is invalid");
      }
    }
    return new _Secp256k1Keypair({ publicKey, secretKey });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   */
  static fromSeed(seed) {
    const publicKey = secp256k1.getPublicKey(seed, true);
    return new _Secp256k1Keypair({ publicKey, secretKey: seed });
  }
  /**
   * The public key for this keypair
   */
  getPublicKey() {
    return new Secp256k1PublicKey(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Secp256k1 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey(this.keypair.secretKey, this.getKeyScheme());
  }
  /**
   * Return the signature for the provided data.
   */
  async sign(data) {
    const msgHash = sha2562(data);
    const sig = secp256k1.sign(msgHash, this.keypair.secretKey, {
      lowS: true
    });
    return sig.toCompactRawBytes();
  }
  /**
   * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must
   * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_SECP256K1_DERIVATION_PATH;
    }
    if (!isValidBIP32Path(path)) {
      throw new Error("Invalid derivation path");
    }
    const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);
    if (key.publicKey == null || key.privateKey == null) {
      throw new Error("Invalid key");
    }
    return new _Secp256k1Keypair({
      publicKey: key.publicKey,
      secretKey: key.privateKey
    });
  }
};

// node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/publickey.js
var SECP256R1_PUBLIC_KEY_SIZE = 33;
var Secp256r1PublicKey = class extends PublicKey {
  /**
   * Create a new Secp256r1PublicKey object
   * @param value secp256r1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    super();
    if (typeof value === "string") {
      this.data = fromBase64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256r1 public keys are equal
   */
  equals(publicKey) {
    return super.equals(publicKey);
  }
  /**
   * Return the byte array representation of the Secp256r1 public key
   */
  toRawBytes() {
    return this.data;
  }
  /**
   * Return the Sui address associated with this Secp256r1 public key
   */
  flag() {
    return SIGNATURE_SCHEME_TO_FLAG["Secp256r1"];
  }
  /**
   * Verifies that the signature is valid for for the provided message
   */
  async verify(message, signature) {
    let bytes;
    if (typeof signature === "string") {
      const parsed = parseSerializedSignature(signature);
      if (parsed.signatureScheme !== "Secp256r1") {
        throw new Error("Invalid signature scheme");
      }
      if (!bytesEqual(this.toRawBytes(), parsed.publicKey)) {
        throw new Error("Signature does not match public key");
      }
      bytes = parsed.signature;
    } else {
      bytes = signature;
    }
    return secp256r1.verify(
      secp256r1.Signature.fromCompact(bytes),
      sha2562(message),
      this.toRawBytes()
    );
  }
};
Secp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;

// node_modules/@mysten/sui/dist/esm/keypairs/secp256r1/keypair.js
var DEFAULT_SECP256R1_DERIVATION_PATH = "m/74'/784'/0'/0/0";
var Secp256r1Keypair = class _Secp256r1Keypair extends Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Secp256r1Keypair} is provided.
   *
   * @param keypair Secp256r1 keypair
   */
  constructor(keypair) {
    super();
    if (keypair) {
      this.keypair = keypair;
    } else {
      const secretKey = secp256r1.utils.randomPrivateKey();
      const publicKey = secp256r1.getPublicKey(secretKey, true);
      this.keypair = { publicKey, secretKey };
    }
  }
  /**
   * Get the key scheme of the keypair Secp256r1
   */
  getKeyScheme() {
    return "Secp256r1";
  }
  /**
   * Generate a new random keypair
   */
  static generate() {
    return new _Secp256r1Keypair();
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array or Bech32 secret key string
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (typeof secretKey === "string") {
      const decoded = decodeSuiPrivateKey(secretKey);
      if (decoded.schema !== "Secp256r1") {
        throw new Error(`Expected a Secp256r1 keypair, got ${decoded.schema}`);
      }
      return this.fromSecretKey(decoded.secretKey, options);
    }
    const publicKey = secp256r1.getPublicKey(secretKey, true);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const msgHash = bytesToHex(blake2b(signData, { dkLen: 32 }));
      const signature = secp256r1.sign(msgHash, secretKey, { lowS: true });
      if (!secp256r1.verify(signature, msgHash, publicKey, { lowS: true })) {
        throw new Error("Provided secretKey is invalid");
      }
    }
    return new _Secp256r1Keypair({ publicKey, secretKey });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   */
  static fromSeed(seed) {
    const publicKey = secp256r1.getPublicKey(seed, true);
    return new _Secp256r1Keypair({ publicKey, secretKey: seed });
  }
  /**
   * The public key for this keypair
   */
  getPublicKey() {
    return new Secp256r1PublicKey(this.keypair.publicKey);
  }
  /**
   * The Bech32 secret key string for this Secp256r1 keypair
   */
  getSecretKey() {
    return encodeSuiPrivateKey(this.keypair.secretKey, this.getKeyScheme());
  }
  /**
   * Return the signature for the provided data.
   */
  async sign(data) {
    const msgHash = sha2562(data);
    const sig = secp256r1.sign(msgHash, this.keypair.secretKey, {
      lowS: true
    });
    return sig.toCompactRawBytes();
  }
  /**
   * Derive Secp256r1 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/74'/784'/0'/0/0, otherwise the path must
   * be compliant to BIP-32 in form m/74'/784'/{account_index}'/{change_index}/{address_index}.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_SECP256R1_DERIVATION_PATH;
    }
    if (!isValidBIP32Path(path)) {
      throw new Error("Invalid derivation path");
    }
    const privateKey = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path).privateKey;
    return _Secp256r1Keypair.fromSecretKey(privateKey);
  }
};

// node_modules/@polymedia/suitcase-core/dist/esm/keypairs.js
function pairFromSecretKey(secretKey) {
  const pair = decodeSuiPrivateKey(secretKey);
  if (pair.schema === "ED25519") {
    return Ed25519Keypair.fromSecretKey(pair.secretKey);
  }
  if (pair.schema === "Secp256k1") {
    return Secp256k1Keypair.fromSecretKey(pair.secretKey);
  }
  if (pair.schema === "Secp256r1") {
    return Secp256r1Keypair.fromSecretKey(pair.secretKey);
  }
  throw new Error(`Unrecognized keypair schema: ${pair.schema}`);
}

// node_modules/@polymedia/suitcase-core/dist/esm/txs.js
function getArgVal(arg) {
  if (arg.type === "pure") {
    return arg.value;
  }
  return arg.objectId;
}
function newSignTx(suiClient, signer) {
  return async (tx) => {
    tx.setSenderIfNotSet(signer.toSuiAddress());
    const txBytes = await tx.build({ client: suiClient });
    return signer.signTransaction(txBytes);
  };
}
function objectArg(tx, obj) {
  return isSuiObjectRef(obj) ? tx.objectRef(obj) : tx.object(obj);
}
function txResToData(resp) {
  var _a;
  if (resp.errors && resp.errors.length > 0) {
    throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
  }
  if (((_a = resp.transaction) == null ? void 0 : _a.data.transaction.kind) !== "ProgrammableTransaction") {
    throw Error(`response has no data or is not a ProgrammableTransaction: ${JSON.stringify(resp, null, 2)}`);
  }
  return {
    sender: resp.transaction.data.sender,
    gasData: resp.transaction.data.gasData,
    inputs: resp.transaction.data.transaction.inputs,
    txs: resp.transaction.data.transaction.transactions
  };
}
var TransferModule = {
  public_freeze_object(tx, obj_type, obj) {
    return tx.moveCall({
      target: "0x2::transfer::public_freeze_object",
      typeArguments: [obj_type],
      arguments: [objectArg(tx, obj)]
    });
  },
  public_share_object(tx, obj_type, obj) {
    return tx.moveCall({
      target: "0x2::transfer::public_share_object",
      typeArguments: [obj_type],
      arguments: [objectArg(tx, obj)]
    });
  },
  public_transfer(tx, obj_type, obj, recipient) {
    return tx.moveCall({
      target: "0x2::transfer::public_transfer",
      typeArguments: [obj_type],
      arguments: [
        objectArg(tx, obj),
        tx.pure.address(recipient)
      ]
    });
  }
};

// node_modules/@polymedia/suitcase-core/dist/esm/types.js
var NETWORK_NAMES = ["mainnet", "testnet", "devnet", "localnet"];
var EmptyPaginatedResponse = {
  data: [],
  hasNextPage: false,
  nextCursor: void 0
};

// node_modules/@polymedia/suitcase-core/dist/esm/urls.js
var makePolymediaUrl = (network, kind, address) => {
  const baseUrl = "https://explorer.polymedia.app";
  let path;
  if (kind === "tx") {
    path = "txblock";
  } else if (kind === "package") {
    path = "object";
  } else if (kind === "coin") {
    path = "object";
    address = address.split("::")[0];
  } else {
    path = kind;
  }
  let url = `${baseUrl}/${path}/${address}`;
  if (network !== "mainnet") {
    const networkLabel = network === "localnet" ? "local" : network;
    url += `?network=${networkLabel}`;
  }
  return url;
};
var makeSuiscanUrl = (network, kind, address) => {
  if (isLocalnet(network)) {
    return makePolymediaUrl(network, kind, address);
  }
  const baseUrl = `https://suiscan.xyz/${network}`;
  let path;
  if (kind === "address") {
    path = "account";
  } else if (kind === "package") {
    path = "object";
  } else {
    path = kind;
  }
  const url = `${baseUrl}/${path}/${address}`;
  return url;
};
var makeSuivisionUrl = (network, kind, address) => {
  if (isLocalnet(network)) {
    return makePolymediaUrl(network, kind, address);
  }
  const baseUrl = network === "mainnet" ? "https://suivision.xyz" : `https://${network}.suivision.xyz`;
  let path;
  if (kind === "tx") {
    path = "txblock";
  } else if (kind === "address") {
    path = "account";
  } else {
    path = kind;
  }
  const url = `${baseUrl}/${path}/${address}`;
  return url;
};
function isLocalnet(network) {
  return network === "localnet" || network == "http://127.0.0.1:9000";
}

// node_modules/@polymedia/suitcase-core/dist/esm/index.js
BigInt.prototype.toJSON = function() {
  return this.toString();
};

export {
  chunkArray,
  chunkString,
  makeRanges,
  sleep,
  isOwnerKind,
  isArgKind,
  isObjChangeKind,
  isSuiObjectRef,
  isParsedDataKind,
  isTxKind,
  objResToContent,
  objResToDisplay,
  newEmptyDisplay,
  objResToFields,
  objResToId,
  objResToOwner,
  objResToRef,
  objResToType,
  SuiClientBase,
  SuiEventFetcher,
  RPC_ENDPOINTS,
  measureRpcLatency,
  newLowLatencySuiClient,
  SuiMultiClient,
  generateRandomAddress,
  removeAddressLeadingZeros,
  shortenAddress,
  validateAndNormalizeAddress,
  apiRequestIndexer,
  balanceToString,
  stringToBalance,
  formatNumber,
  formatBalance,
  MAX_U64,
  NORMALIZED_0x0_ADDRESS,
  NORMALIZED_SUI_TYPE,
  REGEX_ADDRESS,
  REGEX_ADDRESS_NORMALIZED,
  REGEX_MODULE_NAME,
  REGEX_STRUCT_NAME,
  REGEX_TYPE_BASIC,
  RPC_QUERY_MAX_RESULTS,
  devInspectAndGetExecutionResults,
  devInspectAndGetReturnValues,
  fetchDynamicFields,
  getCoinOfValue,
  getSuiObjectRef,
  CoinMetaFetcher,
  anyToStr,
  parseMoveAbort,
  TxErrorParser,
  requestSuiFromFaucet,
  TimeUnit,
  formatBps,
  formatDate,
  formatDuration,
  formatTimeDiff,
  urlToDomain,
  shortenDigest,
  pairFromSecretKey,
  getArgVal,
  newSignTx,
  objectArg,
  txResToData,
  TransferModule,
  NETWORK_NAMES,
  EmptyPaginatedResponse,
  makePolymediaUrl,
  makeSuiscanUrl,
  makeSuivisionUrl
};
/*! Bundled license information:

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-KYKTC6YG.js.map
