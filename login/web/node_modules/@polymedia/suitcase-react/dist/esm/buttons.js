import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useState } from "react";
import { Link } from "react-router-dom";
import { LinkExternal } from "./links";
/**
 * A button component.
 */
export const Btn = ({ onClick, children, disabled = undefined, className = undefined, }) => {
    const [working, setIsWorking] = useState(false);
    disabled = disabled || working;
    const handleClick = async () => {
        try {
            setIsWorking(true);
            await onClick();
        }
        finally {
            setIsWorking(false);
        }
    };
    return (_jsx("button", { onClick: handleClick, className: `btn ${working ? "working" : ""} ${className ?? ""}`, disabled: disabled, children: children }));
};
export const BtnSubmit = (props) => {
    return (_jsx("div", { className: "btn-submit", children: _jsx(Btn, { ...props }) }));
};
export const BtnLinkExternal = (props) => {
    let className = "btn";
    if (props.className) {
        className += ` ${props.className}`;
    }
    if (props.disabled) {
        className += " disabled";
    }
    return (_jsx("div", { className: "btn-submit", children: _jsx(LinkExternal, { ...props, className: className }) }));
};
export const BtnLinkInternal = forwardRef((props, ref) => {
    let className = "btn";
    if (props.className) {
        className += ` ${props.className}`;
    }
    if (props.disabled) {
        className += " disabled";
    }
    return (_jsx("div", { className: "btn-submit", children: _jsx(Link, { ...props, className: className, ref: ref }) }));
});
/**
 * A button component to navigate through paginated data (see `useFetchAndPaginate()`).
 */
export const BtnPrevNext = ({ data, onPageChange, scrollToRefOnPageChange, }) => {
    if (!data.hasMultiplePages) {
        return null;
    }
    const handlePageChange = () => {
        if (scrollToRefOnPageChange?.current) {
            const navBarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--nav-bar-height"));
            const extraOffset = 9;
            const totalOffset = navBarHeight + extraOffset;
            const yOffset = scrollToRefOnPageChange.current.getBoundingClientRect().top + window.scrollY - totalOffset;
            window.scrollTo({ top: yOffset });
        }
        onPageChange?.();
    };
    const handlePrevClick = () => {
        data.goToPreviousPage();
        handlePageChange();
        return Promise.resolve();
    };
    const handleNextClick = async () => {
        await data.goToNextPage();
        handlePageChange();
        return Promise.resolve();
    };
    return (_jsxs("div", { className: "btn-prev-next", children: [_jsx(Btn, { disabled: data.isLoading || data.isFirstPage, onClick: handlePrevClick, children: "PREV" }), _jsx(Btn, { disabled: data.isLoading || (data.isLastPage && !data.hasNextPage), onClick: handleNextClick, children: "NEXT" })] }));
};
//# sourceMappingURL=buttons.js.map