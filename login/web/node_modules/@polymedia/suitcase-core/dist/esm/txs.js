import { isSuiObjectRef } from "./guards.js";
/**
 * Get the value of a `SuiCallArg` (transaction input).
 * If the argument is a pure value, return it.
 * If the argument is an object, return its ID.
 */
export function getArgVal(arg) {
    if (arg.type === "pure") {
        return arg.value;
    }
    return arg.objectId;
}
/**
 * Create a `SignTx` function that uses a `Signer` to sign a `Transaction`.
 */
export function newSignTx(suiClient, signer) {
    return async (tx) => {
        tx.setSenderIfNotSet(signer.toSuiAddress());
        const txBytes = await tx.build({ client: suiClient });
        return signer.signTransaction(txBytes);
    };
}
/**
 * Transform an `ObjectInput` into an argument for `Transaction.moveCall()`.
 */
export function objectArg(tx, obj) {
    return isSuiObjectRef(obj)
        ? tx.objectRef(obj)
        : tx.object(obj);
}
/**
 * Validate a `SuiTransactionBlockResponse` of the `ProgrammableTransaction` kind
 * and return its `.transaction.data`.
 */
export function txResToData(resp) {
    if (resp.errors && resp.errors.length > 0) {
        throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
    }
    if (resp.transaction?.data.transaction.kind !== "ProgrammableTransaction") {
        throw Error(`response has no data or is not a ProgrammableTransaction: ${JSON.stringify(resp, null, 2)}`);
    }
    return {
        sender: resp.transaction.data.sender,
        gasData: resp.transaction.data.gasData,
        inputs: resp.transaction.data.transaction.inputs,
        txs: resp.transaction.data.transaction.transactions,
    };
}
/**
 * Build transactions for the `sui::transfer` module.
 */
export const TransferModule = {
    public_freeze_object(tx, obj_type, obj) {
        return tx.moveCall({
            target: "0x2::transfer::public_freeze_object",
            typeArguments: [obj_type],
            arguments: [objectArg(tx, obj)],
        });
    },
    public_share_object(tx, obj_type, obj) {
        return tx.moveCall({
            target: "0x2::transfer::public_share_object",
            typeArguments: [obj_type],
            arguments: [objectArg(tx, obj)],
        });
    },
    public_transfer(tx, obj_type, obj, recipient) {
        return tx.moveCall({
            target: "0x2::transfer::public_transfer",
            typeArguments: [obj_type],
            arguments: [
                objectArg(tx, obj),
                tx.pure.address(recipient),
            ],
        });
    },
};
//# sourceMappingURL=txs.js.map